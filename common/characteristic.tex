
% {\actuality} Обзор, введение в тему, обозначение места данной работы в
% мировых исследованиях и~т.\:п., можно использовать ссылки на~другие
% работы~\autocite{Gosele1999161,Lermontov}
% (если их~нет, то~в~автореферате
% автоматически пропадёт раздел <<Список литературы>>). Внимание! Ссылки
% на~другие работы в~разделе общей характеристики работы можно
% использовать только при использовании \verb!biblatex! (из-за технических
% ограничений \verb!bibtex8!. Это связано с тем, что одна
% и~та~же~характеристика используются и~в~тексте диссертации, и в
% автореферате. В~последнем, согласно ГОСТ, должен присутствовать список
% работ автора по~теме диссертации, а~\verb!bibtex8! не~умеет выводить в~одном
% файле два списка литературы).
% При использовании \verb!biblatex! возможно использование исключительно
% в~автореферате подстрочных ссылок
% для других работ командой \verb!\autocite!, а~также цитирование
% собственных работ командой \verb!\cite!. Для этого в~файле
% \verb!common/setup.tex! необходимо присвоить положительное значение
% счётчику \verb!\setcounter{usefootcite}{1}!.

% Для генерации содержимого титульного листа автореферата, диссертации
% и~презентации используются данные из файла \verb!common/data.tex!. Если,
% например, вы меняете название диссертации, то оно автоматически
% появится в~итоговых файлах после очередного запуска \LaTeX. Согласно
% ГОСТ 7.0.11-2011 <<5.1.1 Титульный лист является первой страницей
% диссертации, служит источником информации, необходимой для обработки и
% поиска документа>>. Наличие логотипа организации на~титульном листе
% упрощает обработку и~поиск, для этого разметите логотип вашей
% организации в папке images в~формате PDF (лучше найти его в векторном
% варианте, чтобы он хорошо смотрелся при печати) под именем
% \verb!logo.pdf!. Настроить размер изображения с логотипом можно
% в~соответствующих местах файлов \verb!title.tex!  отдельно для
% диссертации и автореферата. Если вам логотип не~нужен, то просто
% удалите файл с~логотипом.

% \ifsynopsis
% Этот абзац появляется только в~автореферате.
% Для формирования блоков, которые будут обрабатываться только в~автореферате,
% заведена проверка условия \verb!\!\verb!ifsynopsis!.
% Значение условия задаётся в~основном файле документа (\verb!synopsis.tex! для
% автореферата).
% \else
% Этот абзац появляется только в~диссертации.
% Через проверку условия \verb!\!\verb!ifsynopsis!, задаваемого в~основном файле
% документа (\verb!dissertation.tex! для диссертации), можно сделать новую
% команду, обеспечивающую появление цитаты в~диссертации, но~не~в~автореферате.
% \fi

% {\progress}
% Этот раздел должен быть отдельным структурным элементом по
% ГОСТ, но он, как правило, включается в описание актуальности
% темы. Нужен он отдельным структурынм элемементом или нет ---
% смотрите другие диссертации вашего совета, скорее всего не нужен.

{\actuality} 
На сегодняшний день многопоточность широко используется в самом разном программном обеспечении --- в  банковских системах, в системах реального времени, в   системном программного обеспечения (например, в ядрах операционных систем, в СУБД) и т.д. Использование  нескольких параллельно работающих взаимодействующих потоков позволяет эффективно задействовать многоядерные процессоры и значительно повысить быстродействие программ. В то же время разработка  многопоточных программ оказывается на порядок 
сложнее, чем традиционных, последовательных программ, порождая специфичные  труднообнаружимые ошибки. 
По этой причине крайне актуальной является задача 
верификации таких  программ, а
решение этой задачи, в свою очередь, требует построения  для них 
строгой математической  семантики.

Формальная семантика многопоточных программ, потоки которых работают 
с общей разделяемой памятью, называется \emph{моделью памяти (memory model)}. 
Основной задачей модели памяти является определение множества 
допустимых \emph{сценариев исполнения} программы.
Современные многопоточные системы и языки программирования, в силу 
применения компиляторами и целевыми процессорами
различных оптимизаций при сборке и выполнении программ,
допускают так называемые \emph{слабые сценарии исполнения (weak behaviours)},
то есть такие сценарии, которые не могут быть получены в результате 
 поочередного исполнения инструкций различных потоков. Соответственно, 
\emph{слабые модели памяти (weak memory models)} предназдначены для описания всего множества 
допустимых слабых сценариев исполнения программы. 


Оказывается, что вопрос о том, какие именно слабые сценарии поведения 
следует допускать, а какие нет, не является однозначным --- ответ  
зависит от требований к многопоточной программы, а также к 
языку программирования, на котором она написана. 
По этой причине в последние годы появилось (и продолжает активно появляться) 
множество различных моделей памяти как для современных мультипроцессоров, например, \Intel~\autocite{Sewell-al:CACM10}, 
\ARM~\autocite{Pulte-al:POPL18}, 
\POWER~\autocite{Sarkar-al:PLDI11}, так и для языков программирования, например, 
\CPP~\autocite{Batty-al:POPL11},
\Java~\autocite{Manson-al:POPL05}, 
\JS~\autocite{Watt-al:PLDI2020}, 
\OCaml~\autocite{Dolan-al:PLDI18},
а также для распределенных систем%
~\autocite{Jagadeesan-al:ESOP2018,Lahav-Boker:PLDI2020}.
В связи с этим является актуальной задача по формализации 
существующих моделей памяти и созданию теоретического инструментария
для разработки будущих моделей памяти.


Одним из способов задания моделей памяти
является использование семантических доменов
\emph{истинной конкурентности (true concurrency semantics)}.
Этот класс моделей позволяет выразить независимость (параллельность) атомарных событий, а также 
причинно-следственные связи между ними. Это, в свою очередь,
 ведет к более компактному представлению пространства состояний программы,
что упрощает рассуждения 
о поведении многопоточных программ как для человека, 
так и для  средств  автоматической и интерактивной верификации. 

\emph{Структуры событий (event structures)} являются одним из семантических доменов, 
относящихся к классу моделей истинной конкурентности.
В наиболее простом варианте структура событий состоит из множества атомарных событий,
функции, присваивающей каждому событию семантическую метку,
отношения причинно-следственной связи и отношения конфликта между событиями.
Классическая теория структур событий была разработана ещё в 1980-1990-х годах, а в последние годы для описания слабых моделей памяти исследователями было предложено несколько моделей,
основанных на структурах событий ---
A.Jeffrey и J.Riely~\autocite{Jeffrey-Riely:LICS16},
J.Pichon-Pharabod и P. Sewell~\autocite{PichonPharabod-Sewell:POPL16},
\Wkm~\autocite{Chakraborty-Vafeiadis:POPL19},
\MRD~\autocite{Paviotti-al:ESOP20}.
Отметим, что данные модели вводят новые классы
структур событий, несовместимые с классической теорией,
что не позволяет применять известные результаты
о структурах событий к данным моделям.
Кроме того, в рамках данных моделей даже для небольших программ
вычислительно затратно перечисление возможных слабых сценариев поведения,
что препятствует разработке эффективных средств верификации многопоточных программ.

Итак, создание формальной семантики 
многопоточных программ на основе структур событий является актуальной исследовательской задачей. При этом важно, чтобы такая семантика, с одной стороны, позволяла бы эффективно описывать слабые сценарии поведения, 
а с другой стороны, допускала бы разработку  
инструментов для автоматической и интерактивной верификации. 

{\progress}
Теория структур событий была разработана M.Nielsen, G.Plotkin и G.Winskel в 1980-1990 годы%
~\autocite{Nielsen:REX93,Sassone:MFCS1993,Vaandrager:TCS1991,Winskel-TCS:09} 
для задания денотационной семантики 
исчисления параллельных взаимодействующих систем (Calculus of Communicating Systems, CCS)%
~\autocite{Winskel:ICALP1982}.
Относительно недавно эта теория также была использована 
для задания семантики пи-исчисления процессов ($\pi$-calculus)%
~\autocite{Varacca-Nobuko:TCS10,Crafa-al:FSCCS12,Hildebrandt-al:LATA2017}.
Однако ни CCS, ни пи-исчисление не позволяют описывать 
слабые сценарии поведения многопоточных программ.

Теория слабых моделей памяти активно развивается, начиная с 1990-х годов: 
на сегодняшний день существует множество моделей памяти, 
описывающих поведение мультипроцессоров, 
многопоточных языков программирования и распределенных систем (см. обзор ~\autocite{Moiseenko-al:PCS21}). 
Эти модели, в свою очередь, можно разделить на несколько классов.

Модели, \emph{сохраняющие программный порядок}, образуют широкий класс,
включая модель \TSO процессоров семейства \Intel~\autocite{Sewell-al:CACM10},
модели последовательной согласованности (sequential consistency)~\autocite{Lamport:TC79},
причинной согласованности (causal consistency)~\autocite{Lahav-Boker:PLDI2020}
и согласованности в конечном счёте (eventual consistency)~\autocite{Jagadeesan-al:ESOP2018}. В этот же класс входят  модели памяти некоторых языков программирования, например,
языка \OCaml~\autocite{Dolan-al:PLDI18}.
Общим недостатком всех этих моделей является то,
что они не поддерживают \emph{оптимальные схемы компиляции} 
в целевой код для широко распространённых мультипроцессоров \ARM и \POWER.
Это означает, что реализация данных моделей на этих мультипроцессорах
влечет дополнительные накладные расходы и может приводить
к увеличению времени исполнения программ~\autocite{Ou-Demsky:OOPSLA18}. 

Модели памяти мультипроцессоров,
в частности, \ARM~\autocite{Pulte-al:POPL18} и \POWER~\autocite{Sarkar-al:PLDI11}, 
как правило, принадлежат к классу моделей, \emph{сохраняющих синтаксические зависимости}. 
Основное ограничение этих моделей заключается в том, 
что они не поддерживают некоторые значимые трансформации программ, 
применяемые оптимизирующими компиляторами, например, свертку констант.
По этой причине модели данного класса, как правило,
не применяются для языков программирования.  

Таким образом, модели памяти двух вышеупомянутых классов 
не отвечают требованиям, предъявляемым к моделям памяти для таких языков как \CPP и \Java. 
С целью преодоления этих ограничений исследователями были предложены модели  
\Prm~\autocite{Kang-al:POPL17}, \Wkm~\autocite{Chakraborty-Vafeiadis:POPL19}, 
\MRD~\autocite{Paviotti-al:ESOP20}, \PwP~\autocite{Jagadeesan-al:OOPSLA2020},
модели A.Jeffrey и J.Riely ~\autocite{Jeffrey-Riely:LICS16} и J.Pichon-Pharabod и P. Sewell~\autocite{PichonPharabod-Sewell:POPL16}. Все эти модели
обычно относят к классу моделей, \emph{сохраняющих семантические зависимости}.
Они, как правило, поддерживают оптимальные схемы компиляции
для современных мультипроцессоров и поддерживают широкий спектр оптимизаций программ. 


Модели, сохраняющие программный порядок и синтаксические зависимости, 
в настоящее время хорошо изучены. Напротив, модели, 
сохраняющие семантические зависимости, по-прежнему активно исследуются,
в частности, для них, фактически, не исследованы
вопросы построения эффективных инструментов автоматической и интерактивной верификации. 

%% Некоторые из вышеупомянутых моделей, сохраняющих семантические зависимости,
%% основаны на теории структур событий%
%% ~\autocite{Jeffrey-Riely:LICS16,PichonPharabod-Sewell:POPL16,
%% Chakraborty-Vafeiadis:POPL19,Paviotti-al:ESOP20}.
%% Общий недостаток данных моделей заключается в том,
%% что они вводят новые классы структур событий, 
%% несовместимые с классическими определениями.
%% Это затрудняет применение уже существующей классической теории структур событий
%% для решения проблем, возникающих в теории слабых моделей памяти. 

Рассмотрим в качестве примера язык \CPP.
Для описания модели памяти данного языка исследовательским
сообществом было выработано несколько подходов.
Модель \RCMM~\autocite{Lahav-al:PLDI17}
относится к классу моделей, сохраняющих программный порядок.
Данная модель является относительно простой и
предоставляет ряд важных и полезных свойств.
Для неё также были разработаны эффективные
средства верификации,
например, инструмент проверки моделей \genmc~\autocite{Kokologiannakis:PLDI2019}.
Однако эта модель не поддерживает
оптимальную схему компиляции в  мультипроцессоры \ARM и \POWER.
С другой стороны, модели \Prm и \Wkm,
относящиеся к классу моделей, сохраняющих семантические зависимости,
поддерживают оптимальную схему компиляции и широкий набор оптимизаций программ.
Но они оказываются существенно более сложными, их свойства слабо изучены,  и, наконец, для этих моделей
отсутствуют эффективные методы верификации программ. 

В контексте данной работы наибольший интерес
представляет именно модель \Wkm~\autocite{Chakraborty-Vafeiadis:POPL19}. Эта
модель основана на теории структур событий,
 для нее было формально доказано наличие ряда важных для практики свойств.
Однако у данной модели имеется ряд недостатков:
она  не укладывается в классическую теорию структур событий,
для нее не была доказана корректность оптимальной схемы
компиляции в модели современных мультипроцессоров,
а также для данной модели отсутствуют
средства верификации программ.

%% Для большей гибкости, данный язык предоставляет несколько
%% режимов доступа к разделяемым переменным (\emph{access modes}):
%% \emph{последовательно согласованный режим} (\emph{sequentiall consistent}),
%% режимы \emph{захвата и освобождения} (\emph{acquire/release}),
%% гарантирующие причинную согласованность~\autocite{Lahav-al:POPL16},
%% \emph{ослабленный режим} (\emph{relaxed}),
%% гарантирующий когерентность~\autocite{Alglave-al:TOPLAS14}
%% и \emph{неатомарный режим} для неконкурентных обращений к памяти. 

%% Для описания подмножества модели памяти \CPP
%% исследователями была разработана модель \RCMM~\autocite{Lahav-al:PLDI17}.
%% Данная модель полностью описывает все возможные сценарии
%% поведения многопоточных программ, которые
%% не используют режим ослабленных обращений.  

%% Среди слабых моделей памяти, сохраняющих семантические зависимости
%% и основанных на структурах событий, в контексте данной работы наибольший интерес
%% представляет модель \Wkm~\autocite{Chakraborty-Vafeiadis:POPL19},
%% поскольку для данной модели было формально доказано наличие ряда важных для практики свойств.
%% В частности, для этой модели была доказана корректность
%% локальных трансформаций программ и теорема о свободе от гонок.
%% Тем не менее отметим, что корректность оптимальной схемы
%% компиляции из модели \Wkm в модели современных мультипроцессоров
%% \emph{не была ранее доказана}, что является существенным недостатком,
%% так как наличие данного свойства является одним из базовых требований,
%% предъявляемых к классу моделей памяти, сохраняющих семантические зависимости.

{\aim} данной работы является адаптация классической теории структур событий
для описания слабых моделей памяти и разработка  
инструментов для автоматической и интерактивной верификации многопоточных программ. 

Для достижения данной цели были сформулированы следующие {\tasks}.
\begin{enumerate}[beginpenalty=10000] % https://tex.stackexchange.com/a/476052/104425
  \item
    Формализовать в системе для интерактивного доказательства теорем \coq
    классическую теорию структур событий. Показать, что
    в данную теорию укладывается класс моделей памяти,
    сохраняющих программный порядок.
  \item
    Формализовать в системе интерактивного доказательства теорем \coq
    теорию структур событий модели \Wkm.
    Доказать корректность оптимальной схемы компиляции
    из модели \Wkm в модели памяти современных мультипроцессоров.
  \item
    Разработать строгую версию модели \Wkm, 
    допускающую реализацию эффективных инструментов автоматической верификации
    и доказать, что для неё сохраняются основные свойства \Wkm  
    (в частности, корректность компиляции, корректность локальных трансформаций программ, 
     теорема о свободе от гонок).
  \item
    Разработать алгоритм проверки моделей (model~checking) для предложенной модели.
\end{enumerate}

%~\newline

{\methods} Диссертационное исследование базируется на теории формальных семантик. 
Используются классические и хорошо изученные формализмы, в частности, 
системы помеченных переходов, языки помеченных частично упорядоченных мультимножеств и структуры событий. 

Для формализации некоторых теорем и доказательств, представленных в данной работе, 
использовалась система интерактивного доказательства теорем \coq 
и библиотека формализованных математических теорий \mathcomp.

%% При разработке алгоритма проверки моделей использовались техника \emph{редукции частичных порядков}.
%% Предложенный алгоритм был внедрен в систему \genmc --- 
%% инструмент для автоматической верификации многопоточных программ написанных на языке \CLANG.

{\defpositions}
\begin{enumerate}[beginpenalty=10000] % https://tex.stackexchange.com/a/476052/104425
  \item Предложена формальная семантика на основе классической теории структур событий, 
    покрывающая класс слабых моделей памяти, сохраняющих программный порядок;
    данная семантика формализована в системе \coq.
  \item Доказана корректность оптимальной схемы компиляции из модели \Wkm
    в модели современных мультипроцессоров \TSO, \ARM и \POWER;
    сама модель \Wkm и доказательство корректности компиляции
    формализованы в системе \coq.
  \item Предложена модель \WkmS, расширяющая модель \Wkm 
  новыми свойствами \emph{свободы от буферизации
  операций чтения} и \emph{локальности сертификации}, 
  предназначенные для верификации;
  для \WkmS доказано сохранение основных свойств модели \Wkm: корректность компиляции,
  корректность локальных трансформаций программ,
  теорема о свободе от гонок.
  \item Для модели \WkmS разработан алгоритм автоматической 
    верификации программ методом проверки моделей; 
    экспериментально показана лучшая эффективность 
    данного алгоритма по сравнению с аналогами.
\end{enumerate}
% В папке Documents можно ознакомиться с решением совета из Томского~ГУ
% (в~файле \verb+Def_positions.pdf+), где обоснованно даются рекомендации
% по~формулировкам защищаемых положений.

{\novelty}
\begin{enumerate}[beginpenalty=10000] % https://tex.stackexchange.com/a/476052/104425

  \item Впервые предложена формальная семантика, основанная на классической теории структур событий,
    которая покрывает класс слабых моделей памяти, сохраняющих программный порядок.
    %% что позволяет применить известные теоретические результаты 
    %% о структурах событий к данному классу моделей.

  \item Впервые доказана корректность оптимальной схемы компиляции
    из модели памяти, основанной на структурах событий (\Wkm), 
    в модели памяти современных мультипроцессоров.

  \item Впервые предложена модель памяти (\WkmS),
    принадлежащая к классу моделей, сохраняющих семантические зависимости, 
    и при этом допускающая реализацию эффективных методов автоматической верификации программ. 

  \item Разработан новый алгоритм проверки моделей для \WkmS,
    который является существенно более эффективным по сравнению с аналогами 
    (алгоритмы \CDSChecker~\autocite{Norris-Demsky:OOPSLA2013} и \rmem~\autocite{Pulte-al:PLDI2019}),
    поддерживающими класс моделей памяти, сохраняющих семантические зависимости.

\end{enumerate}

{\influence} Предложенная новая семантика на основе теории структур событий 
для класса слабых моделей памяти, сохраняющих программный порядок,
соединяет классическую теорию структур событий.
%% с теорией слабых моделей памяти и позволяет применить известные результаты 
%% о структурах событий в новой предметной области.  
Формализация этой семантики в системе \coq открывает 
путь к дальнейшей разработке инструментов для  
интерактивной верификации многопоточных программ  
с учетом слабых сценариев исполнения. Предложенные в рамках модели  \WkmS новые свойства ---
свобода от буферизации операций чтения (load buffering race freedom)
и локальности сертификации (certification locality), --- 
также могут быть добавлены в другие модели памяти 
с целью разработки методов автоматической верификации программ в этих моделях. 
Наличие данных свойств позволяет оптимизировать алгоритм 
проверки моделей и таким образом существенно увеличить его эффективность.

Предложенный  алгоритм проверки моделей может быть использован на практике
для отладки и верификации многопоточных алгоритмов и структур данных 
с учетом слабых сценариев исполнения, допустимых стандартом языка \CLANG. 

{\reliability} полученных результатов обеспечивается 
формальными доказательствами, разработанными в том числе с использованием
систем интерактивного доказательства теорем, 
а также инженерными экспериментами. 
Результаты находятся в соответствии с результатами, полученными другими авторами.

{\probation} Основные результаты работы докладывались~на
следующих научных конференциях и семинарах:
Surrey Concurrency Workshop (23-24 июля 2019, Университет Суррея, Великобритания),
The European Conference on Object-Oriented Programming
(ECOOP, 15-17 ноября 2020, Берлин, Германия, конференция),
Spring/Summer Young Researchers' Colloquium on Software Engineering
(27-28 мая 2021, Москва, Россия),
внутренние семинары JetBrains Research
(18 ноября 2018, 13 апреля 2020, Санкт-Петербург, Россия). \\
\fixme{добавить будущие мероприятия по мере проведения}.

% {\contribution} Автор принимал активное участие \ldots

\ifnumequal{\value{bibliosel}}{0}
{%%% Встроенная реализация с загрузкой файла через движок bibtex8. (При желании, внутри можно использовать обычные ссылки, наподобие `\cite{vakbib1,vakbib2}`).
    {\publications} Основные результаты по теме диссертации изложены
    в~XX~печатных изданиях,
    X из которых изданы в журналах, рекомендованных ВАК,
    X "--- в тезисах докладов.
}%
{%%% Реализация пакетом biblatex через движок biber
    \begin{refsection}[bl-author, bl-registered]
        % Это refsection=1.
        % Процитированные здесь работы:
        %  * подсчитываются, для автоматического составления фразы "Основные результаты ..."
        %  * попадают в авторскую библиографию, при usefootcite==0 и стиле `\insertbiblioauthor` или `\insertbiblioauthorgrouped`
        %  * нумеруются там в зависимости от порядка команд `\printbibliography` в этом разделе.
        %  * при использовании `\insertbiblioauthorgrouped`, порядок команд `\printbibliography` в нём должен быть тем же (см. biblio/biblatex.tex)
        %
        % Невидимый библиографический список для подсчёта количества публикаций:
        \printbibliography[heading=nobibheading, section=1, env=countauthorvak,          keyword=biblioauthorvak]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorwos,          keyword=biblioauthorwos]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorscopus,       keyword=biblioauthorscopus]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorconf,         keyword=biblioauthorconf]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorother,        keyword=biblioauthorother]%
        \printbibliography[heading=nobibheading, section=1, env=countregistered,         keyword=biblioregistered]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorpatent,       keyword=biblioauthorpatent]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorprogram,      keyword=biblioauthorprogram]%
        \printbibliography[heading=nobibheading, section=1, env=countauthor,             keyword=biblioauthor]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorvakscopuswos, filter=vakscopuswos]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorscopuswos,    filter=scopuswos]%
        %
        \nocite{*}%
        %
        {\publications} Основные результаты по теме диссертации изложены в~\arabic{citeauthor}~печатных изданиях,
        \arabic{citeauthorvak} из которых изданы в журналах, рекомендованных ВАК\sloppy%
        \ifnum \value{citeauthorscopuswos}>0%
            , \arabic{citeauthorscopuswos} "--- в~периодических научных журналах, индексируемых Web of~Science и Scopus\sloppy%
        \fi%
        \ifnum \value{citeauthorconf}>0%
            , \arabic{citeauthorconf} "--- в~тезисах докладов.
        \else%
            .
        \fi%
        \ifnum \value{citeregistered}=1%
            \ifnum \value{citeauthorpatent}=1%
                Зарегистрирован \arabic{citeauthorpatent} патент.
            \fi%
            \ifnum \value{citeauthorprogram}=1%
                Зарегистрирована \arabic{citeauthorprogram} программа для ЭВМ.
            \fi%
        \fi%
        \ifnum \value{citeregistered}>1%
            Зарегистрированы\ %
            \ifnum \value{citeauthorpatent}>0%
            \formbytotal{citeauthorpatent}{патент}{}{а}{}\sloppy%
            \ifnum \value{citeauthorprogram}=0 . \else \ и~\fi%
            \fi%
            \ifnum \value{citeauthorprogram}>0%
            \formbytotal{citeauthorprogram}{программ}{а}{ы}{} для ЭВМ.
            \fi%
        \fi%
        % К публикациям, в которых излагаются основные научные результаты диссертации на соискание учёной
        % степени, в рецензируемых изданиях приравниваются патенты на изобретения, патенты (свидетельства) на
        % полезную модель, патенты на промышленный образец, патенты на селекционные достижения, свидетельства
        % на программу для электронных вычислительных машин, базу данных, топологию интегральных микросхем,
        % зарегистрированные в установленном порядке.(в ред. Постановления Правительства РФ от 21.04.2016 N 335)
    \end{refsection}%
    \begin{refsection}[bl-author, bl-registered]
        % Это refsection=2.
        % Процитированные здесь работы:
        %  * попадают в авторскую библиографию, при usefootcite==0 и стиле `\insertbiblioauthorimportant`.
        %  * ни на что не влияют в противном случае
        \nocite{Moiseenko-al:OOPSLA22}
        \nocite{Moiseenko-al:ECOOP20}
        \nocite{Moiseenko-al:STJITMO22}
        \nocite{Moiseenko-al:PCS21}
        \nocite{Gladstein-al:ISPRAS21}
        % \nocite{vakbib2}%vak
        % \nocite{patbib1}%patent
        % \nocite{progbib1}%program
        % \nocite{bib1}%other
        % \nocite{confbib1}%conf
    \end{refsection}%
        %
        % Всё, что вне этих двух refsection, это refsection=0,
        %  * для диссертации - это нормальные ссылки, попадающие в обычную библиографию
        %  * для автореферата:
        %     * при usefootcite==0, ссылка корректно сработает только для источника из `external.bib`. Для своих работ --- напечатает "[0]" (и даже Warning не вылезет).
        %     * при usefootcite==1, ссылка сработает нормально. В авторской библиографии будут только процитированные в refsection=0 работы.
}

% При использовании пакета \verb!biblatex! будут подсчитаны все работы, добавленные
% в файл \verb!biblio/author.bib!. Для правильного подсчёта работ в~различных
% системах цитирования требуется использовать поля:
% \begin{itemize}
%         \item \texttt{authorvak} если публикация индексирована ВАК,
%         \item \texttt{authorscopus} если публикация индексирована Scopus,
%         \item \texttt{authorwos} если публикация индексирована Web of Science,
%         \item \texttt{authorconf} для докладов конференций,
%         \item \texttt{authorpatent} для патентов,
%         \item \texttt{authorprogram} для зарегистрированных программ для ЭВМ,
%         \item \texttt{authorother} для других публикаций.
% \end{itemize}
% Для подсчёта используются счётчики:
% \begin{itemize}
%         \item \texttt{citeauthorvak} для работ, индексируемых ВАК,
%         \item \texttt{citeauthorscopus} для работ, индексируемых Scopus,
%         \item \texttt{citeauthorwos} для работ, индексируемых Web of Science,
%         \item \texttt{citeauthorvakscopuswos} для работ, индексируемых одной из трёх баз,
%         \item \texttt{citeauthorscopuswos} для работ, индексируемых Scopus или Web of~Science,
%         \item \texttt{citeauthorconf} для докладов на конференциях,
%         \item \texttt{citeauthorother} для остальных работ,
%         \item \texttt{citeauthorpatent} для патентов,
%         \item \texttt{citeauthorprogram} для зарегистрированных программ для ЭВМ,
%         \item \texttt{citeauthor} для суммарного количества работ.
% \end{itemize}

% Счётчик \texttt{citeexternal} используется для подсчёта процитированных публикаций;
% \texttt{citeregistered} "--- для подсчёта суммарного количества патентов и программ для ЭВМ.

% Для добавления в список публикаций автора работ, которые не были процитированы в
% автореферате, требуется их~перечислить с использованием команды \verb!\nocite! в
% \verb!Synopsis/content.tex!.

Личный вклад автора в публикациях, выполненных с соавторами, распределён следующим образом.
В работе \cite{Gladstein-al:ISPRAS21} автор предложил
метод кодирования семантики параллельной регистровой машины с
моделью памяти, сохраняющей программный порядок, в терминах простых структур событий;
соавторы участвовали в формализации данного метода в системе \coq.
В работе \cite{Moiseenko-al:STJITMO22} автор предложил
метод кодирования семантического домена языков частично упорядоченных мультимножеств
с использованием фактор-типов, 
соавторы участвовали в обсуждении данного метода и его формализации в системе \coq.
В работе \cite{Moiseenko-al:PCS21} автор выполнил сбор и анализ данных
о существующих моделях памяти языков программирования;
соавторы участвовали в формулировке выводов данного анализа.
В работе \cite{Moiseenko-al:ECOOP20} автор выполнил
формализацию доказательства корректности компиляции из
модели \Wkm в модели современных мультипроцессоров;
соавторы участвовали в обсуждении данного доказательства
и его формализации в системе \coq.
В работе \cite{Moiseenko-al:OOPSLA22} автор
формализовал новые свойства модели \WkmS,
а именно, свойства свободы от буферизации операций чтения и локальности сертификации,
доказал сохранение полезных свойств модели \Wkm в \WkmS,
а также разработал прототип алгоритма проверки моделей для \WkmS;
соавторы участвовали в обсуждении формализации модели \WkmS
и доказательстве ее свойств,
оказывали помощь при реализации нового алгоритма,
а также провели эксперименты по сравнению нового алгоритма с аналогами.
