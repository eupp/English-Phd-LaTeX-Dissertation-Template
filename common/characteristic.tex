
% {\actuality} Обзор, введение в тему, обозначение места данной работы в
% мировых исследованиях и~т.\:п., можно использовать ссылки на~другие
% работы~\autocite{Gosele1999161,Lermontov}
% (если их~нет, то~в~автореферате
% автоматически пропадёт раздел <<Список литературы>>). Внимание! Ссылки
% на~другие работы в~разделе общей характеристики работы можно
% использовать только при использовании \verb!biblatex! (из-за технических
% ограничений \verb!bibtex8!. Это связано с тем, что одна
% и~та~же~характеристика используются и~в~тексте диссертации, и в
% автореферате. В~последнем, согласно ГОСТ, должен присутствовать список
% работ автора по~теме диссертации, а~\verb!bibtex8! не~умеет выводить в~одном
% файле два списка литературы).
% При использовании \verb!biblatex! возможно использование исключительно
% в~автореферате подстрочных ссылок
% для других работ командой \verb!\autocite!, а~также цитирование
% собственных работ командой \verb!\cite!. Для этого в~файле
% \verb!common/setup.tex! необходимо присвоить положительное значение
% счётчику \verb!\setcounter{usefootcite}{1}!.

% Для генерации содержимого титульного листа автореферата, диссертации
% и~презентации используются данные из файла \verb!common/data.tex!. Если,
% например, вы меняете название диссертации, то оно автоматически
% появится в~итоговых файлах после очередного запуска \LaTeX. Согласно
% ГОСТ 7.0.11-2011 <<5.1.1 Титульный лист является первой страницей
% диссертации, служит источником информации, необходимой для обработки и
% поиска документа>>. Наличие логотипа организации на~титульном листе
% упрощает обработку и~поиск, для этого разметите логотип вашей
% организации в папке images в~формате PDF (лучше найти его в векторном
% варианте, чтобы он хорошо смотрелся при печати) под именем
% \verb!logo.pdf!. Настроить размер изображения с логотипом можно
% в~соответствующих местах файлов \verb!title.tex!  отдельно для
% диссертации и автореферата. Если вам логотип не~нужен, то просто
% удалите файл с~логотипом.

% \ifsynopsis
% Этот абзац появляется только в~автореферате.
% Для формирования блоков, которые будут обрабатываться только в~автореферате,
% заведена проверка условия \verb!\!\verb!ifsynopsis!.
% Значение условия задаётся в~основном файле документа (\verb!synopsis.tex! для
% автореферата).
% \else
% Этот абзац появляется только в~диссертации.
% Через проверку условия \verb!\!\verb!ifsynopsis!, задаваемого в~основном файле
% документа (\verb!dissertation.tex! для диссертации), можно сделать новую
% команду, обеспечивающую появление цитаты в~диссертации, но~не~в~автореферате.
% \fi

% {\progress}
% Этот раздел должен быть отдельным структурным элементом по
% ГОСТ, но он, как правило, включается в описание актуальности
% темы. Нужен он отдельным структурынм элемементом или нет ---
% смотрите другие диссертации вашего совета, скорее всего не нужен.

{\actuality} 
В современном мире многопоточные программные системы распространены повсеместно. 
Разработка и тестирование программного обеспечения для таких систем на порядок 
сложнее и трудозатратнее чем для последовательных систем. 
По этой причине крайне актуальной становится проблема 
формальной спецификации и верификации этого программного обеспечения. 

Одним из способов задания формальной семантики многопоточных систем 
является использование моделей \emph{истинной конкурентности}.
Этот класс моделей позволяет семантический выразить
понятие причинно-следственной связи между атомарными событиями системы
и понятие независимости (параллельности) атомарных событий,
что ведет к более компактному представлению пространства состояний программы.
Такое представление, в свою очередь, упрощает рассуждения 
о поведении многопоточных программ как для человека, 
так и для программных средств для автоматической и интерактивной верификации программ. 

\emph{Структуры событий} являются одним из семантических доменов 
относящихся к классу моделей истинной конкурентности.
Классическая теория структур событий была разработана G.Winskel для описания семантики 
исчисления взаимодействующих систем (Calculus of Communicating Systems, CCS).
Тем не менее, данное исчисление является достаточно простой моделью параллельных вычислений,
которое, в частности, не позволяет описывать 
\emph{слабые сценарии поведения} многопоточных программ.
Данные сценарии возникают на современных системах вследствии 
применения компиляторами и процессорами
различных оптимизаций при сборке и выполнении программ. 

Чтобы преодолеть этот недостаток S.Chakraborty и V.Vafeiadis 
предложили модель \Wkm, которая основана на теории 
структур событий и позволяет описывать слабые сценарии поведения.
Тем не менее, данная модель накладывает более слабые ограничения 
на вид структуры событий по сравнению с классическими определениями. 
С теоритической точки зрения, это не позволяет 
применять известные результаты о структурах событий к модели \Wkm. 
С практической точки зрения, это приводит к существенному увелечению 
пространства состояний программ, что препятствует разработке эффективных 
средств верификации многопоточных программ.

Таким образом, возникает потребность в создании формальной семантики 
многопоточных программ на основе структур событий, 
которая, с одной стороны, позволяет описывать слабые сценарии поведения, 
но с другой стороны допускает разработку на её основе 
инструментов для автоматической и интерактивной верификации программ. 

{\progress}

Теория структуры событий была разработана G.Winskel
в 1980-1990 годы для задания денотационной семантики 
исчисления взаимодействующих систем (Calculus of Communicating Systems, CCS)%
~\autocite{Winskel:ICALP1982}.
Относительно недавно эта теория также была использована 
для задания семантики пи-исчисления процессов ($\pi$-calculus)%
~\autocite{Varacca-Nobuko:TCS10,Crafa-al:FSCCS12,Hildebrandt-al:LATA2017}.

Модели многопоточных программ, которые оперируют с разделяемой памятью 
и допускают слабые сценарии поведения, называются \emph{слабыми моделями памяти}.
Теория слабых моделей памяти также активно развивалась начиная с 1990-ых годов. 
На сегодняшний день существует множество моделей памяти 
описывающих поведение мультипроцессоров, 
многопоточных языков программирования и распределенных систем. 
Эти модели, в свою очередь, можно разделить на несколько классов. 
Модели \emph{сохраняющие программный порядок} образуют широкий класс, 
включающий, в том числе, ограниченный фрагмент модели памяти языков \CPP~\autocite{Lahav-al:PLDI17},
модель \TSO процессоров семейства \Intel~\autocite{Sewell-al:CACM10},
а также модели распределенных систем, 
например, модель последовательной согласованности (causal consistency)~\autocite{Lahav-Boker:PLDI2020}
и модель согласованности в конечном счёте (eventual consistency)~\autocite{Jagadeesan-al:ESOP2018}.
Модели архитектур процессоров, например \ARMv{8}~\autocite{Pulte-al:POPL18} 
и \POWER~\autocite{Sarkar-al:PLDI11}, 
как правило принадлежат к классу моделей \emph{сохраняющих синтаксические зависимости}. 
Основное ограничение моделей принадлежащих к данным классам заключается в том, 
что они не поддерживают некоторые трансформации программ, 
применяемые оптимизирующими компиляторами. 
Поэтому эти модели не вполной мере отвечают требованиям, 
предъявляемым к моделям памяти для таких языков как \CPP и \Java. 
С целью преодоления этих ограничений исследователями 
были предложено несколько моделей, в том числе 
\Prm~\autocite{Kang-al:POPL17}, \Wkm~\autocite{Chakraborty-Vafeiadis:POPL19}, 
\MRD~\autocite{Paviotti-al:ESOP20}, \PwP~\autocite{Jagadeesan-al:OOPSLA2020},
которые обычно относят к классу моделей \emph{сохраняющих семантические зависимости}.

Классы моделей сохраняющих программный порядок и синтаксические зависимости 
относительно хорошо изучены, в то время как свойства класса моделей 
сохраняющих семантические зависимости по-прежнему активно исследуются.
В частности, для моделей данного класса практический не исследованы
вопросы построения эффективных инструментов автоматической и интерактивной верификации. 

Также существует несколько работ, делающих попытку адаптировать 
теорию структур событий для формализации слабых моделей памяти%
~\autocite{Jeffrey-Riely:LICS16,PichonPharabod-Sewell:POPL16,Chakraborty-Vafeiadis:POPL19,Paviotti-al:ESOP20}. 
Тем не менее, все эти работы вводят новые классы структур событий, 
несовместимые с классическими определениями, что 
затрудняет применение уже существующей теории структур событий. 

%     Program order preserving models enjoy 
%     a variety of useful properties and allow wide class 
%     of optimization to be applied to programs, 
%     with an important exception of load/store reordering.
%     The latter, in particular, imposes performance penalties
%     on implementation of these models on top of modern hardware, 
%     \eg \ARM and \POWER. 

%     Nevertheless, models of this class are widespread and commonly known.
%     Among them are memory model of a restricted fragment 
%     of the C language, known as \RCMM~\cite{Lahav-al:PLDI17}, 
%     and \TSO model of \Intel hardware~\cite{Sewell-al:CACM10}.    



% \begin{itemize}
  
%   \item In \emph{program order preserving models} 
%     instructions appear to take effect according 
%     to their \emph{program order}, which is 
%     guaranteed to be total within each thread. 
%     Models of this class forbid the outcome ${[r_1=1,r_2=1]}$
%     for program \ref{prog:lb} and its variations 
%     \ref{prog:lb-dep}, \ref{prog:lb-fakedep} shown below.  

%     \begin{minipage}{0.4\linewidth}
%       \begin{equation*}
%         \inarrII{
%           \readInst{}{r_1}{x}  \\
%           \writeInst{}{y}{r_1} \\
%         }{
%           \readInst{}{r_2}{y}  \\
%           \writeInst{}{x}{r_2} \\
%         }                      \\
%         \tag{LB-DEP}\label{prog:lb-dep}
%       \end{equation*}
%     \end{minipage}\hfill
%     % 
%     \begin{minipage}{0.5\linewidth}
%       \begin{equation*}
%         \inarrII{
%           \readInst{}{r_1}{x}          \\
%           \writeInst{}{y}{1 + r_1 * 0} \\
%         }{
%           \readInst{}{r_2}{y}     \\
%           \writeInst{}{x}{r_2}    \\
%         }                         \\
%         \tag{LB-FAKEDEP}\label{prog:lb-fakedep}
%       \end{equation*}
%     \end{minipage}

%     Note that reads are still allowed to read ``stale'' values
%     as opposed to sequentially consistent memory. 
%     For example, program order preservation does not 
%     forbid to assign outcome ${[r_1 = 1, r_2 = 0]}$ 
%     to the program \ref{prog:mp}, 
%     while sequential consistency forbids it.

%     \begin{equation*}
%       \inarrII{
%         \writeInst{}{x}{1}    \\
%         \writeInst{}{y}{1}    \\
%       }{
%         \readInst{}{r_1}{y}    \\
%         \readInst{}{r_2}{x}    \\
%       }                        \\
%       \tag{MP}\label{prog:mp}
%     \end{equation*}    

%     Program order preserving models enjoy 
%     a variety of useful properties and allow wide class 
%     of optimization to be applied to programs, 
%     with an important exception of load/store reordering.
%     The latter, in particular, imposes performance penalties
%     on implementation of these models on top of modern hardware, 
%     \eg \ARM and \POWER. 

%     Nevertheless, models of this class are widespread and commonly known.
%     Among them are memory model of a restricted fragment 
%     of the C language, known as \RCMM~\cite{Lahav-al:PLDI17}, 
%     and \TSO model of \Intel hardware~\cite{Sewell-al:CACM10}.    
    
%   \item \emph{Syntax dependency preserving models} 
%     relax total program order to partial 
%     \emph{preserved program order}, 
%     which relates instructions only if there 
%     exists \emph{syntactic dependency} between them. 
%     For example, in program \ref{prog:lb} there are
%     no syntactic dependencies between instructions, 
%     and thus the outcome ${[r_1=1,r_2=1]}$ is allowed. 
%     Contrary, in programs \ref{prog:lb-dep} and \ref{prog:lb-fakedep}
%     there exists syntactic dependencies, and thus 
%     outcome ${[r_1=1,r_2=1]}$ is forbidden. 
        
%     Although models of this class allow reordering 
%     of independent load/store pairs, they forbid 
%     another important optimization --- constant folding.
%     This can be evident by consulting \ref{prog:lb-fakedep} again: 
%     after an application of constant folding the instructions 
%     of the left thread become independent, thus 
%     jusifying outcome ${[r_1=1,r_2=1]}$.
    
%     Despite this fact syntax dependency preserving models
%     are widely used as models of hardware architectures, 
%     \eg \ARM~\cite{Pulte-al:POPL18}, \RISC~\cite{RISC}, 
%     \POWER~\cite{Sarkar-al:PLDI11}, 
%     because typical processors do not imploy such complex 
%     optimizations as constant folding.
    
%  \item Finally, \emph{semantic dependency preserving models}
%    relax syntactic dependencies tracking to 
%    \emph{semantic dependency} tracking. 
%    Giving program \ref{prog:lb-fakedep} these models would conclude 
%    that there is no semantic dependency between instructions 
%    of the left thread (indeed, the store to $y$ does not 
%    depend on the value read from $x$), and thus 
%    outcome ${[r_1=1,r_2=1]}$ should be allowed. 
%    In program \ref{prog:lb-dep}, on the other hand,
%    there exists a semantic dependency and thus 
%    the weak outcome remains forbidden.
   
%    The models of this class aim to support wide range 
%    of optimizations, including load/store reordering 
%    and constant folding. Several semantical dependency
%    tracking models, \eg \Promising~\cite{Kang-al:POPL17}, 
%    \Weakestmo~\cite{Chakraborty-Vafeiadis:POPL19}, 
%    \MRD~\cite{Paviotti-al:ESOP20}, 
%    \PwT~\cite{Jagadeesan-al:OOPSLA2020}, 
%    were developed independently and proposed 
%    as memory models for the \CPP and \Java languages.    

% \end{itemize}


% Модели, \emph{сохраняющие программный порядок}, включает 


% Эти модели, в свою очередь, можно разделить на несколько классов. 
% Модели, \emph{сохраняющие программный порядок}, включает 




% С 1990-х годов велась работа по
% разработке семантики многопоточности с учетом слабых сценариев поведения.
% Формальные модели для наиболее распространенных процессорных архитектур (x86, Power, ARM)
% были разработаны J. Alglave, S. Ishtiaq, L. Maranget, F. Zappa Nardelli, S. Sarkar, P. Sewell и др.
% исследователями\cscite{Alglave-al:TOPLAS14,Sewell-al:CACM10,Owens-al:TPHOL09}.
% Новые версии моделей продолжают появляться в связи с развитием процессорных архитектур.
% В частности, в 2016 и 2017 годах были представлены модели памяти для архитектур ARMv8.0 и
% ARMv8.3\cscite{Flur-al:POPL16,Pulte-al:POPL18}.
%% В настоящее время также ведутся работы по формализации моделей памяти графических процессоров.
% В 1995 году была стандартизована слабая модель памяти для языка Java\cscite{Manson-al:POPL05};
% в дальнейшем модель существенно менялась вплоть до 2005 года.
% В 2011 году появилась аксиоматическая модель памяти для языков C/C++\cscite{Batty-al:POPL11}.
%% Так модель памяти Java некорректна по отношению к базовым оптимизациям, а модель памяти C/С++ разрешает сценарии поведения
%% программ, в которых появляются т.н. \emph{значения из воздуха} (Out-Of-Thin-Air values),
%% что делает некорректными даже базовые рассуждения о программах.

% В 2017 году исследователи J. Kang, C.-K. Hur, O. Lahav, V. Vafeiadis и D. Dreyer
% представили обещающую модель памяти (promising memory model, $\Promise$)\cscite{Kang-al:POPL17}, которая является перспективным
% решением проблемы задания семантики для языка с многопоточностью. Авторы 
% доказали, что модель допускает большинство необходимых оптимизаций, а также показали корректность
% эффективных схем компиляции в архитектуры x86 и Power. Открытым остался вопрос о корректности компиляции
% в архитектуру ARM.

% Обзор, введение в тему, обозначение места данной работы в
% мировых исследованиях и~т.\:п., можно использовать ссылки на~другие
% работы~\autocite{Gosele1999161,Lermontov}

{\aim} данной работы является исследование 
теории структур событий в контексте слабых моделей памяти
и разработка на основе этих исследований 
инструментов для автоматической и интерактивной верификации программ. 

Для достижения данной цели были сформулированы следующие {\tasks}:
\begin{enumerate}[beginpenalty=10000] % https://tex.stackexchange.com/a/476052/104425
  \item разработать семантику на основе классической теории структур событий, 
    покрывающую класс слабых моделей памяти \emph{сохраняющих программный порядок},
    и формализовать данную семантику в системе для интерактивного доказательства теорем \coq;
  \item разработать более строгую версию модели \WkmS, допускающую реализацию 
    эффективных инструментов автоматической верификации
    и доказать сохранение всех полезных свойств \Wkm для более строгой версии модели 
    (в частности, корректность компиляции, корректность локальных трансформаций программ, 
     теоремы о свободе от гонок);
  \item разработать и апробировать алгоритм проверки моделей (model~checking) для 
    более строгой версии модели \WkmS.
\end{enumerate}

{\methods}

Исследование базируется на теории формальных семантик для 
задания математический строгого определения сценариев поведения многопоточных программ. 
Используются классические и хорошо изученные формализмы, в частности 
системы помеченных переходов, языки помеченных частично упорядоченных мультимножеств и структуры событий. 

Для формализации некоторых теорем и доказательств, представленных в данной работе, 
использовалась система интерактивного доказательства теорем \coq 
и библиотека формализованных математических теорий \mathcomp.

При разработке алгоритма проверки моделей использовались техника \emph{редукции частичных порядков}.
Предложенный алгоритм был внедрен в систему \genmc --- 
инструмент для автоматической верификации многопоточных программ написанных на языке \CLANG.

{\defpositions}
\begin{enumerate}[beginpenalty=10000] % https://tex.stackexchange.com/a/476052/104425
  \item Предложена семантика на основе классической теории структур событий, 
    покрывающая класс слабых моделей памяти сохраняющих программный порядок;
    данная семантика формализована в системе \coq.
  \item Предложена новая версия модели \WkmS, 
    доказано сохранение основных полезных свойств модели \Wkm.
  \item Для модели \WkmS разработан алгоритм автоматической 
    верификации программ методом проверки моделей.
\end{enumerate}
% В папке Documents можно ознакомиться с решением совета из Томского~ГУ
% (в~файле \verb+Def_positions.pdf+), где обоснованно даются рекомендации
% по~формулировкам защищаемых положений.

{\novelty}
\begin{enumerate}[beginpenalty=10000] % https://tex.stackexchange.com/a/476052/104425

  \item Новая предложеная семантика отличается от аналогов тем, 
    что основана на классической теории структур событий, 
    что позволяет применить известные теоретические результаты 
    о структурах событий к классу слабых моделей памяти сохраняющих программный порядок.

  \item Новая версия модели \WkmS является первой моделью в классе 
    моделей памяти \emph{сохраняющих семантические зависимости}, 
    которая удовлетворяет всем типичным требованиям к моделям этого класса, 
    % то есть, допускает эффективную компиляцию, применение локальных трансформаций к программам, 
    % предоставляет гарантии свободы от гонок, 
    и при этом также допускает реализацию эффективных методов автоматической верификации программ. 

  \item Новый алгоритм проверки моделей является существенно более эффективным 
    по сравнению с другими алгоритмами, поддерживающими 
    класс моделей памяти сохраняющих семантические зависимости.

\end{enumerate}

{\influence} 

Новая семантика на основе теории структур событий 
для класса слабых моделей памяти сохраняющих программный порядок
соединяет классическую теорию структур событий 
с теорией слабых моделей памяти и позволяет применить известные результаты 
о структурах событий в новой предметной области.  
Формализация этой семантики в системе \coq открывает 
путь к дальнейшей разработке средств 
интерактивной верификации многоточных программ  
с учетом слабых сценариев исполнения. 
 
Новые свойства свободы от буфферезации записей (load buffering freedom)
и локальности сертификации (certification locality), 
которые были добавлены в новую версию модели \WkmS, 
также могут быть добавлены и в другие модели памяти 
с целью разработки методов автоматической верификации программ в этих моделях. 

Новый алгоритм проверки моделей может быть использован на практике
для отладки и верификации многопоточных алгоритмов и структур данных 
с учетом слабых сценариев исполнения, допустимых стандартом языка \CLANG. 

{\reliability} полученных результатов обеспечивается 
формальными доказательствами, разработанными в том числе с использованием
систем интерактивного доказательства теорем, 
а также инженерными экспериментами. 
Результаты находятся в соответствии с результатами, полученными другими авторами.

{\probation}
Основные результаты работы докладывались~на
следующих научных конференциях и семинарах:
\fixme{todo}

% {\contribution} Автор принимал активное участие \ldots

\ifnumequal{\value{bibliosel}}{0}
{%%% Встроенная реализация с загрузкой файла через движок bibtex8. (При желании, внутри можно использовать обычные ссылки, наподобие `\cite{vakbib1,vakbib2}`).
    {\publications} Основные результаты по теме диссертации изложены
    в~XX~печатных изданиях,
    X из которых изданы в журналах, рекомендованных ВАК,
    X "--- в тезисах докладов.
}%
{%%% Реализация пакетом biblatex через движок biber
    \begin{refsection}[bl-author, bl-registered]
        % Это refsection=1.
        % Процитированные здесь работы:
        %  * подсчитываются, для автоматического составления фразы "Основные результаты ..."
        %  * попадают в авторскую библиографию, при usefootcite==0 и стиле `\insertbiblioauthor` или `\insertbiblioauthorgrouped`
        %  * нумеруются там в зависимости от порядка команд `\printbibliography` в этом разделе.
        %  * при использовании `\insertbiblioauthorgrouped`, порядок команд `\printbibliography` в нём должен быть тем же (см. biblio/biblatex.tex)
        %
        % Невидимый библиографический список для подсчёта количества публикаций:
        \printbibliography[heading=nobibheading, section=1, env=countauthorvak,          keyword=biblioauthorvak]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorwos,          keyword=biblioauthorwos]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorscopus,       keyword=biblioauthorscopus]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorconf,         keyword=biblioauthorconf]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorother,        keyword=biblioauthorother]%
        \printbibliography[heading=nobibheading, section=1, env=countregistered,         keyword=biblioregistered]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorpatent,       keyword=biblioauthorpatent]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorprogram,      keyword=biblioauthorprogram]%
        \printbibliography[heading=nobibheading, section=1, env=countauthor,             keyword=biblioauthor]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorvakscopuswos, filter=vakscopuswos]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorscopuswos,    filter=scopuswos]%
        %
        \nocite{*}%
        %
        {\publications} Основные результаты по теме диссертации изложены в~\arabic{citeauthor}~печатных изданиях,
        \arabic{citeauthorvak} из которых изданы в журналах, рекомендованных ВАК\sloppy%
        \ifnum \value{citeauthorscopuswos}>0%
            , \arabic{citeauthorscopuswos} "--- в~периодических научных журналах, индексируемых Web of~Science и Scopus\sloppy%
        \fi%
        \ifnum \value{citeauthorconf}>0%
            , \arabic{citeauthorconf} "--- в~тезисах докладов.
        \else%
            .
        \fi%
        \ifnum \value{citeregistered}=1%
            \ifnum \value{citeauthorpatent}=1%
                Зарегистрирован \arabic{citeauthorpatent} патент.
            \fi%
            \ifnum \value{citeauthorprogram}=1%
                Зарегистрирована \arabic{citeauthorprogram} программа для ЭВМ.
            \fi%
        \fi%
        \ifnum \value{citeregistered}>1%
            Зарегистрированы\ %
            \ifnum \value{citeauthorpatent}>0%
            \formbytotal{citeauthorpatent}{патент}{}{а}{}\sloppy%
            \ifnum \value{citeauthorprogram}=0 . \else \ и~\fi%
            \fi%
            \ifnum \value{citeauthorprogram}>0%
            \formbytotal{citeauthorprogram}{программ}{а}{ы}{} для ЭВМ.
            \fi%
        \fi%
        % К публикациям, в которых излагаются основные научные результаты диссертации на соискание учёной
        % степени, в рецензируемых изданиях приравниваются патенты на изобретения, патенты (свидетельства) на
        % полезную модель, патенты на промышленный образец, патенты на селекционные достижения, свидетельства
        % на программу для электронных вычислительных машин, базу данных, топологию интегральных микросхем,
        % зарегистрированные в установленном порядке.(в ред. Постановления Правительства РФ от 21.04.2016 N 335)
    \end{refsection}%
    \begin{refsection}[bl-author, bl-registered]
        % Это refsection=2.
        % Процитированные здесь работы:
        %  * попадают в авторскую библиографию, при usefootcite==0 и стиле `\insertbiblioauthorimportant`.
        %  * ни на что не влияют в противном случае
        \nocite{Gladstein-al:ISPRAS21}
        \nocite{Moiseenko2020-al:ECOOP20}
        \nocite{Moiseenko-al:PCS21}
        % \nocite{vakbib2}%vak
        % \nocite{patbib1}%patent
        % \nocite{progbib1}%program
        % \nocite{bib1}%other
        % \nocite{confbib1}%conf
    \end{refsection}%
        %
        % Всё, что вне этих двух refsection, это refsection=0,
        %  * для диссертации - это нормальные ссылки, попадающие в обычную библиографию
        %  * для автореферата:
        %     * при usefootcite==0, ссылка корректно сработает только для источника из `external.bib`. Для своих работ --- напечатает "[0]" (и даже Warning не вылезет).
        %     * при usefootcite==1, ссылка сработает нормально. В авторской библиографии будут только процитированные в refsection=0 работы.
}

% При использовании пакета \verb!biblatex! будут подсчитаны все работы, добавленные
% в файл \verb!biblio/author.bib!. Для правильного подсчёта работ в~различных
% системах цитирования требуется использовать поля:
% \begin{itemize}
%         \item \texttt{authorvak} если публикация индексирована ВАК,
%         \item \texttt{authorscopus} если публикация индексирована Scopus,
%         \item \texttt{authorwos} если публикация индексирована Web of Science,
%         \item \texttt{authorconf} для докладов конференций,
%         \item \texttt{authorpatent} для патентов,
%         \item \texttt{authorprogram} для зарегистрированных программ для ЭВМ,
%         \item \texttt{authorother} для других публикаций.
% \end{itemize}
% Для подсчёта используются счётчики:
% \begin{itemize}
%         \item \texttt{citeauthorvak} для работ, индексируемых ВАК,
%         \item \texttt{citeauthorscopus} для работ, индексируемых Scopus,
%         \item \texttt{citeauthorwos} для работ, индексируемых Web of Science,
%         \item \texttt{citeauthorvakscopuswos} для работ, индексируемых одной из трёх баз,
%         \item \texttt{citeauthorscopuswos} для работ, индексируемых Scopus или Web of~Science,
%         \item \texttt{citeauthorconf} для докладов на конференциях,
%         \item \texttt{citeauthorother} для остальных работ,
%         \item \texttt{citeauthorpatent} для патентов,
%         \item \texttt{citeauthorprogram} для зарегистрированных программ для ЭВМ,
%         \item \texttt{citeauthor} для суммарного количества работ.
% \end{itemize}

% Счётчик \texttt{citeexternal} используется для подсчёта процитированных публикаций;
% \texttt{citeregistered} "--- для подсчёта суммарного количества патентов и программ для ЭВМ.

% Для добавления в список публикаций автора работ, которые не были процитированы в
% автореферате, требуется их~перечислить с использованием команды \verb!\nocite! в
% \verb!Synopsis/content.tex!.
