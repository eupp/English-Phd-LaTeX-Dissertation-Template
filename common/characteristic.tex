
% {\actuality} Обзор, введение в тему, обозначение места данной работы в
% мировых исследованиях и~т.\:п., можно использовать ссылки на~другие
% работы~\autocite{Gosele1999161,Lermontov}
% (если их~нет, то~в~автореферате
% автоматически пропадёт раздел <<Список литературы>>). Внимание! Ссылки
% на~другие работы в~разделе общей характеристики работы можно
% использовать только при использовании \verb!biblatex! (из-за технических
% ограничений \verb!bibtex8!. Это связано с тем, что одна
% и~та~же~характеристика используются и~в~тексте диссертации, и в
% автореферате. В~последнем, согласно ГОСТ, должен присутствовать список
% работ автора по~теме диссертации, а~\verb!bibtex8! не~умеет выводить в~одном
% файле два списка литературы).
% При использовании \verb!biblatex! возможно использование исключительно
% в~автореферате подстрочных ссылок
% для других работ командой \verb!\autocite!, а~также цитирование
% собственных работ командой \verb!\cite!. Для этого в~файле
% \verb!common/setup.tex! необходимо присвоить положительное значение
% счётчику \verb!\setcounter{usefootcite}{1}!.

% Для генерации содержимого титульного листа автореферата, диссертации
% и~презентации используются данные из файла \verb!common/data.tex!. Если,
% например, вы меняете название диссертации, то оно автоматически
% появится в~итоговых файлах после очередного запуска \LaTeX. Согласно
% ГОСТ 7.0.11-2011 <<5.1.1 Титульный лист является первой страницей
% диссертации, служит источником информации, необходимой для обработки и
% поиска документа>>. Наличие логотипа организации на~титульном листе
% упрощает обработку и~поиск, для этого разметите логотип вашей
% организации в папке images в~формате PDF (лучше найти его в векторном
% варианте, чтобы он хорошо смотрелся при печати) под именем
% \verb!logo.pdf!. Настроить размер изображения с логотипом можно
% в~соответствующих местах файлов \verb!title.tex!  отдельно для
% диссертации и автореферата. Если вам логотип не~нужен, то просто
% удалите файл с~логотипом.

% \ifsynopsis
% Этот абзац появляется только в~автореферате.
% Для формирования блоков, которые будут обрабатываться только в~автореферате,
% заведена проверка условия \verb!\!\verb!ifsynopsis!.
% Значение условия задаётся в~основном файле документа (\verb!synopsis.tex! для
% автореферата).
% \else
% Этот абзац появляется только в~диссертации.
% Через проверку условия \verb!\!\verb!ifsynopsis!, задаваемого в~основном файле
% документа (\verb!dissertation.tex! для диссертации), можно сделать новую
% команду, обеспечивающую появление цитаты в~диссертации, но~не~в~автореферате.
% \fi

% {\progress}
% Этот раздел должен быть отдельным структурным элементом по
% ГОСТ, но он, как правило, включается в описание актуальности
% темы. Нужен он отдельным структурынм элемементом или нет ---
% смотрите другие диссертации вашего совета, скорее всего не нужен.

{\actuality} 
На сегодняшний день  многопоточность широко применяется в самом разнообразном программном обеспечении ---
банковских системах, системах реального времени, ядрах операционных систем,
системах управления базами данных и пр.
Многопоточность позволяет эффективно задействовать современные многоядерные процессоры и
значительно повысить скорость выполнения и отзывчивость программ.
При этом \emph{семантика} многопоточных программ принципиально сложнее,
чем семантика последовательных программ.
Данное обстоятельство является следствием недетерминированности переключения потоков при исполнении
программы и отсутствием единой линейной последовательности выполнения ее инструкций.
В итоге затруднена  не только разработка, но и тестирование многопоточных программ \todo{ссылка нужна} --- 
многие ошибки многопоточного программирования проявляются только в малом проценте сценариев  и 
не воспроизводятся  при повторных запусках программы.
По этой причине актуальна  верификация многопоточных программ, а
решение этой задачи, в свою очередь, требует построения  для них 
строгой математической  семантики.

Формальная семантика многопоточной системы, оперирующей с общей разделяемой памятью,
называется \emph{моделью памяти (memory model)}. 
Основной задачей модели памяти является определение множества 
допустимых \emph{сценариев исполнения} программы.

Наиболее известной и интуитивно понятной моделью памяти является 
\emph{модель последовательной согласованности} (sequential consistency),
предложенная Лесли Лампортом в 1979 году \cite{Lamport:TC79}.
Эта модель предполагает, что любой результат исполнения многопоточной программы может быть
получен с помощью последовательного исполнения некоторого чередования инструкций потоков программы
единственным вычислителем (например, ядром процессора): вычислитель делает один или несколько шагов вычисления в одном потоке, потом переключается на другой поток,
выполняет несколько инструкций там, затем переключается на следующий поток, и так далее, пока
все потоки не будут полностью исполнены. 
Во время исполнения каждый поток может иметь свой собственный  локальный контекст
(счетчик команд и состояние регистров),
который переключается в вычислителе при смене текущего потока, 
но глобальное состояние разделяемой памяти является общим для всех потоков.

К сожалению, простая и интуитивная модель последовательной согласованности 
не может описать все возможные сценарии исполнения многопоточных программ, 
которые наблюдаются на современных системах.
Это является следствием того, что компиляторы и процессоры применяют 
различные оптимизации при трансляции и выполнении программ.
Данные оптимизации не меняют семантику однопоточной, последовательной, программы, 
однако эффекты от их применения могут наблюдаться при исполнении потоков на многопоточной системе.
Например, компилятор может переставлять инструкции программы, 
а процессор --- исполнять инструкции не по порядку (\emph{out of order}).

Сценарии исполнения многопоточных программ, 
которые выходят за пределы модели последовательной согласованности,
называются \emph{слабыми (weak behaviours)}, а допускающие их модели памяти ---
\emph{слабыми моделями памяти (weak memory models)}.

Вопрос о том, какие именно слабые сценарии поведения 
следует допускать, а какие нет, не является однозначным --- ответ  
зависит от языка программирования и целевой процессорной архитектуры.
По этой причине в последние годы появилось множество
различных моделей памяти как для мультипроцессоров, \Intel~\autocite{Sewell-al:CACM10}, 
\ARM~\autocite{Pulte-al:POPL18}, 
\POWER~\autocite{Sarkar-al:PLDI11}, так и для языков программирования,
\CPP~\autocite{Batty-al:POPL11},
\Java~\autocite{Manson-al:POPL05}, 
\JS~\autocite{Watt-al:PLDI2020}, 
\OCaml~\autocite{Dolan-al:PLDI18},
а также для распределенных систем%
~\autocite{Jagadeesan-al:ESOP2018,Lahav-Boker:PLDI2020}.

В связи с этим актуальна задача по формализации 
существующих моделей памяти и созданию теоретического инструментария
для разработки будущих моделей памяти. В частности,  открытой остается проблема разработки моделей памяти
для высокопроизводительных языков программирования, таких как \CPP и \Java.
К этим моделям предъявляется набор противоречивых требований.
C одной стороны, они должны поддерживать оптимальные схемы компиляции в
целевой код современных мультипроцессоров и допускать применение
широкого спектра оптимизаций исходного кода --- эти требования
влекут к необходимости ослабления модели памяти.
С другой стороны, данные модели должны предоставлять набор
гарантий о поведении программ, что необходимо, в частности, для разработки инструментов
формальной верификации.

Первоначальные версии моделей памяти языков
\CPP~\autocite{Batty-al:POPL11} и \Java~\autocite{Manson-al:POPL05}
не удовлетворяли приведенным выше требованиям%
~\autocite{Sevcik-Aspinall:ECOOP08,Vafeiadis-al:POPL15,Batty-al:ESOP15}. 
В качестве возможных кандидатов им на замену были предложено множество различных моделей,
в частности модели \Wkm~\autocite{Chakraborty-Vafeiadis:POPL19}, \Prm~\autocite{Kang-al:POPL17}, 
\MRD~\autocite{Paviotti-al:ESOP20}, \PwT~\autocite{Jagadeesan-al:OOPSLA2020,Jeffrey-al:POPL2022}
и другие~\autocite{Jeffrey-Riely:LICS16, PichonPharabod-Sewell:POPL16, Paviotti-al:ESOP20}.
Тем не менее, данные модели тоже подвергаются критике.
Во-первых, в доказательствах ключевых свойств некоторых из этих моделей 
были выявлены ошибки~\autocite{Jeffrey-Riely:LICS16,PichonPharabod-PhD18,Lahav-al:PLDI17}.
Во-вторых, в рамках вышеупомянутых моделей даже для небольших программ
вычислительно затратно перечисление возможных слабых сценариев поведения,
что препятствует разработке эффективных средств верификации многопоточных программ.
Наконец, еще одним пунктом критики является 
чрезмерная концептуальная сложность данных моделей, 
а также обнаружение новых контруинтуитивных слабых сценариев поведения, 
допустимых этими моделями%
~\autocite{Paviotti-al:ESOP20,Jagadeesan-al:OOPSLA2020,Lee-al:PLDI20,Cho-al:PLDI21}.

Для того, чтобы исключить  ошибки
в доказательстве свойств моделей можно использовать автоматические системы доказательств~--- 
\coq~\autocite{Coq}, \agda~\autocite{Agda}, \lean~\autocite{Lean}, \arend~\autocite{Arend}.
Фактический, формализация математических выкладок
в системах доказательства теорем уже стала стандартом
не только в области слабых моделей памяти,
но и в целом в области теории языков программирования, а также в ряде других областей.
Практика использования таких систем  получила название \emph{инженерии доказательств}
(\emph{proof engineering}) и  является отдельной
активно развивающейся областью исследований~\autocite{Ringer-al:FTPL19}.

Наличие строго определенной формальной семантики является необходимым
предусловием для разработки инструментов верификации программ,
в частности, инструментов \emph{проверки моделей}%
~\autocite{Baier:2008} (\emph{model checking}).
Такие инструменты выполняют систематическое исследование различных 
трасс программы, выполняя поиск различных ошибок:
\emph{состояний гонок} (\emph{data races}), 
\emph{взаимных блокировок} (\emph{deadlocks}),
\emph{выхода за пределы массива} (\emph{out-of-bounds accesses}), и других. 
Например, инструменты вроде \genmc~\autocite{Kokologiannakis:CAD2021} 
или \CDSChecker~\autocite{Norris-Demsky:OOPSLA2013} способны выполнять верификацию 
многопоточных программ, написанных на языках \CPP. 
Однако, подобные инструменты поддерживают либо только фрагмент 
модели памяти языков \CPP~\autocite{Lahav-al:PLDI17}, 
не учитывающий все возможные слабые сценарии поведения, 
либо демонстрируют низкую эффективность даже для небольших программ. 
Дело в том что, как уже было упомянуто, предложенные на сегодняшний день модели памяти для языков
программирования \CPP и \Java допускают слишком большое количество
слабых сценариев исполнения, что затрудняет процесс построения эффективных инструментов верификации.
Это, в свою очередь, ставит вопрос о необходимости уточнения данных моделей
с целью упрощения процесса верификации программ в этих моделях.

Перспективным способом решения  проблемы концептуальной сложности слабых моделей памяти является 
теория \emph{структур событий}~\autocite{Winskel:86}.
Эта теория позволяет декларативно описать семантику многопоточной системы.
В наиболее простом варианте  структура событий состоит из следующий элементов: 
множества атомарных событий;
функции, присваивающей каждому событию семантическую метку; 
отношения причинно-следственной связи;  отношения конфликта между событиями.
Заметим, однако, что  слабые модели памяти, использующие структуры событий, 
вводят новые виды таких структур, которые оказываются 
несовместимыми с классической теорией%
~\cite{Winskel:86,Nielsen-al:1981,Boudol-Castellani:1991,Langerak:91,Baldan-al:IC01}. 
А это, в свою очередь, делает невозможным использование известных теоретических результатов
о структурах событий~\autocite{Vaandrager:TCS1991,Sassone:MFCS1993,Nielsen:REX93,Winskel-TCS:09}.
В связи с этим возникает вопрос о том, могут ли данные модели
или какие-то их содержательные подмножества быть выражены
в рамках классической теории структур событий?

Таким образом, актуальной является задача построения и уточнения 
моделей памяти для языков программирования \CPP и \Java,
формализации этих моделей в системах доказательства теорем
и разработки на основе этих исследований инструментов верификации многопоточных программ.

{\progress}

На сегодняшний день в мире существует несколько активных исследовательских групп, 
занимающихся исследованием слабых моделей памяти языков программирования.
Можно отметить
группу под руководством C.-K. Hur в Сеульском Национальном Унивирситете,
группу M. Batty в Университете города Кент,
группу O. Lahav в Университете Тель-Авива,
группу V. Vafeiadis в Институте Макса Планка,
а также группу в лаборатории языков программирования JetBrains Research
под руководством А.~Подкопаева. 
Публикации по этой теме регулярно публикуются на ведущих
международных конференциях в области теории языков программирования 
(POPL, PLDI, OOPSLA и др.)

Теория слабых моделей памяти активно развивается, 
начиная с 1990-х годов~--- создано множество моделей памяти, 
описывающих поведение мультипроцессоров, 
многопоточных языков программирования и распределенных систем 
(см. обзор~\cite{Moiseenko-al:PCS21}). 
Эти модели, в свою очередь, можно разделить на несколько классов.

Модели, \emph{сохраняющие программный порядок}, образуют широкий класс,
включая модель \TSO процессоров семейства \Intel~\autocite{Sewell-al:CACM10},
модели последовательной согласованности (sequential consistency)~\autocite{Lamport:TC79},
причинной согласованности (causal consistency)~\autocite{Lahav-Boker:PLDI2020}
и согласованности в конечном счёте (eventual consistency)~\autocite{Jagadeesan-al:ESOP2018}. 
В этот же класс входят  модели памяти некоторых языков программирования, например,
языка \OCaml~\autocite{Dolan-al:PLDI18}.
Общим недостатком всех этих моделей является то,
что они не поддерживают \emph{оптимальные схемы компиляции} 
в целевой код для широко распространённых мультипроцессоров \ARM и \POWER.
Это означает, что реализация данных моделей на этих мультипроцессорах
влечет дополнительные накладные расходы и может приводить
к увеличению времени исполнения программ~\autocite{Ou-Demsky:OOPSLA18}. 

Модели памяти мультипроцессоров,
в частности, \ARM~\autocite{Pulte-al:POPL18} и \POWER~\autocite{Sarkar-al:PLDI11}, 
как правило, принадлежат к классу моделей, \emph{сохраняющих синтаксические зависимости}. 
Основное ограничение этих моделей заключается в том, 
что они не поддерживают некоторые значимые трансформации программ, 
применяемые оптимизирующими компиляторами, например, свертку констант.
По этой причине модели данного класса, как правило,
не применяются для языков программирования.  

Таким образом, модели памяти двух вышеупомянутых классов 
не отвечают требованиям, предъявляемым к моделям памяти для таких языков как \CPP и \Java. 
С целью преодоления этих ограничений исследователями были предложены модели  
\Prm~\autocite{Kang-al:POPL17}, \Wkm~\autocite{Chakraborty-Vafeiadis:POPL19}, 
\MRD~\autocite{Paviotti-al:ESOP20}, \PwP~\autocite{Jagadeesan-al:OOPSLA2020},
модель A.Jeffrey и J.Riely ~\autocite{Jeffrey-Riely:LICS16} и
модель J.Pichon-Pharabod и P. Sewell~\autocite{PichonPharabod-Sewell:POPL16}.
Все эти модели обычно относят к классу моделей, \emph{сохраняющих семантические зависимости}.
Они, как правило, поддерживают оптимальные схемы компиляции
для современных мультипроцессоров и широкий спектр оптимизаций программ.

Модели, сохраняющие программный порядок и синтаксические зависимости, 
в настоящее время хорошо изучены. Напротив, модели, 
сохраняющие семантические зависимости, по-прежнему активно исследуются.
В частности, для них, фактически, не изучены
вопросы построения эффективных инструментов автоматической и интерактивной верификации. 

Рассмотрим в качестве примера язык \CPP.
Для описания модели памяти данного языка исследовательским
 было предложено несколько подходов.
Модель \RCMM~\autocite{Lahav-al:PLDI17}
относится к классу моделей, сохраняющих программный порядок.
Данная модель является относительно простой и
предоставляет ряд  полезных на практике свойств.
Для неё также были разработаны эффективные
средства верификации, например, инструмент проверки моделей \genmc~\autocite{Kokologiannakis:PLDI2019}.
Однако эта модель не поддерживает оптимальную схему компиляции в мультипроцессоры \ARM и \POWER.
С другой стороны, модели \Prm и \Wkm, относящиеся к классу моделей,
сохраняющих семантические зависимости,
хоть и поддерживают оптимальную схему компиляции и широкий набор оптимизаций программ, но оказываются существенно более сложными, а их свойства слабо изучены.
Наконец, для этих моделей отсутствуют эффективные методы верификации программ. 

В контексте данной работы была выбрана модель \Wkm~\autocite{Chakraborty-Vafeiadis:POPL19},
которую её авторы  предложили в качестве модели памяти
для языков \CPP и \LLVM%
~\autocite{Chakraborty-Vafeiadis:CGO17}.
Модель \Wkm основана на теории структур событий~\autocite{Winskel:86,Winskel:ICALP1982}.
Преимуществом использования данного формализма является декларативность, что позволяет упростить  модификацию этой модели
с целью добавления в нее новых свойств.

Ранее было доказано, что модель \Wkm обладает рядом важных для практики свойств%
~\autocite{Chakraborty-Vafeiadis:POPL19}.
Однако у данной модели имеется ряд недостатков:
для нее ранее не была доказана корректность оптимальной схемы
компиляции в модели современных мультипроцессоров,
для данной модели отсутствуют средства верификации программ,
а также эта модель не укладывается в классическую теорию структур событий~\cite{Winskel:86}.

{\aim} данной работы является  исследование и
модификация известной модели \Wkm для разработки
на ее основе инструментов верификации многопоточных программ. 

Для достижения данной цели были сформулированы следующие {\tasks}.
\begin{enumerate}[beginpenalty=10000] % https://tex.stackexchange.com/a/476052/104425
  \item
    Формализовать в системе интерактивного доказательства теорем \coq модель памяти \Wkm и
    доказательство корректности оптимальной схемы компиляции
    из модели \Wkm в модели памяти современных мультипроцессоров.
  \item
    Разработать строгую версию модели \Wkm, 
    допускающую реализацию эффективных инструментов автоматической верификации
    и доказать, что для неё сохраняются основные свойства \Wkm  
    (в частности, корректность компиляции, корректность локальных трансформаций программ, 
     теорема о свободе от гонок).
  \item
    Разработать инструмент проверки моделей (model~checking) для предложенной модели.
  \item
    Исследовать применимость классической теории структур в контексте слабых моделей памяти.
\end{enumerate}

{\methods} Диссертационное исследование базируется на теории формальных семантик
для математически строгого описания сценариев поведения  программ. 

В работе используются классические формализмы, в частности, 
системы помеченных переходов, языки помеченных частично 
упорядоченных мультимножеств и структуры событий. Для формализации некоторых теорем и доказательств, представленных в данной работе, 
использовалась система интерактивного доказательства теорем \coq 
и библиотека формализованных математических теорий \mathcomp. Представленные в работе  программные средства верификации  реализованы на языке \CLANG и используют инструмент \genmc.  

{\defpositions}
\begin{enumerate}[beginpenalty=10000] % https://tex.stackexchange.com/a/476052/104425

  \item Доказана корректность оптимальной схемы компиляции из модели \Wkm
    в модели современных мультипроцессоров \TSO, \ARM и \POWER;
    выполнена формализация модели \Wkm, а также  предложенного доказательства  в системе \coq.

  \item Предложена модель \WkmS, расширяющая модель \Wkm 
    новыми свойствами \emph{свободы от буферизации операций чтения}
    и \emph{локальности сертификации}, предназначенными для верификации;
    для \WkmS доказано сохранение основных свойств модели \Wkm: корректность компиляции,
    корректность локальных трансформаций программ,
    теорема о свободе от гонок.

  \item Разработан инструмент \wmc, выполняющий верификацию многопоточных программ, 
    написанных на языке \CLANG, методом проверки моделей относительно модели памяти \WkmS;
    экспериментально показана эффективность данного инструмента по сравнению с аналогами.

  \item Предложен метод кодирования слабых моделей памяти 
    с помощью классических простых структур событий с предикатом консистентности.
    Теория данного класса структур событий формализована в системе \coq.
    Выделен фрагмент модели памяти \Wkm, укладывающийся в эту теорию. 

\end{enumerate}

{\novelty}
\begin{enumerate}[beginpenalty=10000] % https://tex.stackexchange.com/a/476052/104425

  \item Впервые доказана корректность оптимальной схемы компиляции
    из модели памяти, основанной на структурах событий (\Wkm), 
    в модели памяти современных мультипроцессоров.

  \item Впервые предложена модель памяти (\WkmS),
    принадлежащая к классу моделей, сохраняющих семантические зависимости, 
    и при этом допускающая реализацию эффективных методов автоматической верификации программ. 

  \item Разработан инструмент проверки моделей \wmc для модели памяти \WkmS,
    который является существенно более эффективным по сравнению с аналогами 
    поддерживающими класс моделей памяти, 
    сохраняющих синтаксические или семантические зависимости
    (\hmc~\autocite{Kokologiannakis-Vafeiadis:ASPLOS2020},
     \rmem~\autocite{Pulte-al:PLDI2019},
     \Nidhugg~\autocite{Abdulla-al:TACAS2015,Abdulla-al:CAV2016},
     \CDSChecker~\autocite{Norris-Demsky:OOPSLA2013}).

  \item Впервые выполнена формализация классической теории 
    простых структур событий в системе \coq. 

\end{enumerate}

{\influence}
Формализация модели памяти \Wkm в системе \coq открывает 
путь к дальнейшей разработке инструментов для  
интерактивной верификации многопоточных программ  
с учетом слабых сценариев исполнения.

Предложенные в рамках модели  \WkmS новые свойства ---
свобода от буферизации операций чтения (load buffering race freedom)
и локальности сертификации (certification locality), --- 
также могут быть добавлены в другие модели памяти 
с целью разработки методов автоматической верификации программ в этих моделях. 
Наличие данных свойств позволяет оптимизировать алгоритм 
проверки моделей и таким образом существенно увеличить его эффективность.

Предложенный инструмент проверки моделей может быть использован на практике
для отладки и верификации многопоточных программ, 
написанных на языке \CLANG, с учетом слабых сценариев исполнения, 
допустимых стандартом этого языка.

Исследование фрагмента модели памяти \Wkm, укладывающегося в
классическую теорию структур событий, закладывает основы
для разработки обобщенной теории структур событий для
описания слабых сценариев исполнения. 

{\reliability} полученных результатов обеспечивается 
математическими доказательствами, разработанными в том числе с использованием
систем интерактивного доказательства теорем, 
а также экспериментами. 
Результаты находятся в соответствии с другими исследованиями в данной области.

{\probation} Основные результаты работы докладывались~на
следующих научных конференциях и семинарах:
Surrey Concurrency Workshop (23-24 июля 2019, Университет Суррея, Великобритания), внутренние семинары JetBrains Research
(18 ноября 2018, 13 апреля 2020, Санкт-Петербург, Россия),
The European Conference on Object-Oriented Programming
(ECOOP, 15-17 ноября 2020, Берлин, Германия),
Spring/Summer Young Researchers' Colloquium on Software Engineering
(27-28 мая 2021, Москва, Россия),
Object-oriented Programming, Systems, Languages, and Applications 
(OOPSLA, 5-10 декабря 2022, Окленд, Новая Зеландия).

% {\contribution} Автор принимал активное участие \ldots

\ifnumequal{\value{bibliosel}}{0}
{%%% Встроенная реализация с загрузкой файла через движок bibtex8. (При желании, внутри можно использовать обычные ссылки, наподобие `\cite{vakbib1,vakbib2}`).
    {\publications} Основные результаты по теме диссертации изложены
    в~XX~печатных изданиях,
    X из которых изданы в журналах, рекомендованных ВАК,
    X "--- в тезисах докладов.
}%
{%%% Реализация пакетом biblatex через движок biber
    \begin{refsection}[bl-author, bl-registered]
        % Это refsection=1.
        % Процитированные здесь работы:
        %  * подсчитываются, для автоматического составления фразы "Основные результаты ..."
        %  * попадают в авторскую библиографию, при usefootcite==0 и стиле `\insertbiblioauthor` или `\insertbiblioauthorgrouped`
        %  * нумеруются там в зависимости от порядка команд `\printbibliography` в этом разделе.
        %  * при использовании `\insertbiblioauthorgrouped`, порядок команд `\printbibliography` в нём должен быть тем же (см. biblio/biblatex.tex)
        %
        % Невидимый библиографический список для подсчёта количества публикаций:
        \printbibliography[heading=nobibheading, section=1, env=countauthorvak,          keyword=biblioauthorvak]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorwos,          keyword=biblioauthorwos]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorscopus,       keyword=biblioauthorscopus]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorconf,         keyword=biblioauthorconf]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorother,        keyword=biblioauthorother]%
        \printbibliography[heading=nobibheading, section=1, env=countregistered,         keyword=biblioregistered]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorpatent,       keyword=biblioauthorpatent]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorprogram,      keyword=biblioauthorprogram]%
        \printbibliography[heading=nobibheading, section=1, env=countauthor,             keyword=biblioauthor]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorvakscopuswos, filter=vakscopuswos]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorscopuswos,    filter=scopuswos]%
        %
        \nocite{*}%
        %
        {\publications} The main results on the topic of the dissertation are presented in~\arabic{citeauthor}~scientific papers,
        \arabic{citeauthorvak} of the publications in a journal recommended by the Higher Attestation Commission\sloppy%
        \ifnum \value{citeauthorscopuswos}>0%
            , \arabic{citeauthorscopuswos} "--- in periodic scientific journals indexed by Web of~Science and Scopus\sloppy%
        \fi%
        \ifnum \value{citeauthorconf}>0%
            , \arabic{citeauthorconf} "--- в~тезисах докладов.
        \else%
            .
        \fi%
        \ifnum \value{citeregistered}=1%
            \ifnum \value{citeauthorpatent}=1%
                Зарегистрирован \arabic{citeauthorpatent} патент.
            \fi%
            \ifnum \value{citeauthorprogram}=1%
                Зарегистрирована \arabic{citeauthorprogram} программа для ЭВМ.
            \fi%
        \fi%
        \ifnum \value{citeregistered}>1%
            Зарегистрированы\ %
            \ifnum \value{citeauthorpatent}>0%
            \formbytotal{citeauthorpatent}{патент}{}{а}{}\sloppy%
            \ifnum \value{citeauthorprogram}=0 . \else \ и~\fi%
            \fi%
            \ifnum \value{citeauthorprogram}>0%
            \formbytotal{citeauthorprogram}{программ}{а}{ы}{} для ЭВМ.
            \fi%
        \fi%
        % К публикациям, в которых излагаются основные научные результаты диссертации на соискание учёной
        % степени, в рецензируемых изданиях приравниваются патенты на изобретения, патенты (свидетельства) на
        % полезную модель, патенты на промышленный образец, патенты на селекционные достижения, свидетельства
        % на программу для электронных вычислительных машин, базу данных, топологию интегральных микросхем,
        % зарегистрированные в установленном порядке.(в ред. Постановления Правительства РФ от 21.04.2016 N 335)
    \end{refsection}%
    \begin{refsection}[bl-author, bl-registered]
        % Это refsection=2.
        % Процитированные здесь работы:
        %  * попадают в авторскую библиографию, при usefootcite==0 и стиле `\insertbiblioauthorimportant`.
        %  * ни на что не влияют в противном случае
        \nocite{Moiseenko-al:OOPSLA22}
        \nocite{Moiseenko-al:ECOOP20}
        \nocite{Moiseenko-al:STJITMO22}
        \nocite{Moiseenko-al:PCS21}
        \nocite{Gladstein-al:ISPRAS21}
        % \nocite{vakbib2}%vak
        % \nocite{patbib1}%patent
        % \nocite{progbib1}%program
        % \nocite{bib1}%other
        % \nocite{confbib1}%conf
    \end{refsection}%
        %
        % Всё, что вне этих двух refsection, это refsection=0,
        %  * для диссертации - это нормальные ссылки, попадающие в обычную библиографию
        %  * для автореферата:
        %     * при usefootcite==0, ссылка корректно сработает только для источника из `external.bib`. Для своих работ --- напечатает "[0]" (и даже Warning не вылезет).
        %     * при usefootcite==1, ссылка сработает нормально. В авторской библиографии будут только процитированные в refsection=0 работы.
}

% При использовании пакета \verb!biblatex! будут подсчитаны все работы, добавленные
% в файл \verb!biblio/author.bib!. Для правильного подсчёта работ в~различных
% системах цитирования требуется использовать поля:
% \begin{itemize}
%         \item \texttt{authorvak} если публикация индексирована ВАК,
%         \item \texttt{authorscopus} если публикация индексирована Scopus,
%         \item \texttt{authorwos} если публикация индексирована Web of Science,
%         \item \texttt{authorconf} для докладов конференций,
%         \item \texttt{authorpatent} для патентов,
%         \item \texttt{authorprogram} для зарегистрированных программ для ЭВМ,
%         \item \texttt{authorother} для других публикаций.
% \end{itemize}
% Для подсчёта используются счётчики:
% \begin{itemize}
%         \item \texttt{citeauthorvak} для работ, индексируемых ВАК,
%         \item \texttt{citeauthorscopus} для работ, индексируемых Scopus,
%         \item \texttt{citeauthorwos} для работ, индексируемых Web of Science,
%         \item \texttt{citeauthorvakscopuswos} для работ, индексируемых одной из трёх баз,
%         \item \texttt{citeauthorscopuswos} для работ, индексируемых Scopus или Web of~Science,
%         \item \texttt{citeauthorconf} для докладов на конференциях,
%         \item \texttt{citeauthorother} для остальных работ,
%         \item \texttt{citeauthorpatent} для патентов,
%         \item \texttt{citeauthorprogram} для зарегистрированных программ для ЭВМ,
%         \item \texttt{citeauthor} для суммарного количества работ.
% \end{itemize}

% Счётчик \texttt{citeexternal} используется для подсчёта процитированных публикаций;
% \texttt{citeregistered} "--- для подсчёта суммарного количества патентов и программ для ЭВМ.

% Для добавления в список публикаций автора работ, которые не были процитированы в
% автореферате, требуется их~перечислить с использованием команды \verb!\nocite! в
% \verb!Synopsis/content.tex!.
