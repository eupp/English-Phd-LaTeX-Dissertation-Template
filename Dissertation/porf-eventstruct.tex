\chapter{Структуры событий для моделей памяти сохраняющих программный порядок}
\label{ch:porf-evenstruct}

В данной главе описан предложенный в диссертации метод 
кодирования слабых моделей памяти сохраняющих программный порядок 
с помощью простых структур событий с предикатом консистентности. 
Этот результат позволяет утверждать, что теория  
моделей памяти сохраняющих программный порядок 
может быть сведена к теории простых структур событий, 
и, как следствие, позволяет применить множество 
уже известных результатов о структурах событий%
~\cite{Winskel:86,Vaandrager:TCS1991,Sassone:MFCS1993,Nielsen:REX93,Winskel-TCS:09}
к проблемам слабых моделей памяти.

Теория простых структур событий и метод сведения 
моделей памяти к ним были формализованы в системе 
доказательства теорем \coq. 
Полученная в результате библиотека может быть использована 
для формализации доказательства свойств структур событий 
и моделей памяти, а также при разработке других
инструментов для интерактивной верификации многоточных программ.
%% Технические вопросы представления структур событий 
%% и других упоминаемых в данной главе формализмов 
%% также кратко рассматриваются в данной главе.  

Данная глава организована следующим образом. 
В разделе \cref{sec:pomset-graphs} описывается метод 
сведения графов сценариев исполнения к языкам помсетов. 
Далее, в разделе \cref{sec:mm-eventstruct} этот результат 
используется для сведения моделей памяти к простым структурам событий. 
В разделе \cref{sec:eventstruct-opsem} описывается 
операционная семантика для инкрементального построения 
структуры событий по заданной многопоточной программе 
и доказываются основные её свойства. 
%% Наконец, в \cref{sec:mm-eventstruct} кратко рассматриваются 
%% технические вопросы представления структур событий 
%% и других упоминаемых в данной главе формализмов.

\section{Сведение графов сценариев исполнения к языкам помсетов}
\label{sec:pomset-graphs}

%% Эквивалентность задания моделей памяти в терминах
%% графов сценариев исполнения и в терминах языков помсетов.

Напомним, что и формализм графов сценариев исполнения,
широко распространненый в сообществе для задания слабых моделей памяти%
~\cite{Alglave-al:TOPLAS14}, 
и формализм помсетов, известный по классическим работам%
~\cite{Pratt:CONCUR84,Gischer:TCS88} 
в области семантики многопоточных программ, основаны на теории частичных порядков. 
Главное отличие между ними заключается в том, что помсет состоит из единственного
отношения частичного порядка --- отношения причинно-следственной связи, 
в то время как граф сценариев исполнения состоит из
нескольких отношений, наделенных различной семантикой. 

Основная идея представленного метода сведения заключается в том 
что в рамках моделей сохраняющих программный порядок 
объединение отношения программного порядка и отношения ``читает-из''
может рассматриваться как аналог отношения причинно-следственной связи.
Таким образом множество графов сценариев исполнения можно факторизовать 
по отношению эквивалентности индуцированных отношений причинно-следственной связи.
И наоборот, можно построить частичную функцию, 
которая принимая на вход помсет и пытается выполнить 
разбиение отношение причинно-следственной связи на 
программный порядок и отношение ``читает-из''. 

Рассмотрим данное построение более формально. 
Для начала, введем формальное определение 
аксиоматических моделей памяти сохраняющих программный порядок.

\begin{definition}
Будем говорить, что граф сценария исполнения $G$ 
сохраняет программный порядок, если выполняются следующие условия: 
\begin{itemize}
  \item $G.\lR \suq \cod{G.\lRF}$; 
    \labelAxiom{$\lRF$-complete}{ax:rf-complete}

  \item $\lPO \cup \lRF$ является ацикличным отношением.
    \labelAxiom{$\lPORF$-acyclic}{ax:porf-acyc}
\end{itemize}
Обозначим множество всех таких графов как $\PorfExecG$.
Также будем говорить, что модель памяти $M$, 
заданная в аксиоматическом стиле, сохраняет программный порядок, 
если для любой программы $P$ каждый соответствующий ей
граф сценария исполнения $G \in \sem{P}_M$ сохраняет программный порядок, 
то есть ${\sem{P}_M \suq \PorfExecG}$.
\end{definition}

Далее определим функцию для построения помсета по графу сценария исполнения.

\begin{definition}
Определим функцию $\gpom : \PorfExecG \fun \Pom[\TidMemLab]$ следующим образом. 
Пусть $G \in \PorfExecG$. Тогда $\gpom(G) = \tup{E, \lab, \ca}$ где
\begin{itemize}
  \item $E = G.\lE$, 
  \item $\lab(e) = \tup{G.\lTID(e), G.\lLAB(e)}$,
  \item $\ca {}\defeq{} (G.\lPO \cup G.\lRF)^*$.
\end{itemize}
\end{definition}

Также предъявим обратную функцию, выполняющую построение 
графа сценария исполнения по помсету.
Для этого сначала определим подмножество помсетов, 
для которых такое построение возможно. 

\begin{definition}
Пусть $p = \tup{E, \lab, \ca} \in \Pom[\TidMemLab]$. 
Будем называть помсет $p$ \emph{разделяемым на потоки} 
(\emph{threaded pomset}) если для любого потока $t \in \Tid$
сужение помсета на события этого потока $p\rst{t}$ 
порождает линейно упорядоченное мультимножество. 
Множество всех таких помсетов будем обозначать как $\ThrdPom[\TidMemLab]$.
\end{definition}

\begin{definition}
Пусть $p = \tup{E, \lab, \ca} \in \ThrdPom[\TidMemLab]$. 
В таком случае определим индуцированное отношение 
программный порядка следующим образом:
$$ \lPO(p) \defeq \bigcup_{t \in \Tid}{\sca\rst{t}}. $$
Также определим множество кандидатов 
на отношение ``читает-из'' $\lRFs(p)$ 
таким образом, что $\lRF \in \lRFs(p)$ 
при выполнении следующих условий:
\begin{itemize}
  \item $\lRF {}\suq{} \lEQLOC \cap \lEQVAL$,
  \item $E \cap \lR \suq \cod{\lRF}$, 
  \item $\ca {}={} (\lPO(p) \cup \lRF)^*$.
\end{itemize}
%
Соответствующим образом определим 
множество графов-кандидатов $\ExecGs{p}$. 
Положим $G \in \ExecGs{p}$ если $p \in \ThrdPom[\TidMemLab]$
и выполнены следующие условия:
\begin{itemize}
  \item $G.\lE = E$,
  \item $\tup{G.\lTID(e), G.\lLAB(e)} = \lab(e)$, 
  \item $G.\lPO = \lPO(p)$, 
  \item $G.\lRF \in \lRFs(p)$. 
\end{itemize}
Если же $p \not\in \ThrdPom[\TidMemLab]$ то положим $\ExecGs{p} = \emptyset$.
%

Множество всех помсетов для которых $\ExecGs{p} \neq \emptyset$
будем обозначать как $\PorfPom[\TidMemLab]$.
Также зададим частично определенную функцию 
${\pomg : \Pom[\TidMemLab] \pfun \ExecG}$,
которая для данного помсета выбирает 
один из соответствующих ему графов.
\begin{equation*}
  \pomg(p) = \begin{cases*}
    G      & такой что $G \in \ExecGs{p}$     \\
    \bot   & если $\ExecGs{p} = \emptyset$ \\
  \end{cases*}
\end{equation*}
%
\end{definition}

\begin{proposition}
Для любого помсета $p \in \Pom[\TidMemLab]$
верно, что $\ExecGs{p} \suq \PorfExecG$
и, следовательно, $\pomg(p) \in \PorfExecG$.
\end{proposition}

Наконец, покажем, что произвольная модель памяти
сохраняющая программный порядок может быть 
представлена как язык помсетов. 

\begin{definition}
Пусть $M$ --- это заданная в аксиоматическом стиле 
модель памяти сохраняющая программный порядок,
то есть $M \suq \PorfExecG$.
Построим соответствующий ей язык помсетов 
$\wmmlang{M} \in \Pomlang[\TidMemLab]$ следующим образом.
Будем считать, что помсет принадлежит этому языку, 
если найдется хотя бы один граф, допустимый $M$,
который соответствует этому помсету.  
$$ p \in \wmmlang{M} \defeq \exists G \in \ExecGs{p} \ldotp G \in M $$
\end{definition}
 
\section{Кодирование модели памяти с помощью структуры событий}
\label{sec:mm-eventstruct}

Задание моделей памяти с помощью простых структур событий
с предикатом консистентности. 

\section{Операционная семантика построения структуры событий}
\label{sec:eventstruct-opsem}

Операционная семантика для построения структуры событий
по многопоточной программе с произвольной моделью памяти
сохраняющей программный порядок.
Свойства полученной семантики:

\begin{itemize}
  \item конфлюэнтность (confluence);
  \item корректность (soundness);
  \item полнота (completness),
    для случая конечных программ;
  \item терминируемость (termination),
    для случая завершающихся программ (well-founded).
\end{itemize}
