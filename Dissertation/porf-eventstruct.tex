\chapter{Структуры событий для моделей памяти сохраняющих программный порядок}
\label{ch:porf-evenstruct}

В данной главе описан предложенный в диссертации метод 
кодирования слабых моделей памяти сохраняющих программный порядок 
с помощью простых структур событий с предикатом консистентности. 
Этот результат позволяет утверждать, что теория  
моделей памяти сохраняющих программный порядок%
\footnote{Везде далее в этом разделе 
под термином ``модель памяти'' будем подразумевать 
модель памяти сохраняющую программный порядок, 
если явно не утверждается иное.} 
может быть сведена к теории простых структур событий, 
и, как следствие, позволяет применить множество 
уже известных результатов о структурах событий%
~\cite{Winskel:86,Vaandrager:TCS1991,Sassone:MFCS1993,Nielsen:REX93,Winskel-TCS:09}
к проблемам слабых моделей памяти.

Теория простых структур событий и метод сведения 
моделей памяти к ним были формализованы в системе 
доказательства теорем \coq. 
Полученная в результате библиотека может быть использована 
для формализации доказательства свойств структур событий 
и моделей памяти, а также при разработке других
инструментов для интерактивной верификации многоточных программ.
%% Технические вопросы представления структур событий 
%% и других упоминаемых в данной главе формализмов 
%% также кратко рассматриваются в данной главе.  

Данная глава организована следующим образом. 
В разделе \cref{sec:pomset-graphs} описывается метод 
сведения графов сценариев исполнения к языкам помсетов. 
Далее, в разделе \cref{sec:mm-eventstruct} этот результат 
используется для сведения моделей памяти к простым структурам событий. 
В разделе \cref{sec:eventstruct-opsem} описывается 
операционная семантика для инкрементального построения 
структуры событий по заданной многопоточной программе 
и доказываются основные её свойства. 
%% Наконец, в \cref{sec:mm-eventstruct} кратко рассматриваются 
%% технические вопросы представления структур событий 
%% и других упоминаемых в данной главе формализмов.

\section{Сведение графов сценариев исполнения к языкам помсетов}
\label{sec:pomset-graphs}

%% Эквивалентность задания моделей памяти в терминах
%% графов сценариев исполнения и в терминах языков помсетов.

Напомним, что и формализм графов сценариев исполнения,
широко распространненый в сообществе для задания слабых моделей памяти%
~\cite{Alglave-al:TOPLAS14}, 
и формализм помсетов, известный по классическим работам%
~\cite{Pratt:CONCUR84,Gischer:TCS88} 
в области семантики многопоточных программ, основаны на теории частичных порядков. 
Главное отличие между ними заключается в том, что помсет состоит из единственного
отношения частичного порядка --- отношения причинно-следственной связи, 
в то время как граф сценариев исполнения состоит из
нескольких отношений, наделенных различной семантикой. 

Основная идея представленного метода сведения заключается в том 
что в рамках моделей сохраняющих программный порядок 
объединение отношения программного порядка и отношения ``читает-из''
может рассматриваться как аналог отношения причинно-следственной связи.
Таким образом множество графов сценариев исполнения можно факторизовать 
по отношению эквивалентности индуцированных отношений причинно-следственной связи.
И наоборот, можно построить частичную функцию, 
которая принимая на вход помсет и пытается выполнить 
разбиение отношение причинно-следственной связи на 
программный порядок и отношение ``читает-из''. 

Рассмотрим данное построение более формально. 
Для начала, введем формальное определение 
аксиоматических моделей памяти сохраняющих программный порядок.

\begin{definition}
Будем говорить, что граф сценария исполнения $G$ 
сохраняет программный порядок, если выполняются следующие условия: 
\begin{itemize}
  \item $G.\lR \suq \cod{G.\lRF}$; 
    \labelAxiom{$\lRF$-complete}{ax:rf-complete}

  \item $\lPO \cup \lRF$ является ацикличным отношением.
    \labelAxiom{$\lPORF$-acyclic}{ax:porf-acyc}
\end{itemize}
Обозначим множество всех таких графов как $\PorfExecG$.
Также будем говорить, что модель памяти $M$, 
заданная в аксиоматическом стиле, сохраняет программный порядок, 
если для любой программы $P$ каждый соответствующий ей
граф сценария исполнения $G \in \sem{P}_M$ сохраняет программный порядок, 
то есть ${\sem{P}_M \suq \PorfExecG}$.
\end{definition}

Далее определим функцию для построения помсета по графу сценария исполнения.

\begin{definition}
Определим функцию $\gpom : \PorfExecG \fun \Pom[\TidMemLab]$ следующим образом. 
Пусть $G \in \PorfExecG$. Тогда $\gpom(G) = \tup{E, \lab, \ca}$ где
\begin{itemize}
  \item $E = G.\lE$, 
  \item $\lab(e) = \tup{G.\lTID(e), G.\lLAB(e)}$,
  \item $\ca {}\defeq{} (G.\lPO \cup G.\lRF)^*$.
\end{itemize}
\end{definition}

Также предъявим обратную функцию, выполняющую построение 
графа сценария исполнения по помсету.
Для этого сначала определим подмножество помсетов, 
для которых такое построение возможно. 

\begin{definition}
Пусть $p = \tup{E, \lab, \ca} \in \Pom[\TidMemLab]$. 
Будем называть помсет $p$ \emph{разделяемым на потоки} 
(\emph{threaded pomset}) если для любого потока $t \in \Tid$
сужение помсета на события этого потока $p\rst{t}$ 
порождает линейно упорядоченное мультимножество. 
Множество всех таких помсетов будем обозначать как $\ThrdPom[\TidMemLab]$.
\end{definition}

\begin{definition}
Пусть $p = \tup{E, \lab, \ca} \in \ThrdPom[\TidMemLab]$. 
В таком случае определим индуцированное отношение 
программный порядка следующим образом:
$$ \lPO(p) \defeq \sca \cap \lEQTID. $$
Также определим множество кандидатов 
на отношение ``читает-из'' $\lRFs(p)$ 
таким образом, что $\lRF \in \lRFs(p)$ 
при выполнении следующих условий:
\begin{itemize}
  \item $\lRF {}\suq{} \lEQLOC \cap \lEQVAL$,
  \item $E \cap \lR \suq \cod{\lRF}$, 
  \item $\ca {}={} (\lPO(p) \cup \lRF)^*$.
\end{itemize}
%
Соответствующим образом определим 
множество графов-кандидатов $\ExecGs{p}$. 
Положим $G \in \ExecGs{p}$ если $p \in \ThrdPom[\TidMemLab]$
и выполнены следующие условия:
\begin{itemize}
  \item $G.\lE = E$,
  \item $\tup{G.\lTID(e), G.\lLAB(e)} = \lab(e)$, 
  \item $G.\lPO = \lPO(p)$, 
  \item $G.\lRF \in \lRFs(p)$. 
\end{itemize}
Если же $p \not\in \ThrdPom[\TidMemLab]$ то положим $\ExecGs{p} = \emptyset$.
%

Множество всех помсетов для которых $\ExecGs{p} \neq \emptyset$
будем обозначать как $\PorfPom[\TidMemLab]$.
Также зададим частично определенную функцию 
${\pomg : \Pom[\TidMemLab] \pfun \ExecG}$,
которая для данного помсета выбирает 
один из соответствующих ему графов.
\begin{equation*}
  \pomg(p) = \begin{cases*}
    G      & такой что $G \in \ExecGs{p}$   \\
    \bot   & если $\ExecGs{p} = \emptyset$. \\
  \end{cases*}
\end{equation*}
%
\end{definition}

\begin{proposition}
Для любого помсета $p \in \Pom[\TidMemLab]$
верно, что $\ExecGs{p} \suq \PorfExecG$
и, следовательно, $\pomg(p) \in \PorfExecG$.
\end{proposition}

Наконец, покажем, что произвольная модель памяти
сохраняющая программный порядок может быть 
представлена как язык помсетов. 

\begin{definition}
Пусть $M$ --- это заданная в аксиоматическом стиле 
модель памяти сохраняющая программный порядок,
то есть $M \suq \PorfExecG$.
Построим соответствующий ей язык помсетов 
$\wmmlang{M} \in \Pomlang[\TidMemLab]$ следующим образом.
Будем считать, что помсет принадлежит этому языку, 
если найдется хотя бы один граф, допустимый $M$,
который соответствует этому помсету.  
$$ p \in \wmmlang{M} \defeq \exists G \in \ExecGs{p} \ldotp G \in M $$
\end{definition}
 
\section{Кодирование модели памяти с помощью структуры событий}
\label{sec:mm-eventstruct}

В предыдущем разделе было показано, что 
модель памяти сохраняющая программный порядок 
может быть представлена как язык помсетов. 
Это наблюдение позволяет заключить, 
что модель памяти также может быть представлена 
и как простая структура событий с предикатом консистентности,
ведь, как было упомянуто в разделе~\cref{sec:pomsets-eventstruct}, 
данный класс структур событий позволяет выразить произвольный язык помсетов. 

В этом разделе будет также показано,
что на самом деле модель памяти сохраняющая программный порядок 
может быть представлена как простая структура событий специального вида.
В данной структуре событий все события одного потока образуют дерево. 
Ветви этого дерева соответствуют различным путям исполнения данного потока,
а события, принадлежащие разным веткам дерева, находятся в отношении конфликта. 
Cтруктуры событий данного вида будем называть 
\emph{разделяемыми на потоки} (\emph{threaded prime event structures}).

Основной особенностью структуры событий принадлежашей 
данному подклассу является то,
что она может быть закодирована с помощью 
только одного отношения частичного порядка
и некоторого отношения эквивалентности на метках.
Отношение конфликта при этом не требуется хранить явно, 
оно индуцируется двумя предыдущими отношениями. 
Такое представление, зачастую, позволяет существенно 
упростить рассуждения о структурах событий. 
Например, можно заметить, что две структуры событий 
данного класса изоморфны тогда и только тогда, 
когда они изоморфны как помеченные частично упорядоченные множества. 

Введем формальные определения описанных выше объектов. 

\begin{definition}
Частично упорядоченное множество $\tup{E, \ca}$ 
называется \emph{префиксно-линейно упорядоченным} 
(\emph{downward-total}) если выполняется следующие условие:
$$ x \ca z \wedge y \ca z \implies x \ca y \vee y \ca x. $$
Если в дополнение к этому частично упорядоченное множество являетя 
префикс-конечным, то будем называть такое множество \emph{лесом}.
Если кроме того существует наименьший элемент $e_0 \in E$, 
тогда будем называть такое множество \emph{деревом}, 
а $e_0$ --- корнем этого дерева. 
\end{definition}

\begin{proposition}
Для леса $\tup{E, \ca}$ можно задать 
частично определенную функцию $\pred : E \pfun E$, 
возращающую родителя данного элемента: 
$$ \pred(e) = e' \;{}\iff{}\; e' \ica e $$
\end{proposition}

\begin{proposition}
Размеченный лес $\tup{E, \lab, \ca}$ порождает простую структуру событий 
без волнений (confusion-free) $\tup{E, \lab, \ca, \cf}$, 
где отношение непосредственного конфликта задается следующим образом: 
$$ e_1 \icf e_2 \defeq e_1 \neq e_2 \wedge \pred(e_1) = \pred(e_2). $$
\end{proposition}

\begin{definition}
Пусть $S = \tup{E, \lab, \ca, \cf} \in \PrimeES[L]$ --- 
это простая структура событий
с бинарным конфликтом, и пусть $\simeq$ это некоторое 
отношение эквивалентности на метках $L$.
Рассмотрим сужение структуры событий на классы эквивалентности 
${ S\rst{\simeq} \defeq \tup{E, \lab, \ca {}\cap{} \simeq, \cf {}\cap{} \simeq} }$.
Будем говорить, что структура \emph{разделима на потоки относительно отношения $\simeq$}
если $S\rst{\simeq}$ образует размеченный лес и, кроме того, 
отношение конфликта во всей структуре событий является 
продолжением отношения конфликта в суженной структуре, то есть 
$${ \icf_S = \icf_{S\rst{\simeq}} }.$$
Будем обозначать множество всех таких структур 
как $\ThrdPrimeES[L,\simeq]$
\end{definition}

\begin{proposition}
Пусть $p = \tup{E, \lab, \ca}$ это 
размеченное частично упорядоченное множество, 
а $\simeq$ отношение эквивалентности на метках событий.
Предположим, что сужение отношения порядка на классы эквивалентности 
${ p\rst{\simeq} \defeq \tup{E, \lab, \ca {}\cap{} \simeq} }$ образует лес.
Тогда $p$ порождает разделимую на потоки относительно отношения $\simeq$
простую структуру событий $\tup{E, \lab, \ca, \cf}$ 
где отношение конфликта $\cf$ индуцированно отношением 
непосредственного конфликта в суженной структуре $\icf_{p\rst{\simeq}}$.
\end{proposition}

Рассмотрим структуру событий $S \in \ThrdPrimeES[\TidMemLab, \lEQTID]$
разделяемую на потоки относительно отношения $\lEQTID$.
Для данной модели памяти $M$ можно дополнить $S$ предикатом консистентности, 
который будет отфильтровывать все конфигурации, 
не принадлежащие языку $\wmmlang{M}$.

\begin{definition}
Пусть ${S = \tup{E, \lab, \ca, \cf} \in \ThrdPrimeES[\TidMemLab, \lEQTID]}$
и ${M \suq \PorfExecG}$.
Определим простую структуру событий с предикатом консистентности
${\wmmpes{S}{M} = \tup{E, \lab, \ca, \cons}}$ таким образом, что:
\begin{itemize}
  \item $E {}\defeq{} E_S$,
  \item $\lab {}\defeq{} \lab_S$,
  \item $\ca {}\defeq{} \ca_S$,
  \item $C \in \cons {}\defeq{} C \not\in \gcf_S \wedge S\rst{C} \in \wmmlang{M}$.
\end{itemize}
\end{definition}

Корректность структуры событий $\wmmpes{S}{M}$ относительно языка 
порождаемого $M$ вытекает напрямую из определения. 

\begin{proposition}
Для любой структуры событий $S = \ThrdPrimeES[\TidMemLab, \lEQTID]$
и любой модели памяти $M \suq \PorfExecG$
язык помсетов, порождаемый $\wmmpes{S}{M}$, 
корректен относительно языка $\wmmlang{M}$, то есть:
$$ \pomlang{\wmmpes{S}{M}} \suq \wmmlang{M}. $$
\end{proposition}

Тем не менее, нетрудно заметить, что структура событий $\wmmpes{S}{M}$
не обязана быть полной относительно языка порождаемого $M$.
В следующем разделе будет рассмотрена операционная семантика 
для инкрементального построения структуры $S$ 
порождающей структуру $\wmmpes{S}{M}$ 
полную относительно языка $\sem{P}_M$ для 
любой заверщающейся программы $P$.

\section{Операционная семантика построения структуры событий}
\label{sec:eventstruct-opsem}

В данном разделе представлена операционная семантика 
для инкрементального построения структуры событий.
Предложенная семантика предоставляет конкретную
процедуру построения структуры событий, 
кодирующую все возможные сценарии поведения 
заданной программы $P$ в заданной модели памяти $M$.  
Также доказываются основные свойства данной семантики, 
а именно \emph{конфлюэнтность}, \emph{полнота} и \emph{терминируемость}.

Отметим, что помимо модели памяти $M$, данная семантика также параметризована
последовательной семантикой потоков программы $P$, 
заданной в терминах системы помеченных переходов $\LTS$. 
Это, в частности, позволяет абстрагироваться от деталей 
реализации последовательной семантики 
и комбинировать предложенную семантику построения структуры событий 
с различными моделями последовательных вычислений. 


\todo{}

\input{Dissertation/porf-eventstruct-opsem}

%% Операционная семантика для построения структуры событий
%% по многопоточной программе с произвольной моделью памяти
%% сохраняющей программный порядок.
%% Свойства полученной семантики:

%% \begin{itemize}
%%   \item конфлюэнтность (confluence);
%%   \item корректность (soundness);
%%   \item полнота (completness),
%%     для случая конечных программ;
%%   \item терминируемость (termination),
%%     для случая завершающихся программ (well-founded).
%% \end{itemize}
