\chapter{Верификация методом проверки модели для \WkmS}
\label{ch:mc-weakestmo2}

В данной главе описывается разработанный в рамках данной диссертации 
инструмент проверки моделей \wmc для верификации 
многопоточных программ в модели \WkmS.
Предложенный инструмент разработан на основе \genmc --- 
инструмента для автоматической верификации многопоточных программ, 
написанных на языке \CLANG, в модели памяти \RCMM. 
Таким образом предложенный \wmc расширяет 
оригинальный инструмент \genmc, 
добавляя в него поддержку модели памяти \WkmS.  

Алгоритм, лежащий в основе \wmc, полагается на новые свойства модели \WkmS, 
а именно свободу от буферизации операций чтения и 
локальность сертификации, чтобы реализовать ключевые 
оптимизации и сделать верификацию в модели \WkmS возможной на практике.  
В рамках серии экспериментов показывается, что 
\wmc обладает лучшей производительностью по сравнению с аналогами.

Данная глава организована следующим образом. 
В разделе \ref{sec:mc-wmm} дано краткое введение 
в задачу верификации методом проверки моделей 
в контексте слабых моделей памяти.
В разделе \ref{sec:genmc} описывается оригинальный инструмент 
\genmc для модели памяти \RCMM.
В разделе \ref{sec:wmc} описывается разработанный в 
рамках данной диссертации инструмент \wmc для модели памяти \WkmS.
Наконец, в разделе \ref{sec:wmc-eval} описаны эксперименты 
по измерению производительности \wmc и его сравнению с аналогами.

\section{Метод проверки моделей для слабых моделей памяти}
\label{sec:mc-wmm}

Напомним, что \emph{метод проверки моделей} (\emph{model checking})~\cite{Baier:2008} 
является одним из методов формальной автоматической верификации программ,
целью которого является проверка удовлетворяет ли 
модель программы заданной спецификации. 
В контексте данной работы будем говорить только 
о проверке свойств \emph{безопасности} (\emph{safety properties})~\cite{Baier:2008}, 
то есть свойств утверждающих, что некоторое 
``плохое'' событие никогда не произойдет в системе. 

Метод проверки моделей с \emph{явным представлением состояний} 
(\emph{explicit-state model checking}) достигает 
этой цели путем явного построения пространства состояний программы 
и перечисления возможных сценариев ее исполнения.
Поскольку количество возможных сценариев исполнения 
растет экспоненциально с ростом программы, 
перечисление всех возможных сценариев исполнения 
на практике не предоставляется возможным. 

\emph{Проверка моделей без сохранения состояний} 
(\emph{stateless model checking}) позволяет 
избежать экспоненциального потребления памяти 
на хранение всего пространства состояний программы 
и достичь полиномиального потребления памяти  --- 
в каждый момент времени алгоритм проверки моделей 
сохраняет только один сценарий исполнений программы 
и некоторую дополнительную информацию.

Проверка моделей без сохранения состояний зачастую 
используется в комбинации с техникой  
\emph{редукции частичного порядка} (\emph{partial order reduction}), 
которая позволяет сократить пространство перебора. 
В основе этой техники лежит наблюдение, что 
порядок выполнения некоторых операций программы 
не имеет значения для конечного результата, 
то есть, что некоторые операции коммутируют. 
Таким образом все сценарии исполнения можно разбить 
на классы эквивалентности, где каждый класс 
можно представить отношением частичного порядка, 
которое упорядочивает только те операции, которые не коммутируют. 
Тогда достаточно рассмотреть только один сценарий исполнения из каждого класса.   

В контексте слабых моделей памяти принято рассматривать 
$\lPORF$-эквивалентность сценариев исполнения%
~\cite{},
то есть эквивалентность с точностью до отношений $\lPO$ и $\lRF$ 
на соответствующих графах сценариев исполнения.
Иногда также рассматривается $\lPORFMO$-эквивалентность, 
то есть эквивалентность с точностью до отношений $\lPO$, $\lRF$ и $\lMO$. 
Таким образом задача проверки моделей в контексте 
слабых моделей памяти сводится к задаче перечисления 
консистентных графов сценариев исполнения заданной программы. 

\section{Инструмент \genmc для модели \RCMM}
\label{sec:genmc}

Инструмент \wmc был разработан на основе инструмента \genmc%
~\cite{Kokologiannakis:PLDI2019, Kokologiannakis:CAD2021}, 
который выполняет автоматическую верификацию многопоточных программ
методом проверки моделей с явным представлением состояний, но без сохранения
пространства состояний (explicit-state stateless model checking).
Инструмент в первую очередь предназначен 
для верификации программ, написанных на языке \CLANG, 
но может быть адаптирован для других языков программирования, 
поддерживающих компиляцию в промежуточное представление \LLVM.  
По-умолчанию верификация выполняется в модели памяти \RCMM,
однако инструмент потенциально поддерживает 
произвольные модели памяти, сохраняющие программный порядок.
\genmc использует технику редукции частичных порядков
и позволяет пользователю выбрать либо редукцию по
отношению $\lPORF$-эквивалентности, либо по отношению $\lPORFMO$-эквивалентности.
В рамках данной работы будем подразумевать, что используется
редукция по отношению $\lPORFMO$-эквивалентности,
так как данный тип редукции частичных порядков 
проще адаптировать для модели \WkmS.

Инструмент \genmc состоит из двух основых компонент: 
\emph{интерпретатора} и \emph{драйвера}~\cite{Kokologiannakis:CAD2021}. 
\textbf{Интерпретатор} выполняет исполнение биткода \LLVM  
и оповещает драйвер о наступлении определенных событий 
(например, о выполнении инструкций чтения или записи в разделяемую память). 
\textbf{Драйвер} в свою очередь 
ответственен за генерацию сценариев исполнения программы и 
проверку их консистентности согласно заданной модели памяти.
Для выплнения этих задач драйвер поддерживает несколько структур данных, 
включая текущий граф сценария исполнения и 
множество перепосещаемых вершин, 
то есть подмножество событий чтения в этом графе 
которые в дальнейшем могут быть повторно рассмотрены драйверомм 
с целью исследования альтернативных сценариев исполнения.

Для добавления поддержки новой модели памяти в \genmc 
предполагается разработка нового драйвера, специфичного 
для данной конкретной модели памяти.
При этом, с целью лучшего переиспользования программного кода, 
допускается наследование классов, реализующих драйверы, 
в соответствии с принципами объектно-ориентированного программирования.  
Расширение инструмента \genmc с целью поддержки 
модели памяти \WkmS было реализовано именно таким образом ---
путем добавления нового драйвера, который наследует 
от драйвера для модели памяти \RCMM.
Поэтому, чтобы разобрать алгоритм, реализованный в новом драйвере, 
необходимо сначала разобрать алгоритм работы драйвера 
для модели \RCMM.

\input{Dissertation/alg/visitone}

\input{Dissertation/alg/calcrevisits}

\section{Инструмент \wmc для модели \WkmS}
\label{sec:wmc}

Описание модифицированной версии инструмента \wmc для модели \WkmS. 
Пример работы. Обсуждение открытых проблем и заделов
для будущей работы в инструменте. 

\input{Dissertation/alg/getpromises}

\input{Dissertation/alg/certrevs}


\section{Апробация инструмента \wmc}
\label{sec:wmc-eval}

Для того чтобы оценить эффективность \wmc были 
сформулированы следующие исследовательские вопросы.
\begin{enumerate}

  \item Как часто на практике встречаются гонки с буферизацией операций чтения
    и каковы накладные расходы на их обнаружение?

  \item Насколько эффективен \wmc по сравнению с другими инструментами, 
    которые поддерживают модели памяти, 
    сохраняющие синтаксические или семантические зависимости? 

  \item Как изменяется производительность \wmc на синтетических программах, 
    содержащих множество гонок с буферизацией операций чтения? 
    
\end{enumerate}

Ответ на первый вопрос позволит определить, как часто 
на практике поведение инструмента \wmc отличается от поведения 
оригинального инструмента \genmc.
Так как модель \WkmS, благодаря свойству \LBRF, присваивает 
программам, свободным от данного типа гонок, 
только \RCMM консистентные сценарии исполнения, 
это означает, что чем реже такие гонки встречаются на практике, 
тем ближе производительность \wmc будет к производительности \genmc.

Ответ на второй вопрос позволит оценить, насколько эффективны 
оказываются оптимизации, реализованные в \wmc благодаря 
наличию свойств \LBRF и \CL у модели \WkmS.  

Ответ на третий вопрос позволит оценить как изменяется 
производительность \wmc в худшем случае на искусственный примерах.

\subsection*{Постановка экспериментов}

В данном подразделе опишем использованные для сравнения 
с \wmc инструменты проверки моделей и методологию поставленных экспериментов.

\paragraph{Инструменты проверки моделей.}

В экспериментах будем сравнивать \wmc с набором инструментов, 
представленных ниже. 

\textbf{\genmc}~\cite{Kokologiannakis:PLDI2019,Kokologiannakis:CAD2021} ---
это инструмент проверки моделей, выполняющий верификацию в модели памяти \RCMM%
\footnote{\genmc также может быть адаптирован для поддержки 
  произвольной модели памяти, сохраняющей программный порядок.}, 
которая относится к классу моделей, сохраняющих программный порядок.  
Отметим, что в отличие от всех других инструментов, используемых в экспериментах, 
только \genmc не использует спекулятивное исполнение инструкций 
ни в каком виде, так как для класса моделей, сохраняющих программный порядок,
нет необходимости в его использовании для моделирования поведения программы. 
Поэтому ожидаемо, что \genmc будет показывать 
лучшее время работы по сравнению со всеми другими инструментами. 
%% По этой причине, а также потому, что \wmc изначально разрабатывался 
%% на основе \genmc, время работы \genmc в экспериментах 
%% используется в качестве базового измерения. 

\textbf{\hmc}~\cite{Kokologiannakis-Vafeiadis:ASPLOS2020} --- 
это расширение \genmc, поддерживающее модель памяти \IMM
\footnote{\hmc также может быть адаптирован для поддержки 
  произвольной модели памяти, сохраняющей синтаксические зависимости.},
которая относится к классу моделей, сохраняющих синтаксические зависимости.  
Алгоритм, лежащий в основе \hmc, отслеживает синтаксические зависимости между событиями, 
чтобы предотвратить появление циклов причинно-следственной связи. 

\textbf{\Nidhugg}~\cite{Abdulla-al:TACAS2015,Abdulla-al:CAV2016} --- 
это инструмент проверки моделей, который, среди прочих, 
поддерживает модель памяти мультипроцессоров \POWER, 
относящуюся к классу моделей, сохраняющих синтаксические зависимости.  
Аналогично \hmc данный инструмент отслеживает синтаксические зависимости между событиями.

\textbf{\rmem}~\cite{RMEM} --- 
это симулятор для выполнения многопоточных программ с учетом слабых сценариев исполнения. 
Данный симулятор поддерживает множество моделей памяти различных мультипроцессоров. 
В рамках данной работы в экспериментах используется режим \PrmARM%
~\cite{Pulte-al:PLDI2019}, так как данный режим является 
наиболее эффективным в инструменте \rmem.
Режим \PrmARM проводит верификацию в модели памяти \ARMv{8}, 
которая относится к классу моделей, сохраняющих синтаксические зависимости. 
При этом для моделирования спекулятивного выполнения инструкций 
используется механизм обещаний~\cite{Kang-al:POPL17}.  

\textbf{\CDSChecker}~\cite{Norris-Demsky:OOPSLA2013} --- 
еще один инструмент проверки моделей, выполняющий верификацию 
в неформально определенной модифицированной версии модели памяти \CMM.
Данный инструмент также использует механизм обещаний~\cite{Kang-al:POPL17}, 
чтобы моделировать спекулятивное исполнение и отслеживать
семантические зависимости между событиями. 
Таким образом, среди всех перечисленных инструментов,
только \CDSChecker выполняет верификацию в модели памяти, 
относящейся к классу моделей, сохраняющих семантические зависимости. 
Следовательно, данный инструмент наиболее близок по функциональности к \wmc.

Все вышеперечисленные инструменты выполняют проверку 
моделей с явным представлением состояний, 
но без сохранения пространства состояний (explicit-state stateless model checking). 
Эти инструменты в первую очередь предназначены 
для верификации многопоточных программ с учетом слабых моделей памяти. 
Более того, все инструменты, за исключением \genmc, выполняют верификацию 
в моделях памяти, относящихся к классу моделей, 
сохраняющих синтаксические или семантические зависимости. 
Данные инструменты были выбраны на основе публикаций 
на ведущих конференциях по тематике языков программирования 
и формальной верификации программ, и среди инструментов, 
удовлетворяющих приведенным выше свойствам, 
составляют наиболее полный список.

\paragraph{Конфигурация системы.} 

Все эксперименты проводились на системе Dell PowerEdge M620 blade
с двумя процессорами Intel Xeon E5-2667 v2 (8 ядер, 3.3 GHz)
и 256GB оперативной памяти. Операционная система --- Debian.
Использовалась библиотека \LLVM версии 7.
Также использовались следующие версии сравниваемых инструментов: 
\hmc (v0.5), \genmc (v0.5), \Nidhugg (v0.3), 
коммит с хеш-кодом \#da671f7 для \CDSChecker
и коммит с хеш-кодом \#85c8130 для \rmem (v0.1). 

\subsubsection*{Описание экспериментов.} 

Для того, чтобы ответить на \textbf{первый исследовательский вопрос} 
было поставлено два эксперимента. 

В рамках первого эксперимента были рассмотрены 
%% TODO: дождаться уточнения от Михалиса по поводу этих тестов
%% реализации 13 алгоритмов блокировки из работы%
%% ~\cite{Oberhauser-al:ASPLOS2021},
5 реализаций многопоточной очереди из работы%
~\cite{Kokologiannakis:PLDI2019}
и 11 реализаций многопоточных структур данных из работы%
\footnote{Были рассмотрены только 11 из 43 
тестовых программ из данной работы, 
так как эти программы были написаны на языке C++,
а \genmc поддерживает язык C и только подмножество возможностей языка C++.}
~\cite{Ou-Demsky:OOPSLA18}.
На данных программах был запущен инструмент \wmc с целью 
поиска гонок с буферизацией операций чтения.
Результаты представлены в таблице~\ref{tab:lbraces}.
Таблица содержит название тестовой программы в первой колонке, 
а во второй колонке символ~\cmark~если соответствующая 
программа \textbf{не содержит} гонок данного вида 
и символ~\xmark~иначе.

\input{Dissertation/table/lbraces}

В рамках второго эксперимента была рассмотрена 241 многопоточная программа 
из набора тестовых программ инструмента \genmc, 
который включает как небольшие ``лакмусовые тесты''~\cite{Alglave-al:TACAS2011}, 
так и реализации различных многопоточных структур данных.
Данный набор программ был разбит на две группы:
те программы, которые содержат гонки с буферизацией чтения 
(28 программ, название группы LB-racy)
и те, которые не содержат гонок данного типа 
(213 программ, название группы LB-race-free).
Далее было замерено время работы инструментов \genmc, \hmc и \wmc на данных программах.  
Результаты замеров представлены в таблице~\ref{tab:overhead}.
В данной таблице в первой колонке приводится название группы, 
а в остальных колонках суммарное время работы инструментов 
на соответствующей группе программ в секундах.

\input{Dissertation/table/overhead}

Для ответа на \textbf{второй исследовательский вопрос}, 
то есть для сравнения \wmc с аналогами, 
было использовано два тестовых набора программ.

Первый набор тестовых программ был взят 
из соревнования по верификации программ \SVCOMP~\cite{SVCOMP}, 
а именно из категорий \texttt{pthread} и \texttt{pthread-atomic}.
Тестовые программы были модифицированы путем замены 
обращений к разделяемым переменным на атомарные обращения 
с ослабленным (relaxed) режимом доступа 
для того, чтобы спровоцировать появление гонок с буферизацией операций чтения. 
Результаты экспериментов для этого тестового набора 
представлены в таблице~\ref{tab:svcomp}. 
В первой колонке приводится название тестовой программы, 
а в остальных колонках время работы инструментов 
на соответствующей программе в секундах.
При этом было установленно максимальное ограничение на время работы --- 30 минут.
Если время работы инструмента выходило за этот предел, 
то его исполнение на данной тестовой программе обрывалось. 
В таблице этот факт отображается знаком \timeoutNoSpc
в соответствующей колонке.
Также отметим, что на некоторых программах из данного набора 
инструмент \Nidhugg был исключен из сравнения, так как он не поддерживает 
атомарные инструкции чтения-модификации-записи (\RMW) в модели памяти \POWER. 
Соответствующие ячейки в таблице~\ref{tab:svcomp} оставлены пустыми.

\input{Dissertation/table/svcomp}

Второй набор тестовых программ состоит из 
реализаций различных многопоточных структур данных, 
взятых из тестового набора \CDSChecker~\cite{Norris-Demsky:OOPSLA2013}. 
В данных программах все циклы были развернуты 
на определенную фиксированную глубину, чтобы исключить из сравнения тот фактор, 
поддерживают ли инструменты продвинутые методы рассуждения о циклах или нет. 
В рамках экспериментов с данным тестовым набором инструмент \Nidhugg 
был исключен из сравнения по той же причине что 
и в случае некоторых программ из предыдущего тестового набора. 
Инструмент \rmem также был исключен из-за сложности портирования 
программ из данного набора в формат входных данных этого инструмента.
Результаты экспериментов для этого тестового набора 
представлены в таблице~\ref{tab:datastructures}. 
В первой колонке таблицы приводится название тестовой программы, 
а в остальных колонках время работы инструментов 
на соответствующей программе в секундах.
Максимальное ограничение на время работы также составляло 30 минут.

\input{Dissertation/table/realworld}

Наконец, для ответа на \textbf{третий исследовательский вопрос}, 
было измерено количество исследованных \wmc 
сценариев исполнения для нескольких синтетических программ, 
содержащих множество гонок с буферизацией операций чтения. 

Кратко опишем эти тестовые программы. 
Программы \bmark{LB+ctrl(N)} и \bmark{LB+data(N)}
являются аналогом программы \ref{ex:lb-nodep} 
из раздела \cref{sec:models-classes},
за исключением того, что в этих программах 
$\lPORF$ цикл охватывает \texttt{N} потоков.
Также, в программе \bmark{LB+ctrl(N)} используются зависимости 
по потоку управления, а не зависимости по данным как в \bmark{LB+data(N)}.
Тестовая программа \bmark{LB-nodep(N)} является аналогом 
программы \ref{ex:lb-spec} из раздела \ref{sec:models-requirements}, 
за исключением того, что в этой программе 
$\lPORF$ цикл также охватывает \texttt{N} потоков.
Наконец, программа \bmark{LB-pairs(N)} содержит \texttt{N}
независимых пар потоков, где каждая пара образует 
подпрограмму, аналогичную \ref{ex:lb-spec}.

Результаты последнего эксперимента приведены в таблице~\ref{tab:lb}.
Первая колонка данной таблицы содержит название тестовой программы. 
Вторая колонка --- количество уникальных сценариев исполнения, 
исследованных \wmc. Третья колонка --- процент повторяющихся
сценариев, посещенных \wmc несколько раз, от 
количества уникальных сценариев. 
Последняя колонка показывает процент блокированных 
сценариев --- то есть тех сценариев, которые 
были отброшены во время работы инструмента 
из-за невозможности сертифицировать все сделанные обещания.

\input{Dissertation/table/lb}

\subsection*{Результаты}

Проанализируем результаты, полученные в ходе описанных экспериментов.

\subsubsection*{Затраты на обнаружение гонок с буферизацией операции чтения}

Результаты первого эксперимента (таблица~\ref{tab:lbraces})
подтверждают гипотезу, что гонки с буферизацией операций чтения 
довольно редко встречаются на практике: 
из 16 тестовых программ ни в одной не были найдены гонки данного вида.
%% из 28 тестовых программ только в 2 были найдены гонки данного вида.

По результатам второго эксперимента (таблица~\ref{tab:overhead}), 
согласно данным во второй строке таблицы, можно видеть, что
процесс обнаружения гонок с буферизацией операций чтения 
в инструменте \wmc приводит к накладным расходам на время работы 
примерно в 25\% процентов по сравнению с временем работы \genmc.
Тем не менее, эти накладные расходы существенно ниже чем 
расходы на поддержание информации о синтаксических зависимостях
в инструменте \hmc, которые увеличивают время работы \hmc
на программах из второй группы в два раза.  
Также заметим, что на программах из обоих групп
время работы \wmc существенно меньше времени работы \hmc. 

\subsubsection*{Сравнение инструмента \wmc с аналогами}

Проанализируем данные из таблицы~\ref{tab:svcomp}. 
Можно видеть, что \Nidhugg и \rmem работаю существенно медленнее остальных 
конкурентов почти на всех тестовых программах. 
Это объясняется особенностью используемых этими инструментами алгоритмов.
\Nidhugg выполняет дорогостоящие проверки консистентности
на каждом шаге исполнения программы.
\rmem строит линейный порядок на множестве всех операций записи.

Единственная программа, на которой \Nidhugg показывает 
лучший результат по сравнению с остальными --- это \bmark{szymanski}.
Дело в том, что в данной программе используется 
последовательно-согласованные барьеры памяти.
\Nidhugg выполняет проверку последовательно-согласованной
консистентности на каждом шаге исполнения программы, в то время 
как остальные инструменты откладывают эту проверку 
до завершения исследования сценария исполнения. 
В то время как в большинстве случаев выполнение этой дорогостоящей проверки 
на каждом шаге существенно замедляет \Nidhugg, 
в случае программы \bmark{szymanski} это позволяет 
раньше отфильтровать неконсистентные сценарии исполнения 
и таким образом сократить пространство перебора. 

Что касается сравнения с \CDSChecker, то можно видеть,
что этот инструмент опережает \wmc только 
на программах \bmark{reorder} и \bmark{singleton}, 
а на всех остальных программах \CDSChecker работает существенно 
медленнее чем \wmc, и, в некоторых случаях 
(например, \bmark{fib\_bench} и \bmark{sigma}), 
даже превышает заданный лимит времени, в то время как 
\wmc укладывается в этот лимит.
Худшее время работы \CDSChecker объясняется тем, что 
данный инструмент вынужден тратить много времени 
на попытку сертификации неосуществимых обещаний. 
В то же время, свойство \LBRF, помогает \wmc 
рассматривать меньше потенциальных обещаний, 
а свойство \CL помогает быстро проверить 
сертифицируемость оставшихся обещаний.  

Заметим, что на тестовых программах из этого набора 
время работы \hmc также примерно в два раза больше времени работы \genmc, 
как и в случае данных из таблицы~\ref{tab:overhead}.
Это приводит к тому, что на некоторых тестовых программах 
(например, \bmark{sigma} и \bmark{indexer}) \wmc обгоняет \hmc.
Это вновь подтверждает гипотезу, что для программ, 
которые содержат мало гонок c буферизацией операций чтения, 
схема с запуском спекулятивного исполнения только в случае 
обнаружения этих гонок (\wmc) оказывается более эффективной, 
чем постоянное отслеживание синтаксических зависимостей между событиями (\hmc). 

Тем не менее, на программах \bmark{fib\_bench} и \bmark{peterson}
\wmc показывает худшее время по сравнению с \hmc.
Для \bmark{fib\_bench} проблема заключается в том, 
что \wmc вынужден тратить много времени 
на попытку сертификации неосуществимых обещаний, 
это проблема с которой также сталкивается \CDSChecker.
Что касается \bmark{peterson} то здесь проблема 
заключается в самой модели \WkmS --- для 
данной программы эта модель памяти просто допускает 
существенно большее количество слабых сценариев исполнения, 
чем модель \IMM, относительно которой выполняет верификацию \hmc. 

Результаты экспериментов, приведенные в таблице~\ref{tab:datastructures},
в целом подтверждают приведенные выше наблюдения. 
Время работы \CDSChecker на порядок больше времени 
работы других инструментов на всех тестовых программах, 
более того на 3 из 5 программ \CDSChecker не укладывается 
в заданный лимит времени. Время работы \hmc примерно в
два раза выше чем у \genmc~---~ замедление вызвано накладными расходами
на поддержание информации о синтаксических зависимостях между событиями.
На программах из этой группы \wmc вновь обходит \hmc, 
так как первые три программы из списка вообще не содержат 
гонок с буферизацией операций чтения, 
а две другие хоть и содержат гонки данного вида, 
обработка этих гонок все равно оказывается 
более эффективной, чем расходы на отслеживание синтаксических зависимостей.

\subsubsection*{Время работы \wmc на синтетических программах}

Далее проанализируем поведение инструмента \genmc
на синтетических программах (таблица~\ref{tab:lb}).

\wmc исследует одинаковое количество уникальных сценариев
исполнения для всех программ за исключением \bmark{LB+ctrl}.
В случае последней наличие зависимостей по управлению 
предотвращает появление большего количества слабых 
сценариев исполнения, содержащих $\lPORF$ циклы. 
За исключением программы \bmark{LB-pairs} 
количество повторяющихся и заблокированных сценариев исполнения 
остается очень маленьким. Однако для \bmark{LB-pairs}
количество повторяющихся сценариев исполнения 
в несколько раз превышает количество уникальных сценариев, 
а количество заблокированных сценариев составляет одну треть 
от количества уникальных. 
В подобных случаях \wmc может потребоваться 
сохранять информацию о всех исследованных сценариях исполнения, 
чтобы избежать необходимости их повторного посещения. 
Однако реализация данной стратегии приведет 
к кратному увеличению потребляемой памяти.  

\subsubsection*{Выводы}

Подводя итоги, можно сделать следующие выводы. 

В первую очередь отметим, что согласно результатам экспериментов,
гонки с буферизацией чтения действительно встречаются 
довольно редко в не синтетических многопоточных программах, 
и что затраты на их обнаружения не доминируют 
в суммарном времени работы инструмента.

Что касается сравнения с другими инструментами, 
то \wmc оказывается намного более эффективным, чем \CDSChecker~---~ 
единственный инструмент среди аналогов, который 
также выполняет верификацию в модели памяти, сохраняющей семантические зависимости.    
Вместе с тем на многих тестовых программах \wmc также опережает 
и другие инструменты (например, \hmc),
выполняющие верификацию в моделях памяти, 
сохраняющей синтаксические зависимости, даже 
несмотря на то, что этот класс моделей устроен более просто
и, как правило, допускает меньше возможных 
слабых сценариев исполнения чем модель \WkmS.
Это особенно заметно на программах, 
которые не содержат гонки с буферизацией операций чтения, 
либо содержат малое количество таких гонок. 
Это преимущество напрямую связано с реализованной в \wmc 
оптимизацией на основе свойства \LBRF --- 
для программ, свободных от буферизации операций чтения, 
\wmc не задействует механимз спекулятивного исполнения 
и выполняет исследование только \RCMM консистентных сценариев исполнения программы.

Кроме того отметим, что \wmc показывает худшую производительность 
по сравнению с другими инструментами на тех тестовых программах, 
которые практический не используют примитивы для синхронизации между потоками, 
такие как барьеры памяти или более сильные режимы доступа к атомарным переменным. 
К таким программам относится, например, тестовая программа \bmark{peterson}, 
реализующая алгоритм блокировки Петерсона. 
Подобные программы используют только ослабленные (relaxed)
режимы обращения к атомарным переменным.
Эта ситуация крайне нехарактерная для большинства 
практические значимых многопоточных программ, 
так как использование только ослабленных обращений к памяти
дает крайне мало гарантий о поведении программ. 
В остальных случаях \wmc показывает производительность 
лучшую по отношению к другим инструментам
и сравнимую с производительностью исходного инструмента~\genmc.

Наконец, на некоторых синтетических программах производительность \wmc 
может существенно ухудшится из-за необходимости исследовать 
избыточные дублирующиеся или заблокированные сценарии исполнения. 
Эта проблему можно частично решить путем сохранения информации
обо всех исследованных сценариях исполнения, увеличив таким образом   
количеством потребляемой инструментом оперативной памяти.
