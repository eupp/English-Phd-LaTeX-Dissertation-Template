\chapter{Верификация методом проверки модели для \WkmS}
\label{ch:mc-weakestmo2}

В данной главе описывается разработанный в рамках данной диссертации 
алгоритм проверки моделей \wmc для верификации 
многопоточных программ в модели \WkmS.
Предложенный алгоритм был внедрен в систему \genmc --- 
инструмент для автоматической верификации многопоточных программ, 
написанных на языке \CLANG, в модели памяти \RCMM. 
Таким образом предложенный алгоритм \wmc расширяет 
оригиальный алгоритм \genmc, добавляя в него 
поддержку модели памяти \WkmS.  

Алгоритм \wmc полагается на новые свойства модели \WkmS, 
а именно свободу от буферизации операций чтения и 
локальность сертификации, чтобы реализовать ключевые 
оптимизации и сделать верификацию в модели \WkmS возможной на практике.  
В рамках серии экспериментов показывается, что 
новый алгоритм \wmc обладает лучшей производительностью 
по сравнению с аналогами.

Данная глава организована следующим образом. 
В разделе \ref{sec:mc-wmm} дано краткое введение 
в задачу верификации методом проверки моделей 
в контексте слабых моделей памяти.
В разделе \ref{sec:genmc} описывается оригинальный алгоритм 
\genmc для модели памяти \RCMM.
В разделе \ref{sec:wmc} описывается разработанный в 
рамках данной диссертации алгоритм \wmc для модели памяти \WkmS.
Наконец, в разделе \ref{sec:wmc-eval} описаны эксперименты 
по измерению производительности алгоритма \wmc и его сравнению с аналогами.

\section{Метод проверки моделей для слабых моделей памяти}
\label{sec:mc-wmm}

Напомним, что \emph{метод проверки моделей} (\emph{model checking}) 
является одним из методов формальной автоматической верификации программ,
целью которого является проверка удовлетворяет ли 
модель программы заданной спецификации. 
\TODO{Упомянуть что рассматриваем только safety свойства.}

Метод проверки моделей с \emph{явным представлением состояний} 
(\emph{explicit-state model checking}) достигает 
этой цели путем явного построения пространства состояний программы 
и перечисления возможных сценариев ее исполнения.
Поскольку количество возможных сценариев исполнения 
растет экспоненциально с ростом программы, 
перечисление всех возможных сценариев исполнения 
на практике не предоставляется возможным. 
Для решения этой проблемы используются различные техники, 
призванные сократить пространство перебора. 

Одной из таких техник является 
\emph{редукция частичного порядка} (\emph{partial order reduction}). 
В основе этой техники лежит наблюдение, что 
порядок выполнения некоторых операций программы 
не имеет значения для конечного результата, 
то есть, данные операции коммутируют. 
Таким образом все сценарии исполнения можно разбить 
на классы эквивалентности, где каждый класс 
можно представить отношением частичного порядка, 
которое упорядочивает только те операции, которые не коммутируют. 
Тогда достаточно рассмотреть только один сценарий исполнения из каждого класса.   

В контексте слабых моделей памяти принято рассматривать 
$\lPORF$-эквивалентность сценариев исполнения%
~\cite{},
то есть эквивалентность с точностью до отношений $\lPO$ и $\lRF$ 
на соответствующих графах сценариев исполнения.
Иногда также рассматривается $\lPORFMO$-эквивалентность, 
то есть эквивалентность с точностью до отношений $\lPO$, $\lRF$ и $\lMO$. 
Таким образом задача проверки моделей в контексте 
слабых моделей памяти сводится к задаче перечисления 
консистентных графов сценариев исполнения заданной программы. 

\section{Алгоритм \genmc для модели \RCMM}
\label{sec:genmc}

Описание алгоритма \genmc. Пример работы алгоритма. 

\section{Алгоритм \wmc для модели \WkmS}
\label{sec:wmc}

Описание модифицированной версии алгоритма \genmc --- \wmc ---
для модели \WkmS. Пример работы алгоритма.
Обсуждение открытых проблем и заделов
для будущей работы в алгоритме. 

\section{Сравнение алгоритма \wmc с аналогами}
\label{sec:wmc-eval}

Для того чтобы оценить эффективность алгоритма \wmc были 
сформулированы следующие исследовательские вопросы:
\begin{enumerate}

  \item Как часто на практике встречаются гонки с буферизацией операций чтения
    и каковы накладные расходы на их обнаружение?
    Так как модель \WkmS, благодаря свойству \LBRF, присваивает 
    программам свободным от данного типа гонок только \RCMM консистентные сценарии исполнения, 
    это означает, что чем реже такие гонки встречаются на практике, 
    тем ближе производительность алгоритма \wmc 
    будет к производительности оригинального алгоритма \genmc.

  \item Насколько эффективен алгоритм \wmc по сравнению 
    с другими алгоритмами, которые также поддерживают 
    модели памяти, сохраняющие семантические зависимости. 

  \item Как изменяется производительность \wmc на синтетических программах, 
    содержащих множество гонок с буферизацией операций чтения. 
    
\end{enumerate}

В экспериментах будем сравнивать \wmc со следующими инструментами.

\begin{itemize}

  \item \genmc~\cite{Kokologiannakis:PLDI2019,Kokologiannakis:CAD2021} ---
    это инструмент проверки моделей, на основе которого был разработан \wmc. 
    \genmc поддерживает модель памяти \RCMM%
    \footnote{\genmc также может быть адаптирован для поддержки 
    произвольной модели памяти, сохраняющей программный порядок.}, 
    которая относится к классу моделей, сохраняющих программный порядок.  

  \item \hmc~\cite{Kokologiannakis-Vafeiadis:ASPLOS2020} --- 
    это расширение \genmc, поддерживающее модель памяти \IMM
    \footnote{\hmc также может быть адаптирован для поддержки 
    произвольной модели памяти, сохраняющей синтаксические зависимости.},
    которая относится к классу моделей, сохраняющих синтаксические зависимости.  
    Алгоритм, лежащий в основе \hmc, отслеживает синтаксические зависимости между событиями, 
    чтобы предотвратить появление циклов причинно-следственной связи. 

  \item \Nidhugg~\cite{Abdulla-al:TACAS2015,Abdulla-al:CAV2016} --- 
    это инструмент проверки моделей, который, среди прочих, 
    поддерживает модель памяти мультипроцессоров \POWER, 
    относящуюся к классу моделей, сохраняющих синтаксические зависимости.  
    Аналогично \hmc, данный инструмент отслеживает синтаксические зависимости между событиями.

%%   \item \rmem~\cite{RMEM} --- 
%%     это симулятор для выполнения многопоточных программ с учетом слабых сценариев исполнения. 
%%     Данный симулятор поддерживает множество моделей памяти различных мультипроцессоров. 
%%     В рамках данной работы в экспериментах используется режим \PrmARM%
%%     ~\cite{Pulte-al:PLDI2019}, так как данный режим является 
%%     наиболее эффективным в инструменте \rmem.
%%     Режим \PrmARM проводит верификацию в модели памяти \ARMv{8}, 
%%     которая относится к классу моделей, сохраняющих синтаксические зависимости. 
%%     При этом для моделирования спекулятивного выполнения инструкций 
%%     используется механизм обещаний~\cite{Kang-al:POPL17}.  

%%   \item \CDSChecker~\cite{Norris-Demsky:OOPSLA2013} --- 
%%     еще один инструмент проверки моделей, выполняющий верификацию 
%%     в неформально определенной модифицированной версии модели памяти \CMM.
%%     Данный инструмент также использует механизм обещаний~\cite{Kang-al:POPL17}, 
%%     чтобы моделировать спекулятивное исполнение и отслеживать
%%     семантические зависимости между событиями. 
%%     Таким образом, среди всех перечисленных инструментов,
%%     только \CDSChecker выполняет верификацию в модели памяти, 
%%     относящейся к классу моделей, сохраняющих семантические зависимости, 
%%     Следовательно, данный инструмент наиболее близок по функциональности к \wmc.

\end{itemize}

