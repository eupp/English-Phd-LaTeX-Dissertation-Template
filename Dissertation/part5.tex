\chapter{Верификация методом проверки модели для \WkmS}
\label{ch:mc-weakestmo2}

В данной главе описывается разработанный в рамках данной диссертации 
алгоритм проверки моделей \wmc для верификации 
многопоточных программ в модели \WkmS.
Предложенный алгоритм был внедрен в систему \genmc --- 
инструмент для автоматической верификации многопоточных программ, 
написанных на языке \CLANG, в модели памяти \RCMM. 
Таким образом предложенный алгоритм \wmc расширяет 
оригиальный алгоритм \genmc, добавляя в него 
поддержку модели памяти \WkmS.  

Алгоритм \wmc полагается на новые свойства модели \WkmS, 
а именно свободу от буферизации операций чтения и 
локальность сертификации, чтобы реализовать ключевые 
оптимизации и сделать верификацию в модели \WkmS возможной на практике.  
В рамках серии экспериментов показывается, что 
новый алгоритм \wmc обладает лучшей производительностью 
по сравнению с аналогами.

Данная глава организована следующим образом. 
В разделе \ref{sec:mc-wmm} дано краткое введение 
в задачу верификации методом проверки моделей 
в контексте слабых моделей памяти.
В разделе \ref{sec:genmc} описывается оригинальный алгоритм 
\genmc для модели памяти \RCMM.
В разделе \ref{sec:wmc} описывается разработанный в 
рамках данной диссертации алгоритм \wmc для модели памяти \WkmS.
Наконец, в разделе \ref{sec:wmc-eval} описаны эксперименты 
по измерению производительности алгоритма \wmc и его сравнению с аналогами.

\section{Метод проверки моделей для слабых моделей памяти}
\label{sec:mc-wmm}

Напомним, что \emph{метод проверки моделей} (\emph{model checking}) 
является одним из методов формальной автоматической верификации программ,
целью которого является проверка удовлетворяет ли 
модель программы заданной спецификации. 
\TODO{Упомянуть что рассматриваем только safety свойства.}

Метод проверки моделей с \emph{явным представлением состояний} 
(\emph{explicit-state model checking}) достигает 
этой цели путем явного построения пространства состояний программы 
и перечисления возможных сценариев ее исполнения.
Поскольку количество возможных сценариев исполнения 
растет экспоненциально с ростом программы, 
перечисление всех возможных сценариев исполнения 
на практике не предоставляется возможным. 
Для решения этой проблемы используются различные техники, 
призванные сократить пространство перебора. 

Одной из таких техник является 
\emph{редукция частичного порядка} (\emph{partial order reduction}). 
В основе этой техники лежит наблюдение, что 
порядок выполнения некоторых операций программы 
не имеет значения для конечного результата, 
то есть, данные операции коммутируют. 
Таким образом все сценарии исполнения можно разбить 
на классы эквивалентности, где каждый класс 
можно представить отношением частичного порядка, 
которое упорядочивает только те операции, которые не коммутируют. 
Тогда достаточно рассмотреть только один сценарий исполнения из каждого класса.   

В контексте слабых моделей памяти принято рассматривать 
$\lPORF$-эквивалентность сценариев исполнения%
~\cite{},
то есть эквивалентность с точностью до отношений $\lPO$ и $\lRF$ 
на соответствующих графах сценариев исполнения.
Иногда также рассматривается $\lPORFMO$-эквивалентность, 
то есть эквивалентность с точностью до отношений $\lPO$, $\lRF$ и $\lMO$. 
Таким образом задача проверки моделей в контексте 
слабых моделей памяти сводится к задаче перечисления 
консистентных графов сценариев исполнения заданной программы. 

\section{Алгоритм \genmc для модели \RCMM}
\label{sec:genmc}

Описание алгоритма \genmc. Пример работы алгоритма. 

\section{Алгоритм \wmc для модели \WkmS}
\label{sec:wmc}

Описание модифицированной версии алгоритма \genmc --- \wmc ---
для модели \WkmS. Пример работы алгоритма.
Обсуждение открытых проблем и заделов
для будущей работы в алгоритме. 

\section{Сравнение алгоритма \wmc с аналогами}
\label{sec:wmc-eval}

Для того чтобы оценить эффективность алгоритма \wmc были 
сформулированы следующие исследовательские вопросы:
\begin{enumerate}

  \item Как часто на практике встречаются гонки с буферизацией операций чтения
    и каковы накладные расходы на их обнаружение?
    Так как модель \WkmS, благодаря свойству \LBRF, присваивает 
    программам свободным от данного типа гонок только \RCMM консистентные сценарии исполнения, 
    это означает, что чем реже такие гонки встречаются на практике, 
    тем ближе производительность алгоритма \wmc 
    будет к производительности оригинального алгоритма \genmc.

  \item Насколько эффективен алгоритм \wmc по сравнению 
    с другими алгоритмами, которые также поддерживают 
    модели памяти, сохраняющие семантические зависимости. 

  \item Как изменяется производительность \wmc на синтетических программах, 
    содержащих множество гонок с буферизацией операций чтения. 
    
\end{enumerate}

\paragraph{Инструменты проверки моделей.}

В экспериментах будем сравнивать \wmc со следующими инструментами.

\begin{itemize}

  \item \genmc~\cite{Kokologiannakis:PLDI2019,Kokologiannakis:CAD2021} ---
    это инструмент проверки моделей, на основе которого был разработан \wmc. 
    \genmc поддерживает модель памяти \RCMM%
    \footnote{\genmc также может быть адаптирован для поддержки 
    произвольной модели памяти, сохраняющей программный порядок.}, 
    которая относится к классу моделей, сохраняющих программный порядок.  

  \item \hmc~\cite{Kokologiannakis-Vafeiadis:ASPLOS2020} --- 
    это расширение \genmc, поддерживающее модель памяти \IMM
    \footnote{\hmc также может быть адаптирован для поддержки 
    произвольной модели памяти, сохраняющей синтаксические зависимости.},
    которая относится к классу моделей, сохраняющих синтаксические зависимости.  
    Алгоритм, лежащий в основе \hmc, отслеживает синтаксические зависимости между событиями, 
    чтобы предотвратить появление циклов причинно-следственной связи. 

  \item \Nidhugg~\cite{Abdulla-al:TACAS2015,Abdulla-al:CAV2016} --- 
    это инструмент проверки моделей, который, среди прочих, 
    поддерживает модель памяти мультипроцессоров \POWER, 
    относящуюся к классу моделей, сохраняющих синтаксические зависимости.  
    Аналогично \hmc, данный инструмент отслеживает синтаксические зависимости между событиями.

  \item \rmem~\cite{RMEM} --- 
    это симулятор для выполнения многопоточных программ с учетом слабых сценариев исполнения. 
    Данный симулятор поддерживает множество моделей памяти различных мультипроцессоров. 
    В рамках данной работы в экспериментах используется режим \PrmARM%
    ~\cite{Pulte-al:PLDI2019}, так как данный режим является 
    наиболее эффективным в инструменте \rmem.
    Режим \PrmARM проводит верификацию в модели памяти \ARMv{8}, 
    которая относится к классу моделей, сохраняющих синтаксические зависимости. 
    При этом для моделирования спекулятивного выполнения инструкций 
    используется механизм обещаний~\cite{Kang-al:POPL17}.  

  \item \CDSChecker~\cite{Norris-Demsky:OOPSLA2013} --- 
    еще один инструмент проверки моделей, выполняющий верификацию 
    в неформально определенной модифицированной версии модели памяти \CMM.
    Данный инструмент также использует механизм обещаний~\cite{Kang-al:POPL17}, 
    чтобы моделировать спекулятивное исполнение и отслеживать
    семантические зависимости между событиями. 
    Таким образом, среди всех перечисленных инструментов,
    только \CDSChecker выполняет верификацию в модели памяти, 
    относящейся к классу моделей, сохраняющих семантические зависимости, 
    Следовательно, данный инструмент наиболее близок по функциональности к \wmc.

\end{itemize}

\paragraph{Конфигурация системы.} 
\TODO{}

\subsection*{Оценка частоты появления гонок с буферизацией операции чтения}

Для того, чтобы оценить как часто в реалистичных многопоточных
программах встречаются гонки с буферизацией операции чтения
и насколько затратно алгоритму \wmc их обнаружить 
был поставлен следующий эксперимент.
%% было поставлено два эксперимента. 

%% В рамках первого эксперимента были рассмотрены 
%% реализации 13 алгоритмов блокировки из работы%
%% ~\cite{oberhauser2021:vsync},
%% 5 реализаций многопоточной очереди из работы%
%% ~\cite{Kokologiannakis:PLDI2019}
%% и 10 реализаций многопоточных структур данных из работы%
%% \footnote{Были рассмотрены только 10 из 43 
%% тестовых программ из данной работы, 
%% так как эти программы были написаны на языке C++,
%% а \genmc поддерживает язык C и только подмножество возможностей языка C++}. 
%% ~\cite{Ou-Demsky:OOPSLA18}.
%% Running \wmc on these benchmarks confirmed our expectation that
%% realistic implementations rarely contain LB races: out of 18
%% implementations, we found LB races only in 2. One of them was due to
%% the porting of a non-C11-compliant queue to C11, while the
%% other was an intentional race part of a lock implementation
%% (\bmark{musl\_lock}), that could not lead to LB behaviors.

Была рассмотрена 241 многопоточная программа 
из набора тестовых программ инструмента \genmc, 
который включает как небольшие ``лакмусовые тесты''~\cite{Alglave-al:TACAS2011}, 
так и реализации различных многопоточных структур данных.
Данный набор программ был разбит на две группы:
те программы, которые содержат гонки с буферизацией чтения (28 программ)
и те, которые не содержат гонок данного типа (213 программ).
Далее было замерено время работы алгоритмов \genmc, \hmc и \wmc на данных программах.  
Результаты замеров представлены в таблице~\ref{tab:overhead}.

\input{Dissertation/table/overhead}

Как можно видеть по второй строке таблицы, 
процесс обнаружения гонок с буферизацией операций чтения 
в алгоритме \wmc приводит к накладным расходам на время работы 
примерно в 25\% процентов по сравнению с временем работы \genmc.
Тем не менее, эти накладные расходы существенно ниже чем 
расходы на поддержание информации о синтаксических зависимостях
в алгоритме \hmc. Можно видеть, что на программах из обоих групп
время работы \wmc существенно меньше времени работы \hmc. 

По результатам этих экспериментов можно сделать вывод, 
что гонки с буферизацией чтения действительно встречаются 
довольно редко в несинтетических многопоточных программах, 
и что затраты на их обнаружения не приводят к существенному
замедлению алгоритма. Более того, схема с 
запуском спекулятивного исполнения только в случае 
обнаружения гонок с буферизацией чтения (\wmc) 
оказывается более эффективной, чем постоянное отслеживание 
синтаксических зависимостей между событиями (\hmc). 


%% As far as \wmc is concerned, detecting LB races imposes roughly 25\% overhead
%% over \genmc, which is substantially lower than the overhead of calculating
%% dependencies in \hmc, especially when no LB races are present.

%% As far as \hmclbf is concerned, observe that \hmclbf significantly improves the
%% running time of \hmc on benchmarks without LB races,
%% as it effectively runs \wmc, and imposes a negligible overhead with respect to
%% \hmc on benchmarks with LB races.  The reason for the latter that it typically detects LB races
%% very quickly, in a fraction of the time needed for verifying the program.

%% In addition, also observe that \hmclbf performs really close to \genmc and \wmc in benchmarks
%% without LB races. The reason for the additional slowdown compared to \genmc and
%% \wmc is that \hmclbf has to maintain some extra data structures which will
%% be necessary if it has to fall back to dependency tracking.

