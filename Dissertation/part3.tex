\chapter{Модель \Wkm и корректность компиляции}
\label{ch:weakestmo-imm}

Напомним, что модель \Wkm принадлежит классу моделей,
сохраняющих семантические зависимости.
Как уже упоминалось, одним из требований, предъявляемых к таким моделям,
является корректность оптимальной схемы компиляции
в ассемблерный код современных мультипроцессоров,
в частности \Intel~\cite{Sewell-al:CACM10},
\ARM~\cite{Pulte-al:POPL18} и \POWER~\cite{Alglave-al:TOPLAS14}.

В данной главе описывается выполненное в рамках
диссертационного исследования доказательство
о корректности компиляции из модели \Wkm в модели
современных мультипроцессоров.
Данное доказательство вместе с определением модели \Wkm
были формализованы в системе \coq.
Репозиторий с исходным кодом данной формализации
может быть найден здесь~%
\cite{Coq:Weakestmo}.
Далее в данном главе описываются основные идеи данного доказательства.

В предложенном доказательстве используется \emph{промежуточная модель памяти}
(\emph{intermediate memory model, \IMM})~\cite{Podkopaev-al:POPL19}.
Данная модель является абстракцией над моделями \Intel, \ARM и \POWER,
которая позволяет скрыть низкоуровневые детали этих моделей.
Так как для модели \IMM ранее уже была доказана
корректность компиляции в модели \Intel, \ARM и \POWER~\cite{Podkopaev-al:POPL19}, 
то задача сводится к доказательству корректности компиляции из модели \Wkm в модель \IMM. 

Будем считать, что модель \Wkm и модель \IMM заданы для языка \LLANG,
а оптимальной схемой компиляции положим
тождественное отображение из языка \LLANG в него же.
Тогда требование о корректности компиляции
из модели \Wkm в модель \IMM сводится к следующей теореме. 

\begin{theorem}
  \label{thm:main}
  Пусть $P$ --- это программа на языке \LLANG
  и пусть $G$ --- это \IMM-консистентный граф сценария исполнения этой программы.
  Тогда существует \Wkm-консистентная структура событий $S$,
  соответствующая программе $P$, которая содержит граф $G$, 
  то есть верно, что $S \rhd G$.
\end{theorem}


\section{Схема доказательства теоремы о корректности компиляции}

\eupp{В этом разделе необходимо переформулировать предложения,
  чтобы избежать плагиата с ВКР.}

Для того чтобы доказать теорему о корректности компиляции
в данной работе был предложен способ построения
необходимой структуры событий с помощью метода
\emph{симуляции}~\cite{Milner:1971}.
А именно, построение структуры событий происходит
инкрементально шаг за шагом с помощью операционной семантики
%% (\todo{ссылка на раздел про оп.сем.})
путем симуляции \emph{обхода \IMM графа}
(\emph{\IMM graph traversal})~\cite[\S6,7]{Podkopaev-al:POPL19}.
Обход графа соответствует некоторому сценарию выполнения программы,
в рамках которого события исполняются согласно
сохраняемому программному порядку ($\lPPO$).

Более формально, обход графа $G$
порождает операционную семантику малого шага 
$G \vdash \TC \travstep{e} \TC'$ где $\TC$ и $\TC'$ --- это
\emph{конфигурации обхода}.
Конфигурация обхода --- это пара $\tup{C, I}$,
где $C \suq G.\lE$ --- это множество \emph{покрытых событий}
(\emph{covered events}), а $I \suq G.\lW$ --- это множество
\emph{выпущенных записей} (\emph{issued writes}).
Покрытие события соответствует выполнению
инструкции программы в обычном порядке,
в то время как выпуск события записи соответствует
спекулятивному исполнению инструкции записи вне очереди.
Событие может быть покрыто если (i) все его
$\lPO$ предшественники уже покрыты, и (ii)
это событие уже выпущено (в случае события записи)
либо оно читает из уже выпущенной записи (в случае события чтения).
Событие записи может быть выпущено если все
события записи из других потоков, от которых
зависит данное событие согласно отношению $\lPPO$, также уже выпущены. 
Эти требования могут быть выражены как следующие инварианты конфигурации обхода.

\[\def\arraystretch{1}
\begin{array}{c@{\qquad}c@{\qquad}c@{\qquad}c}
 \dom{\lPO \seqc [C]} \subseteq C  &
 C \cap \lW \subseteq I             &
 \dom{\lRF \seqc [C]} \subseteq I  &
 \dom{\lRFE \seqc \lPPO \seqc [I]} \subseteq I
\end{array}
\]

Имея операционную семантику обхода \IMM графа $G \vdash \TC \travstep{e} \TC'$
и операционную семантику построения структуры событий $S \esstepcons{e} S'$
доказательство строится на основе метода \emph{симуляции}~\cite{Milner:1971}.
А именно, определяется отношение симуляции $\simrel(P, T, G, \TC, S, X)$,
соединяющее программу $P$, подмножество идентификаторов потоков $T \suq \Tid$,
\IMM граф $G$ и текущую конфигурацию его обхода $\TC$,
текущую структуру событий $S$ и его выделенную конфигурацию $X$.
Далее доказательство строится на следующих трех леммах,
которые утверждают что 
(i) начальная конфигурация обхода и инициализирующая структура событий
связаны отношением симуляции, (ii) каждый шаг обхода графа
может быть симулирован соответствующим шагом построения структуры событий,
(iii) из конечной структуры событий, которая соответствует конечной
конфигурации обхода, может быть извлечен требуемый \IMM граф $G$.

\begin{lemma}[Начало симуляции]
  \label{lm:simstart}
  \quad\\
  Пусть $P$ --- это программа на языке \LLANG,
  а $G$ --- это соответствующий ей \IMM консистентный граф.
  Тогда выполняется $\simrel(P, \lTID(P), G, \TCinit{G}, \ESinit(P), \lEi)$, 
  где $\lTID(P)$, $\TCinit{G}$ и $\ESinit(P)$ заданы следующим образом:
  \begin{itemize}
    \item $\lTID(P)$ --- множество всех идентификаторов потоков программы~$P$;
    \item $\TCinit{G} \defeq \tup{\lEi, \lEi}$ --- это начальная конфигурация обхода,
      содержащая только инициализирующие события;
    \item $\ESinit(P)$ --- это начальная структура событий,
      также содержащая только инициализирующие события.
  \end{itemize}
\end{lemma}

\begin{lemma}[Шаг симуляции]
  \label{lm:simstep}
  \quad\\
  Если выполняется $\simrel(P, T, G, \TC, S, X)$ и ${G \vdash \TC \travstep{} \TC'}$,
  тогда существует $S'$ и $X'$, такие что выполняется
  $\simrel(P, T, G, \TC', S', X')$ и $S \esstepcons{}^* S'$.
\end{lemma}

\begin{lemma}[Окончание симуляции]
  \label{lm:simend}
  \quad\\
  Если выполняется $\simrel(P, \lTID(P), G, \TCfinal{G}, S, X)$,
  где $\TCfinal{G} \defeq \tup{G.\lE, G.\lE}$ --- это конечная
  конфигурация обхода графа, тогда граф сценария исполнения,
  порождаемый конфигурацией $X$, изоморфен $G$,
  или, другими словами, $G$ может быть извлечен из $S$:~~$S \rhd G$.
\end{lemma}

Доказательство теоремы \ref{thm:main}
проводится методом индукции по трассе обхода графа
$G \vdash \TCinit{G} \travstep{}^* \TCfinal{G}$.
Лемма \ref{lm:simstart} используется в качестве базы индукции,
лемма \ref{lm:simstep} --- это шаг индукции,
а лемма \ref{lm:simend} завершает доказательство.

В свою очередь, доказательства лемм \ref{lm:simstart} и \ref{lm:simend}
достаточно прямолинейны (найти их можно в \coq репозитории).
Основная сложность заключена в доказательстве леммы \ref{lm:simstep}.
Более детально это доказательство рассматривается~в~разделе~\ref{sec:simstep}.

\section{Модель \IMM и обход графа сценария исполнения}

В этом разделе приводится формальное 
определение модели памяти \IMM~\cite{Podkopaev-al:POPL19},
а также операционной семантики обхода графов 
сценариев исполнения в модели~\IMM.

\subsection*{Модель \IMM}

Модель \IMM относится к классу моделей, сохраняющих синтаксические зависимости. 
%% В рамках данных моделей, как правило, 
%% определяется отношение \emph{сохраняемого программного порядка}
%% (\emph{preserved program order}) $\lPPO$, 
%% являющееся подмножеством обычного программного порядка. 
%% События, связанные сохраняемым программным порядком, 
%% должны выполнятся согласно этому порядку, 
%% а несвязанные события могут выполняться в произвольном порядке. 
 
%% Рассмотрим программы \ref{ex:LB-nodep}, 
%% \ref{ex:LB-fakedep} и \ref{ex:LB-dep} показанные ниже.

%% \input{Dissertation/fig/lb-progs}

\eupp{В этом разделе далее необходимо переформулировать предложения,
  чтобы избежать плагиата с ВКР.}

%% Модель \IMM допускает сценарий исполнений 
%% с результатом $a=b=1$ для программы \ref{ex:LB-nodep}, 
%% но не для \ref{ex:LB-fakedep} и \ref{ex:LB-dep}.
%% Соответствующий этому сценарию граф для 
%% программы \ref{ex:LB-nodep} показан на~\ref{fig:LB-nodep-ppo-exec},
%% а для для \ref{ex:LB-fakedep} и \ref{ex:LB-dep} на~\ref{fig:LB-dep-ppo-exec}.
%% Заметим, что в графе, показанном на~\ref{fig:LB-nodep-ppo-exec}, 
%% события в левом потоке не связаны отношением $\lPPO$.
%% В графе, показанном на~~\ref{fig:LB-nodep-ppo-exec}, напротив, 
%% события в обоих потоках связанны отношением $\lPPO$,
%% так как между соответствющими инструкциями 
%% есть \emph{зависимость по данным}.
%% Кроме того, объединение отношений $\lPPO$ и $\lRFE$ образует цикл. 
%% Именно из-за наличия этого цикла данный 
%% граф считается неконсистентным с точки зрения модели~\IMM.

%% \input{Dissertation/fig/lb-execs}

Далее приводится модели \IMM.

\begin{definition}
  \label{def:imm-aux-rel}
  В модели \IMM для графа $G$ вводятся следующием производные отношения%
  \footnote{Подробное описание приведенных здесь отношений может 
   быть найдено в~\cite{Podkopaev-al:POPL19,Moiseenko-al:ECOOP20}}.

  \begin{itemize}

    \item Отношение \emph{порядка барьеров} (\emph{barrier-order-before}):
      $$ \lBOB \defeq \lPO \seqc [\lW^{\rel\squq}] \cup 
                      [\lR^{\acq\squq}] \seqc \lPO \cup 
                      \lPO \seqc [\lF] \cup [\lF] \seqc \lPO \cup 
                      [\lW^{\rel\squq}] \seqc \lPO_{\lLOC} \seqc [\lW]. $$

    \item Отношение \emph{сохраняемого программного порядка} 
      (\emph{preserved program order}):
      $$ \lPPO \defeq [\lR] \seqc (\lDEPS \cup \lRFI)^+ \seqc [W] $$

    \item Отношение \emph{обхода} (\emph{detour}):
      $$ \lDETOUR \defeq (\lCOE \seqc \lRFE) \cap \lPO. $$

    \item Отношение \emph{синхронизируется-с} (\emph{synchronizes-with}):
     $$ \lSW  \defeq [\lE^{\rel\squq}]             \seqc 
                     ([\lF] \seqc \lPO)^?           \seqc 
                     ([\lW] \seqc \lPO_{\lLOC})^?   \seqc
                     (\lRF \seqc \lRMW)^*           \seqc 
                     \lRF \seqc (\lPO \seqc [\lF])^? \seqc 
                     [\lE^{\acq\squq}]. 
     $$

    \item Отношение \emph{произошло-до} (\emph{happens-before}):
      $$ \lHB \defeq (\lPO \cup \lSW)^+. $$

    \item Отношение \emph{читает-до} (\emph{reads-before} или \emph{from-reads}):
      $$ \lFR \defeq \lRF^{-1} \seqc \lCO. $$

    \item \emph{Расширенный порядок когерентности} 
      (\emph{extended coherence order}):
      $$ \lECO \defeq (\lCO \cup \lRF \cup \lFR)^+. $$

    \item Отношение \emph{последовательно-упорядочен-до}
      (\emph{sequentially consistent before}):
      $$ \lSCB \defeq \lPO \cup
                      \lPO\rst{\neq \lLOC} \seqc \lHB \seqc 
                      \lPO\rst{\neq \lLOC} \cup
                      \lHB\rst{\lLOC} \cup
                      \lCO \cup \lFR. $$

    \item Частиный порядок \emph{базовой последовательной упорядоченности}:
      $$ \lPSCB \defeq ([\lE^\sco] \cup [\lF^\sco] \seqc \lHB^?) \seqc 
                         \lSCB \seqc 
                       ([\lE^\sco] \cup \lHB^?\seqc[\lF^\sco]). 
      $$ 

    \item Частиный порядок \emph{последовательной упорядоченности барьеров}:
      $$ \lPSCF \defeq [\lF^\sco] \seqc 
                       (\lHB \cup \lHB \seqc \lECO \seqc \lHB) \seqc 
                       [\lF^\sco]. 
      $$ 

    \item Частиный порядок \emph{последовательной упорядоченности}:
      $$ \lPSC \defeq \lPSCB \cup \lPSCF. $$ 

    \item Вспомогательное \emph{ацикличное} отношение (\emph{acyclic relation}):
      $$ \lAR \defeq \lRFE \cup \lBOB \cup \lPPO \cup \lDETOUR \cup \lPSCF. $$
    
  \end{itemize}

\end{definition}

\begin{definition}
  \label{def:imm-cons}
  Граф $G$ является консистентным с точки зрения \IMM 
  если выполняются следующие условия:
  
  \begin{itemize}

    \item $\lR \suq \cod{\lRF}$;
      \labelAxiom{$\lRF$-completeness}{ax:rf-complete}

    \item $\lAR$ ациклично;
      \labelAxiom{imm-no-thin-air}{ax:imm-noota}

    \item $\lHB_{\IMM} \seqc \lECO^?$ иррефлексивно;
      \labelAxiom{imm-coherent}{ax:imm-coh}

    \item $\lRMW \cap (\lFR \seqc \lCO) = \emptyset$;
      \labelAxiom{rmw-atomic}{ax:imm-atom}

    \item $\lPSC$ ациклично.
      \labelAxiom{imm-sequential-consistency}{ax:imm-sc}

  \end{itemize}
\end{definition}

\TODO{Семантика обхода графа}

\section{Симуляция обхода графа \IMM}

\eupp{В этом разделе необходимо переформулировать предложения,
  чтобы избежать плагиата с ВКР.}

В данном разделе приводится более подробный обзор
процесса симуляции построения структуры событий по обходу \IMM графа.
В разделе \ref{sec:simrel} описывается
отношение симуляции $\simrel$, 
а в разделе \ref{sec:simstep} на примере графа, 
изображенного на рисунке~\ref{fig:lb-sim-ex},
рассматривается процесс симуляции шага обхода \IMM графа
семантикой построения структуры событий. 

\input{Dissertation/fig/lb-sim-ex}

\subsection*{Отношение симуляции}
\label{sec:simrel}

Далее опишем отношение симуляции $\simrel$.
В целях ясности и простоты изложения, 
в данном разделе будет приведена упрощенная версия формального
определения этого отношения, которая опускает некоторые
технические детали. Полная версия отношения симуляции
может быть найдена в \coq репозитории. 

Отношение симуляции $\simrel(P, T, G, TC, S, X)$
устанавливает взаимосвязь между структурой событий $S$
и графом сценария исполнения $G$ с помощью
функции $\ea : S.\lE \fun G.\lE$, которая отображает
события структуры $S$ в события графа $G$.
Эта функция может быть натуральным образом
расширена на множества событий следующим образом%
\footnote{аналогично образом функций $\ea$ может быть расширена
на бинарные отношения на событиях.}:

\begin{align*}
\text{for } A_S \subseteq S.\lE        & :
  \fmap{A_S} \defeq \set{\ea(e) \in G.\lE \mid e \in A_S} \\
\text{for } A_G \subseteq G.\lE        & :
  \fcomap{A_G} \defeq \set{e \in S.\lE \mid \ea(e) \in A_G}.
\end{align*}

Отношение симуляции $\simrel(P, T, G, \TC, S, X)$ состоит из следующих свойств.

\begin{enumerate}

  \item \label{simrel:events}
    События $S$, принадлежащие потокам из $T$, а также события,
    принадлежащие конфигурации $X$, соответствуют покрытым событиям,
    а также выпущенным событиям и их $\lPO$-предшественникам: 
    \begin{itemize}
      \item $\fmap{S.\lE\rst{T}} = \fmap{X} = C \cup \dom{G.\lPO^? \seqc [I]}$
    \end{itemize}

  \item \label{simrel:lab}
    Метки событий из $S$ совпадают с метками событий из $G$
    по модулю прочитанных или записанных значений. 
    \begin{enumerate}
      \setcounter{enumii}{0}
      \item \label{simrel:lab-eqmval}
        $\forall e \in S.\lE \ldotp\;
          S.\set{\lTID, \lTYP, \lLOC, \lMOD}(e) =
          G.\set{\lTID, \lTYP, \lLOC, \lMOD}(\fmap{e}) $
    \end{enumerate}
    Метки покрытых и выпущенных событий, принадлежащих конфигурации $X$,
    сопадают полностью.
    \begin{enumerate}
      \setcounter{enumii}{1}
      \item \label{simrel:lab-det}
        $\forall e \in X \cap \fcomap{C \cup I} \ldotp~
          S.\lVAL(e) = G.\lVAL(\ea(e))$
    \end{enumerate}

  \item \label{simrel:po}
    Программный порядок в структуре событий $S$
    совпадает с программным порядком в графе $G$:
    \begin{itemize}
      \item $\fmap{S.\lPO} \suq G.\lPO$
    \end{itemize}

  \item \label{simrel:cf}
    Если два события имеют одинаковый образ под действием функции $\ea$,
    то эти события равны или находятся в конфликте.
    \begin{itemize}
      \item $\fcomap{\mathtt{id}} \suq S.\lCF^?$
    \end{itemize}

  \item \label{simrel:jf}
    События чтения в $S$ должны быть обоснованы событиями записи,
    которые наблюдаются соответствующим событием чтением в $G$.
    \begin{enumerate}
      \item \label{simrel:jf-obs}
      \setcounter{enumii}{0}
        $\fmap{S.\lJF} \suq G.\lRF^?\seqc G.\lHB^?$
    \end{enumerate}
    Более того, отношение $\lJF$, ограниченное на события чтения,
    принадлежащие конфигурации $X$, соответствуют
    отношению \emph{стабильной обоснованности} (\emph{stable justification})
    (смотри определение~\ref{def:sjf}) в графе $G$.
    \begin{enumerate}
      \setcounter{enumii}{1}
      \item \label{simrel:jf-sjf}
        $\fmap{S.\lJF \seqc [X]} \suq G.\lSRF_{TC}$
    \end{enumerate}
    %% As a consequence it is possible to derive that
    %% justification for covered events in $X$
    %% corresponds to their justification in $G$:
    %% $\fmap{S.\lJF \seqc [X \cap \fcomap{C}]} \subseteq G.\lRF$. \\
    Только выпущенные события могут быть использованы для
    внешнего обоснования событий чтения. 
    \begin{enumerate}
      \setcounter{enumii}{2}
      \item \label{simrel:jfe-iss}
         $\dom{S.\lJFE} \suq \dom{S.\lEW \seqc [X \cap \fcomap{I}]}$
    \end{enumerate}

  \item \label{simrel:ew}
    Все эквивалентные события записи в $S$ отображаются
    в одно и то же событие записи $G$.
    \begin{enumerate}
      \setcounter{enumii}{0}
      \item \label{simrel:ew-id}
        $\fmap{S.\lEW} \suq \mathtt{id}$
    \end{enumerate}
    Также каждый класс эквивалентности по отношению $S.\lEW^*$
    должен иметь представителя среди выпущенных событий,
    принадлежащих конфигурации $X$.
    \begin{enumerate}
      \setcounter{enumii}{1}
      \item \label{simrel:ew-iss}
        $S.\lEW \suq (S.\lEW \seqc [X \cap \fcomap{I}] \seqc S.\lEW)^?$
    \end{enumerate}

  \item \label{simrel:co}
    Если два события структуры $S$ находящихся в отношении когерентности,
    то их образы под действием функции либо также находятся
    в отношении когерентности, либо равны. 
    \begin{enumerate}
      \setcounter{enumii}{0}
      \item \label{simrel:co-co}
         $\fmap{S.\lCO} \suq G.\lCO^?$
    \end{enumerate}
    Если же ребро отношения когерентности оканчивается
    в событии, принадлежащем конфигурации $X$ и одному из потоков из $T$,
    тогда образ этого ребра принадлежит отношению когерентности в графе $G$.
    \begin{enumerate}
      \setcounter{enumii}{1}
      \item \label{simrel:co-cfg}
         $\fmap{S.\lCO \seqc [X\rst{T}]} \suq G.\lCO$
    \end{enumerate}

  \item \label{simrel:sw-hb}
    Отношения ``синхронизируется-с'' и ``происходит-до''
    в структуре событий $S$ согласованы с соответствующими
    отношениями в графе $G$.
    \begin{enumerate}
      \item \label{simrel:sw}
        $\fmap{S.\lSW} \suq G.\lSW$
      \item \label{simrel:hb}
        $\fmap{S.\lHB} \suq G.\lHB$
    \end{enumerate}
\end{enumerate}

\input{Dissertation/fig/lb-sim-ex-travA}

\TODO{пример}

\subsection*{Шаг симуляции}
\label{sec:simstep}

В данном разделе приводится схема доказательства леммы \ref{lm:simstep}.
А именно, будет показано каким образом
операционная семантика построения структуры событий
симулирует шаг обхода графа \IMM.

Предположим, что для некоторых $P$, $G$, $\TC$, $S$ и $X$
выполняется отношение симуляции $\simrel(P, G, \TC, S, X)$.
Также положим, что в рамках обхода выполняется шаг
$G \vdash \TC \travstep{} \TC'$, который покрывает
или выпускает событие из потока с идентификатором $t$.
По условиям леммы \ref{lm:simstep} требуется предъявить
структуру $S'$ и конфигурацию $X'$,
такие что выполняется $\simrel(P, G, \TC', S', X')$.
Если поток $t$ содержит ещё непокрытые, но уже
выпущенные события записи, то необходимо выполнить
несколько шагов для построения из структуры $S$ структуры $S'$
чтобы добавить все события, $\lPO$-предшествующие непокрытым
событиям записи в потоке $t$.
Будем называть множество этих событий
\emph{сертификационной веткой},
а процесс добавление этих событий --- \emph{сертификацией}.

\input{Dissertation/fig/lb-sim-ex-travB}

Рассмотрим процесс построения сертификационной ветки
на примере шага обхода из конфигурации $\TC_a$ 
(рисунок~\ref{fig:lb-sim-ex-travA})
в конфигурацию $\TC_b$ 
(рисунок~\ref{fig:lb-sim-ex-travB})
путем выпуска события $\ese{2}{3}{}$.
Чтобы симулировать этот шаг, необходимо выполнить инструкции правого потока
и добавить в структуру событий ветку
$\Br_b = \set{\ese{2}{1}{1},\ese{2}{2}{1},\ese{2}{3}{1}}$
(рисунок~\ref{fig:lb-sim-ex-travB}).
Для того чтобы добавить эти события, в свою очередь,
выполняется построение трассы операционной семантики потока
${\state \thrdstep{\ese{2}{1}{1}}
         \thrdstep{\ese{2}{2}{1}}
         \thrdstep{\ese{2}{3}{1}}
         \state'}$, 
такой что
(i) она содержит все события правого потока
вплоть до последнего выпущенного события записи $\ese{2}{3}{}$ в графе $G$,
(ii) все эти события должны иметь тот же идентификатор потока,
тип обращения и локацию как и соответствующие события в графе
(то есть $\ese{2}{1}{}, \ese{2}{2}{}, \ese{2}{3}{}$),
(iii) все события, соответствующие покрытым и выпущенным событиям
(в данном случае~$\ese{2}{3}{1}$) должны иметь то же значение,
что и в графе $G$.
Для построения этой трассы используется свойство
\emph{восприимчивости} (\emph{receptiveness})
операционной семантики потока.
Это свойство позволяет выбрать произвольные значения
для всех промежуточных событий чтения в конструируемой трассе,
от которых не зависят (согласно отношению $\lDEPS$) выпущенные события записи%
\footnote{Формальное определение восприимчивости опущено
в данной работе для краткости и может быть найдено в \coq репозитории,
сопровождающем работу~\cite{Podkopaev-al:POPL19}.}.

Помимо этого, при добавлении новой ветки $\Br_b$ в структуру событий
необходимо выполнить следующие требования.
\begin{itemize}
  \item Для каждого события чтения (в данном случае $\ese{2}{1}{1}$ и $\ese{2}{2}{1}$)
    необходимо выбрать событие запись, обосновывающее это чтение.  
  \item Для каждого события записи необходимо определить позицию
    этого события в отношении частичного порядка $\lCO$.
\end{itemize}
Наконец, после завершения процесса сертификации,
новая ветка заменяет собой ветку потока $t$ в конфигурации $X$:
$$ X_b \defeq X_a \setminus S.\lE\rst{t} \cup \Br_b $$
где $S.\lE\rst{t} \defeq \set{e \in S.\lE \sth S.\lTID(e) = t}$.

\paragraph{Обоснование событий чтения.}

Далее рассмотрим процесс выбора обосновывающего события записи
для добавляемого события чтения.
Для этой цели определим отношение \emph{стабильной обоснованности}
в несколько этапов. 

Сначала по графу $G$ и текущей конфигурации обхода $\tup{C, I}$
зададим множество \emph{зафиксированных} (\emph{determined}) событий.
Метки зафиксированных событий а также события записи,
обосновывающие зафиксированные чтения, должны
совпадать в графе $G$, текущей структуре событий $S$,
а также в конструируемой сертификационной ветке $\Br$.

\begin{definition}
\label{def:det}
Множество \emph{зафиксированных событий}
определяется следующим соотношением.
\begin{align*}
  G.D_{\tup{C, I}} &\defeq {}
           C \cup I {}\cup{} \\
     %% &\cup G.\lW \setminus \codom{G.\lPPO} {}\cup{} \\
     &\cup \dom{G.\lRFI^? \seqc G.\lPPO \seqc [I]} {}\cup{} \\
     &\cup \cod{[I] \seqc G.\lRFI} {}\cup{} \\
     &\cup \cod{G.\lRFE \seqc [G.\lE^{\squq\acq}]}
\end{align*}
\end{definition}

Помимо покрытых и выпущенных событий
в множество зафиксированных событий также входят
все $\lPPO$-предшественники выпущенных событий,
все события чтения, читающие локально из некоторого выпущенного события,
а также события захватывающего ($\acq$) чтения,
читающие из другого потока. 

Для графа $G$ и конфигурации обхода $\TC_b$,
показанных на рисунке~\ref{fig:lb-sim-ex-travB},
множество зафиксированных событий 
состоит из событий $\ese{1}{3}{}$, $\ese{2}{2}{}$ и $\ese{2}{3}{}$.
В то же время события $\ese{1}{1}{}$, $\ese{1}{2}{}$ и $\ese{2}{1}{}$
не являются зафиксированными, и следовательно
метки соответствующих им событий в структуре $S_b$
могут отличаться от меток в графе $G$.

Далее, введем понятие \emph{фронта} с помощью отношения $\lVF$.
Множество $\dom{\lVF \seqc [e]}$ будем называть \emph{фронтом}
события $e$. Это множество содержит все события записи
``наблюдаемые'' событием $e$.
Будем говорить что $e$ \emph{наблюдает} событие записи $w$,
то есть $\tup{w, e} \in G.\lVF_{\TC}$, если
$w$ ``происходит-до'' $e$, либо оно было
прочитано некоторым покрытым событием, ``происходящим-до''~$e$,
либо оно было ранее прочитано некоторым зафиксированным событием
принадлежащем тому же потококу, что и~$e$. 

\begin{definition}
\label{def:vf}
Отношение $\lVF$ определяется следующим образом:
\begin{align*}
  G.\lVF_{\tup{C,I}} \defeq {}
    [G.\lW] \seqc (G.\lRF \seqc [C])^? \seqc G.\lHB^? \cup
    G.\lRF \seqc [G.D_{\tup{C, I}}] \seqc G.\lPO^?.
\end{align*}
\end{definition}

На рисунке~\ref{fig:lb-sim-ex-travB} изображено три ребра отношения $G.\lVF_{\TC_b}$.
Все остальные ребра этого отношения могут быть выведены
при помощи следующего наблюдения:

$$ {G.\lVF_{\TC} \seqc G.\lPO \subseteq G.\lVF_{\TC}}. $$

Наконец, можно привести определение отношения стабильной обоснованости.
Оно соединяет событие чтения с $\lCO$ максимальным
наблюдаемым событием записи в ту же локацию.

\begin{definition}
\label{def:sjf}
Отношение \emph{стабильной обоснованности} определяется следующим образом.
\begin{equation*}
  G.\lSRF_{TC} \defeq
    ([G.\lW] \seqc (G.\lVF_{TC} \cap \lEQLOC) \seqc [G.\lR])
    \setminus (G.\lCO \seqc G.\lVF_{TC})
\end{equation*}
\end{definition}

Для графа $G$ и конфигурации $\TC_b$
отношение $\lSRF$ совпадает c показанными
на рисунке~\ref{fig:lb-sim-ex-travB} ребрами отношения $\lVF$:
$$\tup{\Init, \ese{1}{1}{}}, \tup{\Init, \ese{2}{1}{}},
  \tup{\ese{1}{3}{}, \ese{2}{2}{}} \in G.\lSRF_{\TC_b}.$$

\begin{lemma}
\label{lm:sjf-det}
Если граф $G$ консистентен согласно модели \IMM,
тогда отношение $G.\lSRF$ совпадает с отношением $G.\lRF$
на множестве зафиксированных событий чтения.
$$  G.\lSRF_{\TC} ; [G.D_{\TC}] \subseteq G.\lRF $$
\end{lemma}

Лемма \ref{lm:sjf-det}, в частности, гарантирует, что
выбранные метки для событий чтения в сертификационной ветке,
от которых зависят (согласно отношению $\lDEPS$) выпущенные события записи,
будут согласованы с метками соответствующих событий в графе $G$.
Для всех остальных событий чтения, согласно свойству восприимчивости,
можно безопасно заменить прочитанные значения.

\begin{lemma}
\label{lm:sjf-iss-po}
Если граф $G$ консистентен согласно модели \IMM,
тогда для отношения $G.\lSRF$ выполняется следующие соотношение:
$$  G.\lSRF_{\TC} \suq [I] \seqc G.\lSRF_{\TC} \cup G.\lPO. $$
\end{lemma}

Лемма \ref{lm:sjf-iss-po} позволяет выбрать обосновывающее
событие записи в структуре событий.
Пусть $\tup{w, r} \in G.\lSRF_{\TC}$.
Если при этом $\tup{w, r} \in [I] \seqc G.\lSRF_{\TC}$
тогда, согласно свойству \ref{simrel:ew-iss} отношения симуляции
можно выбрать событие записи $w' \in S.\lE$, которое принадлежит
конфигурации $X$ и при этом соответствует выпущенной записи, 
то есть верно, что $\ea(w') = w$.
Например, в случае конфигурации обхода $\TC_b$, показанной 
на рисунке~\ref{fig:lb-sim-ex-travB},
для события чтения $\ese{2}{2}{1}$
обосновывающим событием записи будет $\ese{2}{3}{1}$
Иначе $\tup{w, r} \in G.\lPO$.
В таком случае достаточно просто выбрать $S.\lPO$
предшествующее событие записи, принадлежащее сертификационной ветке $\Br$.

\paragraph{Упорядочивание событий записи.}

Позиция добавляемых событий записи в отношении порядка
$S.\lCO$ структуры событий выбирается на основе порядка
$G.\lCO$ \IMM графа. Тем не менее, из-за наличия конфликтующих событий,
можно гарантировать только лишь что отношение $S.\lCO$ вложено
в рефлексивное замыкание отношения $G.\lCO$,
то есть выполняется $\fmap{S.\lCO} \subseteq G.\lCO^?$.

\input{Dissertation/fig/lb-sim-ex-travC}

Данную особенность можно продемонстрировать 
на примере шага обхода из конфигурации $\TC_b$ 
(рисунок~\ref{fig:lb-sim-ex-travB})
в конфигурацию $\TC_c$ 
(рисунок~\ref{fig:lb-sim-ex-travC})
путем покрытия события $\ese{1}{1}{}$.
Для симуляции этого шага выполняется построение
структуры событий $S_c$, содержашей новую ветку 
$\Br_c \defeq \set{\ese{1}{1}{2}, \ese{1}{2}{2}, \ese{1}{3}{2}}$.

Рассмотрим события записи $\ese{1}{2}{1}$ и $\ese{1}{2}{2}$.
Так как два этих события имеют различные метки,
они не могут быть объявлены $\lEW$-эквивалентными.
С другой стороны, требуется, чтобы отношение
$S_c.\lCO$ полностью упорядочивало все события записи в одну и ту же локацию
(по модулю $\lEW$-эквивалентных событий).
То есть требуется каким-либо образом упорядочить
события $\ese{1}{2}{1}$ и $\ese{1}{2}{2}$ между собой.
Так как оба эти события отображаются в одно и то же событие $\ese{1}{2}{}$
в графе $G$, отношение $G.\lCO$ не может быть использовано
при выборе направления $S_c.\lCO$ ребра. 

На самом деле может быть выбран любой из двух способов
упорядочить эти события. Тем не менее,
в целях упрощения доказательства оказалось
удобнее выбрать порядок, при котором новые события
оказываются упорядочены ранее в отношении когеретности.
То есть, возвращаясь к примеру на рисунке~\ref{fig:lb-sim-ex-travC},
стоит добавить ребро $\tup{\ese{1}{2}{2}, \ese{1}{2}{1}} \in S_c.\lCO$.
Используя данное соглашение можно показать, что
$S.\lCO$ ребро, оканчивающиеся событием из новой ветки $\Br_c$,
должно отображаться строго в ребро $G.\lCO$ в графе: 
$\fmap{S_c.\lCO \seqc [\Br_c]} \suq G.\lCO$.

Далее рассмотрим события $\ese{1}{3}{1}$ и $\ese{1}{3}{2}$.
Эти события имеют одинаковую метку и отображаются в одно
и тоже событие $\ese{1}{3}{}$ в графе $G$.
Следовательно, они могут быть объявлены $\lEW$-эквивалентными.
На самом деле, для корректности построения их необходимо объявить таковыми.
Иначе события ветки $\Br_c$ окажутся невидимыми из-за того,
что существует путь $S_c.\lCF \cap (S_c.\lJFE \seqc (S_c.\lPO \cup S_c.\lJF)^*)$
из события $\ese{1}{3}{1}$ в событие $\ese{1}{1}{2}$.
Напомним, что только видимые события могут быть использованы
для извлечения графа сценария исполнения из структуры событий
(смотри определение~\ref{def:cfg}).

В общем случае, новое событие записи $e$
прикрепляется к классу эквивалентности по отношению $S.\lEW$,
представленному событием $w$, таким что
(i) $w$ имет тот же образ графе, что и $e$: $\ea(w) = \ea(e)$;
(ii) $w$ принадлежит конфигурации $X$, а его образ в графе
принадлежит множеству выпущенных событий: $w \in X \cap \fcomap{I}$.
Если такого события $w$ не существует, тогда $e$
упорядочивается в отношении $S.\lCO$ до
множества событий, чьи образы в графе $G.\lCO$-предшествуют $\ea(e)$
и после событий, чьи образы в графе равны или $G.\lCO$-следуют за $\ea(e)$.
Благодаря свойству \ref{simrel:jfe-iss} отношения симуляции,
а именно $\dom{S.\lJFE} \suq \dom{S.\lEW \seqc [X \cap \fcomap{I}]}$,
подобный выбор отношения $S'.\lEW$ гарантирует,
что все события из новой сертификационной ветки будут видимы. 

\section{Кодирование доказательства в системе \coq}
