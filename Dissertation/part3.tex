\chapter{Модель \Wkm и корректность компиляции}
\label{ch:weakestmo-imm}

Напомним, что модель \Wkm принадлежит классу моделей,
сохраняющих семантические зависимости.
Как уже упоминалось, одним из требований, предъявляемых к таким моделям,
является корректность оптимальной схемы компиляции
в ассемблерный код современных мультипроцессоров,
в частности \Intel~\cite{Sewell-al:CACM10},
\ARM~\cite{Pulte-al:POPL18} и \POWER~\cite{Alglave-al:TOPLAS14}.

В данной главе описывается выполненное в рамках
диссертационного исследования доказательство
о корректности компиляции из модели \Wkm в модели
современных мультипроцессоров.
Данное доказательство вместе с определением модели \Wkm
были формализованы в системе \coq.

В предложенном доказательстве используется \emph{промежуточная модель памяти}
(\emph{intermediate memory model, \IMM})~\cite{Podkopaev-al:POPL19}.
Данная модель является абстракцией над моделями \Intel, \ARM и \POWER,
которая позволяет скрыть низкоуровневые детали этих моделей.
Так как для модели \IMM ранее уже была доказана
корректность компиляции в модели \Intel, \ARM и \POWER~\cite{Podkopaev-al:POPL19}, 
то задача сводится к доказательству корректности компиляции из модели \Wkm в модель \IMM. 

Будем считать, что модель \Wkm и модель \IMM заданы для языка \LLANG,
а оптимальной схемой компиляции положим
тождественное отображение из языка \LLANG в него же.
Тогда требование о корректности компиляции
из модели \Wkm в модель \IMM сводится к следующей теореме. 

\begin{theorem}
  \label{thm:main}
  Пусть $P$ это программа на языке \LLANG
  и пусть $G$ это \IMM-консистентный граф сценария исполнения этой программы.
  Тогда существует \Wkm-консистентная структура событий $S$,
  соответствующая программе $P$,
  которая содержит граф $G$, то есть $S \rhd G$.
\end{theorem}

\section{Схема доказательства теоремы о корректности компиляции}

\eupp{В этом разделе необходимо переформулировать предложения,
  чтобы избежать плагиата с ВКР.}

Для того чтобы доказать теорему о корректности компиляции
в данной работе был предложен способ построения
необходимой структуры событий с помощью метода
\emph{симуляции}~\cite{Milner:1971}.
А именно, построение структуры событий происходит
инкрементально шаг за шагом с помощью операционной семантики
%% (\todo{ссылка на раздел про оп.сем.})
путем симуляции \emph{обхода \IMM графа}
(\emph{\IMM graph traversal})~\cite[\S6,7]{Podkopaev-al:POPL19}.
Обход графа соответствует некоторому сценарию выполнения программы,
в рамках которого события исполняются согласно
сохраняемому программному порядку ($\lPPO$).

Более формально, обход графа $G$
порождает операционную семантику малого шага 
$G \vdash \TC \travstep{e} \TC'$ где $\TC$ и $\TC'$ это
\emph{конфигурации обхода}.
Конфигурация обхода, в свою очередь, это пара $\tup{C, I}$,
где $C \suq G.\lE$ это множество \emph{покрытых событий}
(\emph{covered events}), а $I \suq G.\lW$ это множество
\emph{выпущенных записей} (\emph{issued writes}).
Покрытие события соответствует выполнению
инструкции программы в обычном порядке,
в то время как выпуск события записи соответствует
спекулятивному исполнению инструкции записи вне очереди.
Событие может быть покрыто если (i) все его
$\lPO$ предшественники уже покрыты, и (ii)
это событие уже выпущено (в случае события записи)
либо оно читает из уже выпущенной записи (в случае события чтения).
Событие записи может быть выпущено если все
события записи из других потоков, от которых
зависит данное событие согласно отношению $\lPPO$, также уже выпущены. 
Эти требования могут быть выражены как следующие инварианты конфигурации обхода.

\[\def\arraystretch{1}
\begin{array}{c@{\qquad}c@{\qquad}c@{\qquad}c}
 \dom{\lPO \seqc [C]} \subseteq C  &
 C \cap \lW \subseteq I             &
 \dom{\lRF \seqc [C]} \subseteq I  &
 \dom{\lRFE \seqc \lPPO \seqc [I]} \subseteq I
\end{array}
\]

Имея операционную семантику обхода \IMM графа $G \vdash \TC \travstep{e} \TC'$
и операционную семантику построения структуры событий $S \esstepcons{e} S'$
доказательство строится на основе метода \emph{симуляции}~\cite{Milner:1971}.
А именно, определяется отношение симуляции $\simrel(P, T, G, \TC, S, X)$,
соединяющее программу $P$, подмножество идентификаторов потоков $T \suq \Tid$,
\IMM граф $G$ и текущую конфигурацию его обхода $\TC$,
текущую структуру событий $S$ и его выделенную конфигурацию $X$.
Далее доказательство строится на следующих трех леммах,
которые утверждают что 
(i) начальная конфигурация обхода и инициализирующая структура событий
связаны отношением симуляции, (ii) каждый шаг обхода графа
может быть симулирован соответствующим шагом построения структуры событий,
(iii) из конечной структуры событий, которая соответствует конечной
конфигурации обхода, может быть извлечен требуемый \IMM граф $G$.

\begin{lemma}[Начало симуляции]
  \label{lm:simstart}
  \quad\\
  Пусть $P$ это программа на языке \LLANG,
  а $G$ это соответствуюий ей \IMM консистентный граф.
  Тогда выполняется $\simrel(P, \lTID(P), G, \TCinit{G}, \ESinit(P), \lEi)$ где
  \begin{itemize}
    \item $\lTID(P)$ --- множество всех идентификаторов потоков программы~$P$;
    \item $\TCinit{G} \defeq \tup{\lEi, \lEi}$ --- это начальная конфигурация обхода,
      содержащая только инициализирующие события;
    \item $\ESinit(P)$ --- это начальная структура событий,
      также содержащая только инициализирующие события.
  \end{itemize}
\end{lemma}

\begin{lemma}[Шаг симуляции]
  \label{lm:simstep}
  \quad\\
  Если выполняется $\simrel(P, T, G, \TC, S, X)$ и ${G \vdash \TC \travstep{} \TC'}$,
  тогда существует $S'$ и $X'$, такие что выполняется
  $\simrel(P, T, G, \TC', S', X')$ и $S \esstepcons{}^* S'$.
\end{lemma}

\begin{lemma}[Окончание симуляции]
  \label{lm:simend}
  \quad\\
  Если выполняется $\simrel(P, \lTID(P), G, \TCfinal{G}, S, X)$,
  где $\TCfinal{G} \defeq \tup{G.\lE, G.\lE}$ --- это конечная
  конфигурация обхода графа, тогда граф сценария исполнения,
  порождаемый конфигурацией $X$, изоморфен $G$,
  или, другими словами, $G$ может быть извлечен из $S$:~~$S \rhd G$.
\end{lemma}

Доказательство теоремы \ref{thm:main}
проводится методом индукции по трассе обхода графа
$G \vdash \TCinit{G} \travstep{}^* \TCfinal{G}$.
Лемма \ref{lm:simstart} используется в качестве базы индукции,
лемма \ref{lm:simstep} --- это шаг индукции,
а лемма \ref{lm:simend} завершает доказательство.

В свою очередь, доказательства лемм \ref{lm:simstart} и \ref{lm:simend}
достаточно прямолинейны (найти их можно в \coq репозитории).
Основная сложность заключена в доказательстве леммы \ref{lm:simstep}.
Более детально это доказательство рассматривается~в~разделе~\cref{sec:simstep}.

\section{Модель \IMM и обход графа сценария исполнения}

В этом разделе приводится формальное 
определение модели памяти \IMM~\cite{Podkopaev-al:POPL19},
а также операционной семантики обхода графов 
сценариев исполнения в модели~\IMM.

\input{Dissertation/imm}

\TODO{Семантика обхода графа}

\section{Симуляция обхода графа \IMM}

\eupp{В этом разделе необходимо переформулировать предложения,
  чтобы избежать плагиата с ВКР.}

В данном разделе приводится более подробный обзор
процесса симуляции построения структуры событий по обходу \IMM графа.
В разделе \ref{sec:simrel} описывается
отношение симуляции $\simrel$, 
а в разделе \ref{sec:simstep} на примере графа, 
изображенного на \cref{fig:lb-sim-ex},
рассматривается процесс симуляции шага обхода \IMM графа
семантикой построения структуры событий. 

\input{Dissertation/fig/lb-sim-ex}

\input{Dissertation/simrel}
\input{Dissertation/simstep}
