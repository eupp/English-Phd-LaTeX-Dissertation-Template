\chapter{\Wkm and Soundness of Compilation Schemes}
\label{ch:weakestmo-imm}

Напомним, что модель \Wkm принадлежит классу моделей,
сохраняющих семантические зависимости.
Как уже упоминалось, одним из свойств, ожидаемым от моделей данного класса,
является корректность оптимальной схемы компиляции
в ассемблерный код современных мультипроцессоров,
в частности \Intel~\cite{Sewell-al:CACM10},
\ARM~\cite{Pulte-al:POPL18} и \POWER~\cite{Alglave-al:TOPLAS14}.

В данной главе описывается доказательство
корректности оптимальной схемы компиляции из модели \Wkm в модели
современных мультипроцессоров, выполненное в рамках данной диссертации.
Данное доказательство вместе с определением модели \Wkm
было формализовано в системе \coq.
В  главе описываются основные идеи доказательства.
Репозиторий с исходным кодом данной формализации
находится по ссылке~%
\cite{Coq:Weakestmo}.


В предложенном доказательстве используется \emph{промежуточная модель памяти}
(\emph{intermediate memory model, \IMM})~\cite{Podkopaev-al:POPL19}.
Данная модель является абстракцией над моделями \Intel, \ARM и \POWER,
которая позволяет скрыть низкоуровневые детали этих моделей.
Так как для модели \IMM ранее уже была доказана
корректность оптимальной компиляции в модели \Intel, \ARM и \POWER~\cite{Podkopaev-al:POPL19}, 
то задача сводится к доказательству корректности компиляции из модели \Wkm в модель \IMM. 

Будем считать, что модель \Wkm и модель \IMM заданы для языка,
который  представляет собой код для 
простой параллельной регистровой машины с разделяемой памятью.
Оптимальной схемой компиляции будем считать
тождественное отображение инструкций языка \LLANG в инструкции этого же языка~\LLANG~\cite{Podkopaev-al:POPL19}.
Тогда требование о корректности оптимальной схемы компиляции
из модели \Wkm в модель \IMM сводится к следующей теореме. 

\begin{theorem}
  \label{thm:main}
  Пусть $P$ является  программой на языке \LLANG,
  а $G$ --- это \IMM-консистентный граф сценария исполнения этой программы.
  Тогда существует \Wkm-консистентная структура событий $S$,
  соответствующая программе $P$, которая содержит граф $G$, 
  то есть верно, что $S \rhd G$.
\end{theorem}

\section{Proof Sketch of the Soundness Theorem}

Доказательство теоремы проводится методом \emph{симуляции}~\cite{Milner:1971}.
Этот метод позволяет установить, что одна система помеченных переходов
может симулировать шаги другой системы переходов. Из этого, в частности, следует,
что язык, принимаемый второй системой, является подмножеством языка, принимаемого первой системой переходов. 
Суть метода заключается в том, чтобы предъявить \emph{отношение симуляции} между состояниями двух систем. 
Затем требуется доказать, что если пара состояний связана отношением симуляции, 
то при выполнении помеченного перехода второй системой первая система 
также может совершить переход по данной метке, и
результирующие состояния двух систем снова окажутся связаны отношением симуляции.

Построение необходимой структуры событий выполняется пошагово, 
путем симуляции \emph{обхода} графа сценария исполнения~\cite[\S6,7]{Podkopaev-al:POPL19}.
Обход графа $G$ порождает систему помеченных переходов
$G \vdash \TC \travstep{e} \TC'$, где $\TC$ и $\TC'$ --- это
\emph{конфигурации обхода}.
Каждая такая конфигурация является парой $\tup{C, I}$ двух подмножеств событий графа.
Первый компонент пары $C \suq G.\lE$ --- это множество 
\emph{покрытых событий} (covered events).
Добавление события в множество покрытых событий  
моделирует исполнение одной инструкции программы в обычном порядке (in-order).
Второй компонент пары  $I \suq G.\lW$ представляет собой множество
\emph{выпущенных событий записи} (issued writes).
Выпуск события записи соответствует
спекулятивному исполнению некоторой инструкции записи вне очереди (out-of-order).

Событие может быть покрыто при выполнении следующих условий.
Во-первых, все $\lPO$ предшественники этого события уже покрыты.
Во-вторых, если это событие является событием записи, то оно должно быть выпущено,
а если оно является событием чтения, то тогда оно должно читать 
из выпущенного события записи.
Событие записи может быть выпущено, если все
события записи из других потоков, от которых оно зависит согласно отношению $\lPPO$, 
уже выпущены. 
Эти требования порождают следующие инварианты конфигурации обхода графа.

\[\def\arraystretch{1}
\begin{array}{c@{\qquad}c@{\qquad}c@{\qquad}c}
 \dom{\lPO \seqc [C]} \subseteq C   &
 C \cap \lW \subseteq I             &
 \dom{\lRF \seqc [C]} \subseteq I   &
 \dom{\lRFE \seqc \lPPO \seqc [I]} \subseteq I
\end{array}
\]

Процесс построения структуры событий также можно рассматривать как 
систему помеченных переходов $S \esstepcons{e} S'$.
Таким образом добавление нового события в структуру соответствует 
одному шагу в этой системе. 

Далее доказательство использует метод \emph{симуляции}~\cite{Milner:1971} 
одной операционных семантики для воспроизведения ее трассы другой семантикой.
Вводится отношение симуляции $\simrel(P, T, G, \TC, S, X)$,
где $P$ --- это фиксированная программа, 
$T \suq \Tid$ --- подмножество идентификаторов потоков этой программы,
$G$ и $\TC$ --- это \IMM граф и текущая конфигурация его обхода,
$S$ --- текущая структура событий, а $X$ --- выделенная 
обоснованная конфигурация $X$ этой структуры.

Доказательство теоремы \ref{thm:main}
выполняется методом индукции по трассе обхода графа
$G \vdash \TCinit{G} \travstep{}^* \TCfinal{G}$.
В качестве базы индукции используется лемма \ref{lm:simstart},
которая утверждает, что начальная конфигурация обхода 
и инициализирующая структура событий связаны отношением симуляции.
Лемма \ref{lm:simstep} служит для индукционного перехода
и утверждает, что каждый шаг обхода графа
может быть симулирован соответствующим шагом построения структуры событий.
Наконец, лемма \ref{lm:simend} завершает доказательство. 
Эта лемма постулирует, что из конечной структуры событий, соответствующей конечной
конфигурации обхода, может быть извлечен требуемый граф $G$.

\begin{lemma}
  \label{lm:simstart}
  Пусть $P$ --- это программа на языке \LLANG,
  а $G$ --- это соответствующий ей \IMM консистентный граф.
  Тогда выполняется отношение симуляции $\simrel(P, \lTID(P), G, \TCinit{G}, \ESinit(P), \lEi)$, 
  где множество потоков $\lTID(P)$, а также 
  начальная конфигурация обхода $\TCinit{G}$ и структура событий $\ESinit(P)$ заданы следующим образом:
  \begin{itemize}
    \item $\lTID(P)$ --- множество всех идентификаторов потоков программы~$P$;
    \item $\TCinit{G} \defeq \tup{\lEi, \lEi}$ --- начальная конфигурация обхода,
      содержащая только инициализирующие события;
    \item $\ESinit(P)$ ---  начальная структура событий,
      также содержащая только инициализирующие события.
  \end{itemize}
\end{lemma}

\begin{lemma}
  \label{lm:simstep}
  Если выполняется отношение симуляции $\simrel(P, T, G, \TC, S, X)$ и делается шаг обхода графа ${G \vdash \TC \travstep{} \TC'}$,
  тогда существует структура событий $S'$ и ее конфигурация $X'$ такие, что выполняется отношение симуляции 
  $\simrel(P, T, G, \TC', S', X')$ и может быть сделан
  шаг построения структуры событий $S \esstepcons{}^* S'$.
\end{lemma}

\begin{lemma}
  \label{lm:simend}
  Если выполняется отношение симуляции \\ $\simrel(P, \lTID(P), G, \TCfinal{G}, S, X)$,
  где $\TCfinal{G} \defeq \tup{G.\lE, G.\lE}$ --- это конечная
  конфигурация обхода графа, тогда граф сценария исполнения,
  порождаемый конфигурацией $X$, изоморфен графу $G$,
  или, другими словами, $G$ может быть извлечен из 
  структуры событий $S$:~~$S \rhd G$.
\end{lemma}

Доказательства лемм \ref{lm:simstart} и \ref{lm:simend}
достаточно просты, и их  можно найти в \coq репозитории~\cite{Coq:Weakestmo}.
Основная сложность заключена в доказательстве леммы \ref{lm:simstep},
которое рассматривается в~разделе~\ref{sec:simstep}.

\section{\IMM and Execution Graph Traversals}

Модель \IMM относится к классу моделей, сохраняющих синтаксические зависимости. 
В данной модели отношение сохраняемого программного порядка~$\lPPO$, 
включающее отношение зависимости~$\lDEPS$ (см. определение~\ref{def:deps-rel}),
задано согласно следующему определению.

\begin{definition}
  \label{def:imm-ppo}
  В модели \IMM отношение $\lPPO$ определено следующим образом:
  $$ \lPPO \defeq [\lR] \seqc (\lDEPS \cup \lRFI)^+ \seqc [\lW]. $$
\end{definition}
 
Для того, чтобы запретить значения из воздуха 
помимо отношения $\lPPO$, модель \IMM также определяет 
\emph{глобальное отношение порядка} $\lAR$ (global acyclic relation),
которое состоит из следующих отношений. 

\begin{definition}
  \label{def:imm-bob}
  Отношение \emph{порядка барьеров} $\lBOB$ (\emph{barrier-order-before})
  связывает события в рамках одного потока, если между ними находится барьеры памяти:
  $$ \lBOB \defeq \lPO \seqc [\lW^{\rel\squq}] \cup 
                  [\lR^{\acq\squq}] \seqc \lPO \cup 
                  \lPO \seqc [\lF] \cup [\lF] \seqc \lPO \cup 
                  [\lW^{\rel\squq}] \seqc \lPO_{\lLOC} \seqc [\lW]. $$
\end{definition}

\begin{definition}
  \label{def:imm-detour}
  Отношение \emph{обхода} (\emph{detour}) связывает 
  событие записи c следующим за ним в рамках программного порядка $\lPO$ 
  событием чтения, если это событие читает-из другого потока:
  $$ \lDETOUR \defeq (\lCOE \seqc \lRFE) \cap \lPO. $$
\end{definition}

\begin{definition}
  \label{def:imm-ar}
  Глобальное отношение порядка $\lAR$ (global acyclic relation)
  в модели \IMM задано следующим образом:
  $$ \lAR \defeq \lBOB \cup \lPPO \cup \lRFE \cup \lDETOUR \cup \lPSCF. $$
\end{definition}

Подробный разбор определений данных отношений выходит 
за рамки этой диссертации и может быть найден в работе~\cite{Podkopaev-al:POPL19}.

Требование консистентности графа сценария исполнения согласно модели \IMM 
запрещает появление значений из воздуха, а также включает свойства 
когерентности (определение~\ref{def:coherence}),
\RMW-атомарности (определение~\ref{def:rmw-atomicity})
и последовательной согласованности (определение~\ref{def:seq-consistency}).
  
\begin{definition}
  \label{def:rc11-cons}
  Граф $G$ является консистентным с точки зрения модели \IMM,
  если выполняются следующие условия:  

  \begin{itemize}

    \item $\lAR$ является ацикличным отношением;
      \labelAxiom{\RCMM-No-Thin-Air}{ax:imm-noota}

    \item $\lHB \seqc \lECO^?$ является иррефлексивным отношением;
      \labelAxiom{Coherent}{ax:imm-coh}

    \item $\lRMW \cap (\lRB \seqc \lCO) = \emptyset$;
      \labelAxiom{\RMW-Atomic}{ax:imm-atom}

    \item $\lPSC$ является ацикличным отношением.
      \labelAxiom{Sequentially Consistent}{ax:imm-sc}

  \end{itemize}
\end{definition}

Можно видеть, что модель \IMM действительно относится к 
классу моделей, сохраняющих синтаксические зависимости 
(согласно определению~\ref{def:ppo-preserving}),
так как верно, что $\lPPO \cup \lRFE \suq \lAR$.

\input{Dissertation/fig/trav-opsem}

Далее рассмотрим формальную операционную семантику обхода \IMM графа,
правила которой показаны на рисунке~\ref{fig:trav-opsem}.
Правило \CoverStep отвечает за покрытие события,
а правило \IssueStep за выпуск события записи. 

\begin{definition}
\label{def:coverable}
Событие $e$ может быть \emph{покрыто} (coverable)
в конфигурации обхода $\tup{C, I}$, что обозначается как 
$w \in \Coverable(G, C, I)$, если выполняются следующие условия: 
\begin{itemize}
\item $ \dom{\lPO \seqc [e]} \suq C $;
\item если $e \in \lW$ тогда $e \in I$;
\item если $e \in \lR$ тогда $\dom{\lRF \seqc [e]} \suq I$;
\item если $e \in \lF^{\sco}$ тогда $\dom{\lSC \seqc [e]} \suq C$.
\end{itemize}
\end{definition}

\begin{definition}
\label{def:issueable}
Событие записи $w$ может быть \emph{выпущено} (\emph{issueable})
в конфигурации обхода $\tup{C, I}$, что обозначается как 
$w \in \Issuable(G, C, I)$, если выполняются следующие условия: 
\begin{itemize}
\item $ \dom{([\lW^{\rel\squq}] \seqc \lPO\rst{G.\lLOC} \cup [\lF] \seqc \lPO) \seqc [w]} \suq C $;
\item $ \dom{(\lDETOUR \cup \lRFE) \seqc (\lPPO \cup [\lR^{\acq\squq}] \seqc \lPO) \seqc [w]} \suq I $.
\end{itemize}
\end{definition}

Сделаем ряд замечаний. 
Правило \IssueStep выпускает только те события записи,
которые аннотированны режимом доступа более слабым, чем~$\rel$. 
События записи, аннотированные режимом $\rel$ или более строгим, 
обрабатываются правилом \ReleaseCoverStep  ---  
для таких событий одновременно выполняется их выпуск и покрытие.

Покрытие событий записи, 
относящихся к атомарной паре чтения-записи,
выполняется сходным образом, согласно правилу \RMWCoverStep. 
Во-первых, выполняется проверка того, что событие чтения данной 
пары может быть покрыто. Во-вторых, если событие записи данной пары
аннотировано режимом доступа более слабым, чем~$\rel$,
то оно уже должно быть выпущено.
Иначе одновременно выполняется и его выпуск, и покрытие. 

\section{Operational Semantics of Event Structure Construction}

На рисунке~\cref{fig:wkmo-opsem} представлена формальная 
операционная семантика процесса построения структуры событий в модели \Wkm, а
на рисунке~\cref{fig:wkmo-opsem-deltas}  приводятся 
вспомогательные определения, используемые для задания семантики.

\input{./Dissertation/fig/opsem}
\input{./Dissertation/fig/opsem-deltas}

Семантика построения структуры событий параметризована
\emph{локальной операционной семантикой потоков} $\thrdst \thrdstep{} \thrdst'$.
Отношение перехода задано на парах $\tup{S, \lCONT}$,
где $S$ --- это структура событий, а $\lCONT : S.\lE \fun \thrdst$ ---
функция, отображающая события в \emph{локальные состояния потоков}.

Правило \AddPORule отвечает за добавление в структуру $S$ нового события $e'$,
обновление $\lPO$ компоненты и функции $\lCONT$.
При применении этого правила выбирается событие $e$, 
которое будет являться предком нового события $e'$.
Также выполняется проверка того факта, что локальные состояния, соответствующие событиям $e$ и $e'$, 
 образуют корректный переход в локальной семантике потока.  

Правило \AddRMWRule выполняет обновление $\lRMW$ компоненты.
Правило \AddJFRule отвечает за обновление $\lJF$ компонент, то есть
для нового события чтения $r$ недетерменированно выбирается 
обосновывающее его событие записи $w$.
Правило \AddEWRule выполняет обновление $\lEW$ компоненты; 
для этого выбирается подмножество событий записи $EW$,
которое образует класс эквивалентности согласно отношению $\lEW$,
и новое событие записи $w'$ помещается в этот класс.
Правило \AddCORule отвечает за обновление $\lCO$ компоненты, то есть 
выбирается подмножество событий $W$, и новое событие записи $w'$ упорядочивается 
перед событиями из этого подмножества.

Правила \AddFRule, \AddRRule и \AddWRule отвечают 
за добавление события барьера, чтения и записи, соответственно, 
выполняя обновление необходимых компонент структуры событий. 
Правило \AddEventRule добавляет новое событие 
с помощью одного из вышеозначенных правил и дополнительно проверяет 
корректность итоговой структуры событий $S'$.

\section{Simulation of \IMM Graph Traversal}

Рассмотрим более подробно процесса симуляции 
построения структуры событий путем обхода \IMM графа
на примере программы и \IMM графа, показанных на рисунке~\ref{fig:lb-sim-ex}.

\input{Dissertation/fig/lb-sim-ex}

\subsection*{Simulation Relation}
\label{sec:simrel}

Определим отношение симуляции $\simrel$.
В демонстрационных целях далее приводится упрощенная версия формального определения
этого отношения, опускающая некоторые излишне сложные технические детали. 
Полная версия отношения симуляции находится в \coq репозитории. 

Отношение симуляции $\simrel$ устанавливает взаимосвязь между структурой событий $S$
и графом сценария исполнения $G$ с помощью
функции $\ea : S.\lE \fun G.\lE$, которая отображает 
события структуры $S$ в события графа $G$.
Эта функция может быть расширена на множества событий следующим образом%
\footnote{Аналогичным образом функция $\ea$ может быть расширена
на бинарные отношения на событиях.}:
\vspace{-0.5cm}
\begin{align*}
\text{для } A_S \subseteq S.\lE        & :
  \fmap{A_S} \defeq \set{\ea(e) \in G.\lE \mid e \in A_S} \\
\text{для } A_G \subseteq G.\lE        & :
  \fcomap{A_G} \defeq \set{e \in S.\lE \mid \ea(e) \in A_G}.
\end{align*}
%% \vspace{2pt}

Отношение симуляции $\simrel(P, T, G, \TC, S, X)$ имеет следующие свойства.

\begin{enumerate}

  \item \label{simrel:events}
    События структуры $S$, относящиеся к потокам из множества $T$,
    а также события, принадлежащие конфигурации $X$,
    должны соответствовать покрытым событиям,
    а также выпущенным событиям и их предшественникам в программном порядке: 
    $$\fmap{S.\lE\rst{T}} = \fmap{X} = C \cup \dom{G.\lPO^? \seqc [I]}.$$

  \item \label{simrel:lab}
    Метки событий в структуре $S$ и графе $G$ связаны следующим образом.  
    \begin{enumerate}
      \item \label{simrel:lab-eqmval}
         Во-первых, метки событий должны совпадать по модулю прочитанных или записанных значений: 
         $$\forall e \in S.\lE \ldotp\;
              S.\set{\lTID, \lTYP, \lLOC, \lMOD}(e) =
              G.\set{\lTID, \lTYP, \lLOC, \lMOD}(\fmap{e}). 
         $$

      \item \label{simrel:lab-det}
        Во-вторых, метки событий, принадлежащих конфигурации $X$, чьи образы 
        лежат в множестве покрытых или выпущенных событий, должны полностью совпадать:
        $$\forall e \in X \cap \fcomap{C \cup I} \ldotp~
            S.\lVAL(e) = G.\lVAL(\ea(e)).
        $$
    \end{enumerate}

  \item \label{simrel:po}
    Программный порядок в структуре событий $S$
    должен совпадать с программным порядком в графе $G$:
    $$\fmap{S.\lPO} \suq G.\lPO.$$

  \item \label{simrel:cf}
    События структуры $S$, имеющие одинаковый образ под действием функции $\ea$,
    должны быть равны или находится в конфликте: 
    $$\fcomap{\mathtt{id}} \suq S.\lCF^?.$$

  \item \label{simrel:jf}
    Отношение обоснованности $\lJF$ в структуре событий $S$
    должно обладать следующими свойствами.
    \begin{enumerate}
      \item \label{simrel:jf-obs}
        Образ события чтения в структуре $S$ должен ``наблюдать'' 
        образ события записи, которое его обосновывает: 
        $$\fmap{S.\lJF} \suq G.\lRF^?\seqc G.\lHB^?.$$

      \item \label{simrel:jf-sjf}
        Более того, если событие чтения принадлежит конфигурации $X$, 
        тогда его образ в графе $G$ должен быть связан с образом обосновывающего события 
        отношением \emph{стабильной обоснованности} (stable justification)
        (смотри определение~\ref{def:sjf}):
        $$\fmap{S.\lJF \seqc [X]} \suq G.\lSRF_{TC}.$$


      \item \label{simrel:jfe-iss}
        Наконец, для внешнего обоснования события чтения 
        могут быть использованы только те события записи, 
        образ которых принадлежит множество выпущенных событий:
        $$\dom{S.\lJFE} \suq \dom{S.\lEW \seqc [X \cap \fcomap{I}]}.$$
    \end{enumerate}

  \item \label{simrel:ew}
    Отношение эквивалентности на событиях записи $\lEW$ 
    в структуре событий $S$ должно обладать следующими свойствами.

    \begin{enumerate}
      \item \label{simrel:ew-id}
        Эквивалентые события записи в структуре $S$ 
        должны отображаться в одно и то же событие записи в графе $G$:
        $$\fmap{S.\lEW} \suq \mathtt{id}.$$

      \item \label{simrel:ew-iss}
        Для каждого класса эквивалентности по отношению $S.\lEW$
        должен сущетствовать такой его представитель принадлежащий конфигурации $X$
        такой, что его образ является выпущенным событием записи:
        $$S.\lEW \suq (S.\lEW \seqc [X \cap \fcomap{I}] \seqc S.\lEW)^?.$$
    \end{enumerate}

  \item \label{simrel:co}
    Отношение когерентности $\lCO$ 
    в структуре событий $S$ должно обладать следующими свойствами.

    \begin{enumerate}
      \item \label{simrel:co-co}
        Образы событий структуры $S$, связанные отношением когерентности, 
        должны также находится в отношении когерентности либо быть равны:
        $$\fmap{S.\lCO} \suq G.\lCO^?.$$

      \item \label{simrel:co-cfg}
        В случае, если ребро отношения когерентности в структуре $S$
        оканчивается в событии, принадлежащем конфигурации $X$ и одному из потоков из $T$,
        тогда их образ этого должен лежать строго в отношении когерентности в графе $G$:
        $$\fmap{S.\lCO \seqc [X\rst{T}]} \suq G.\lCO.$$
    \end{enumerate}

  \item \label{simrel:sw-hb}
    Отношения ``синхронизируется-с'' и ``происходит-до''
    в структуре событий $S$ должны быть согласованы с соответствующими отношениями в графе $G$:
    $$\fmap{S.\lSW} \suq G.\lSW \qquad\qquad \fmap{S.\lHB} \suq G.\lHB.$$

\end{enumerate}

\input{Dissertation/fig/lb-sim-ex-travA}

Для примера покажем, что граф $\GTrav$,
конфигурация его обхода $\TC_a$, 
структура событий $S_a$ и ее конфигурация $X_a$,
продемонстрированные на рисунке~\ref{fig:lb-sim-ex-travA}, 
связаны отношением симуляции, то есть выполняется 
$\simrel(\progTrav, \lTID(\progTrav), \GTrav, \TC_a, S_a, X_a)$.

Определим функцию $\ea_{\GTrav, S_a}$  следующим образом:
$$\ea_{\GTrav,S_a} = \set{
  \Init \mapsto \Init, 
  \ese{1}{1}{1} \mapsto \ese{1}{1}{},
  \ese{1}{2}{1} \mapsto \ese{1}{2}{},
  \ese{1}{3}{1} \mapsto \ese{1}{3}{}
}.$$

Можно убедиться, что свойства \ref{simrel:events}, 
\ref{simrel:lab-eqmval}, \ref{simrel:po} отношения симуляции 
действительно выполняются. 
Свойство \ref{simrel:lab-det} также выполняется, 
так как события $\ese{1}{3}{1}$ и $\ese{1}{3}{}$ имеют одинаковые метки
(заметим, что $\ese{1}{3}{}$ является единственным выпущенным событием,
 поэтому ограничение \ref{simrel:lab-det} распространяется только на прообразы этого события). 
Поскольку отношения $\lCF$ и $\lEW$ пусты, то есть $\lCF=\lEW=\emptyset$, 
то свойства \ref{simrel:cf} и \ref{simrel:ew} выполняются тривиальным образом. 
Все ограничения на отношение $\lJF$, то есть свойство \ref{simrel:jf},
также выполняются, поскольку единственное 
событие чтения $\ese{1}{1}{1}$ обосновано инициализирующей записью $\Init$, 
которая ``происходит-до'' этого события чтения. 
Образы отношений $\lCO$ и $\lHB$ структуры $S$ совпадают
с соответствующими отношениями в графе $G$,
из чего можно сделать вывод, что свойства 
\ref{simrel:co} и \ref{simrel:sw-hb} также выполняются. 

\subsection*{Simulation Step}
\label{sec:simstep}

Покажем, как шаг построения структуры событий
может симулировать шаг обхода графа \IMM.

Положим, что для некоторых $P$, $G$, $\TC$, $S$ и $X$
выполняется отношение симуляции $\simrel(P, G, \TC, S, X)$.
В рамках обхода графа выполняется шаг
${G \vdash \TC \travstep{} \TC'}$, покрывающий или выпускающий
некоторое событие с идентификатором потока $t$.
Согласно лемме \ref{lm:simstep}, 
необходимо предъявить структуру событий $S'$ и конфигурацию ее обхода $X'$
такие, чтобы выполнялось отношение симуляции $\simrel(P, G, \TC', S', X')$.

В случае, если поток $t$ содержит выпущенные, но непокрытые события записи,
необходимо выполнить несколько шагов построения структуры событий,
чтобы добавить все события, предшествующие событиям записи в потоке $t$.
Будем называть множество этих событий
\emph{сертификационной веткой},
а процесс добавление этих событий --- \emph{сертификацией}.

\input{Dissertation/fig/lb-sim-ex-travB}

Рассмотрим процесс сертификации 
на примере одного шага перехода из конфигурации $\TC_a$ 
(рисунок~\ref{fig:lb-sim-ex-travA})
в конфигурацию $\TC_b$ 
(рисунок~\ref{fig:lb-sim-ex-travB})
путем выпуска события $\ese{2}{3}{}$.
Для симуляции этого шага требуется выполнить несколько инструкций правого потока
и добавить в структуру событий ветку, состоящую из множества событий
$\Br_b = \set{\ese{2}{1}{1},\ese{2}{2}{1},\ese{2}{3}{1}}$
(рисунок~\ref{fig:lb-sim-ex-travB}).
Для этого необходимо
построить трассу операционной семантики потока
${\state \thrdstep{\ese{2}{1}{1}}
         \thrdstep{\ese{2}{2}{1}}
         \thrdstep{\ese{2}{3}{1}}
         \state'}$, 
удовлетворяющую следующим условиям: 
данная ветка должна содержать все события правого потока
вплоть до последнего выпущенного события $\ese{2}{3}{}$;
метки этих событий должны совпадать с метками
соответствующих событий в графе $\GTrav$
(то есть $\ese{2}{1}{}, \ese{2}{2}{}, \ese{2}{3}{}$),
по модулю прочитанного или записанного значения; 
наконец, метки событии, соответствующих покрытым и выпущенным событиям
(в данном случае~$\ese{2}{3}{1}$)  должны совпадать  по значению.

Для построения такой трассы используется свойство
\emph{восприимчивости} (\emph{receptiveness})
операционной семантики потока.
Данное свойство позволяет изменить прочитанное значение 
всех промежуточных событий чтения в трассе,
от которых не зависят (согласно отношению $\lDEPS$) выпущенные события записи%
\footnote{Формальное определение восприимчивости опущено
в данной работе. Оно может быть найдено в \coq репозитории,
сопровождающем работу~\cite{Podkopaev-al:POPL19}.}.

При добавлении событий новой ветки $\Br_b$ в структуру $S$
необходимо выполнить следующие требования.
Во-первых, каждому событию чтения (в данном случае $\ese{2}{1}{1}$ и $\ese{2}{2}{1}$)
необходимо поставить в соответствие обосновывающее его событие записи.
Во-вторых, для событий записи необходимо определить их позицию в отношении когерентности $\lCO$. 

Наконец, после завершения сертификации, происходит замена 
событий из старой ветки потока $t$ в конфигурации $X$
на события новой ветки $Br_b$:
$$ X_b \defeq X_a \setminus S.\lE\rst{t} \cup \Br_b, $$
где $S.\lE\rst{t} \defeq \set{e \in S.\lE \sth S.\lTID(e) = t}$.

\paragraph{Обоснование событий чтения.}

Опишем, как происходит выбор обосновывающего события записи
при добавлении события чтения. 
Для этого введем отношение \emph{стабильной обоснованности} в графе $G$.

С этой целью для  графа $G$ и текущей конфигурации обхода $\tup{C, I}$
определим множество \emph{зафиксированных} (determined) событий.
Метки таких событий, а также событий записи, которые обосновывают зафиксированные события чтения, 
должны совпадать в графе $G$, текущей структуре событий $S$
и в конструируемой на данном шаге сертификационной ветке $\Br$.

\begin{definition}
\label{def:det}
Множество \emph{зафиксированных событий} определяется следующим соотношением:
\begin{align*}
  G.D_{\tup{C, I}} &\defeq {}
           C \cup I {}\cup{} \\
     %% &\cup G.\lW \setminus \codom{G.\lPPO} {}\cup{} \\
     &\cup \dom{G.\lRFI^? \seqc G.\lPPO \seqc [I]} {}\cup{} \\
     &\cup \cod{[I] \seqc G.\lRFI} {}\cup{} \\
     &\cup \cod{G.\lRFE \seqc [G.\lE^{\squq\acq}]}.
\end{align*}
\end{definition}

Можно видеть, что зафиксированными считаются 
уже покрытые и выпущенные событий, а также
все их предшественники в рамках программного порядка,
и все события чтения, которые читают из некоторого выпущенного события из своего же потока,
наконец, события захватывающего ($\acq$) чтения, которые читают не из своего потока. 

В случае графа $\GTrav$ и его конфигурации обхода $\TC_b$
(рисунок~\ref{fig:lb-sim-ex-travB}) 
множество зафиксированных событий состоит из  
$\ese{1}{3}{}$, $\ese{2}{2}{}$ и $\ese{2}{3}{}$.

Также определим понятие \emph{фронта} события, используя для этог отношение $\lVF$, 
то есть множество $\dom{\lVF \seqc [e]}$ будем называть \emph{фронтом} события $e$. 
Такое множество включает все события записи, которые событие $e$ ``наблюдает''.
Будем говорить, что событие $e$ \emph{наблюдает} событие записи $w$ (что обозначается как $\tup{w, e} \in G.\lVF_{\TC}$), 
если $w$ ``происходит-до'' $e$, либо $w$ было
прочитано некоторым покрытым событием, которое ``происходит-до''~$e$,
либо $w$ было прочитано зафиксированным событием чтения,
предшествующим событию $e$ в рамках программного порядка.

\begin{definition}
\label{def:vf}
Отношение $\lVF$ определяется следующим образом:
\begin{align*}
  G.\lVF_{\tup{C,I}} \defeq {}
    [G.\lW] \seqc (G.\lRF \seqc [C])^? \seqc G.\lHB^? \cup
    G.\lRF \seqc [G.D_{\tup{C, I}}] \seqc G.\lPO^?.
\end{align*}
\end{definition}

Заметим, что справедливо  следующее: ${G.\lVF_{\TC} \seqc G.\lPO \subseteq G.\lVF_{\TC}}.$
Таким образом, любое ребро отношения $\lVF$ может быть продолжено в программном порядке.

На рисунке~\ref{fig:lb-sim-ex-travB} также продемонстировано отношение $G.\lVF_{\TC_b}$, при этом не показаны  ребра этого отношения, которые могут быть получены продолжением по отношению $\lPO$.

Наконец, можно дать определение отношению стабильной обоснованости ---
оно соединяет событие чтения с $\lCO$ максимальным событием 
записи в ту же локацию, которое наблюдает это событие чтения.

\begin{definition}
\label{def:sjf}
Отношение \emph{стабильной обоснованности} определяется следующим соотношением:
\begin{equation*}
  G.\lSRF_{TC} \defeq
    ([G.\lW] \seqc (G.\lVF_{TC} \cap \lEQLOC) \seqc [G.\lR])
    \setminus (G.\lCO \seqc G.\lVF_{TC}).
\end{equation*}
\end{definition}

Для графа $\GTrav$ и конфигурации $\TC_b$ (рисунок~~\ref{fig:lb-sim-ex-travB})
отношение $\lSRF$ совпадает c показанными ребрами отношения $\l VF$:$\tup{\Init, \ese{1}{1}{}}, \tup{\Init, \ese{2}{1}{}},
  \tup{\ese{1}{3}{}, \ese{2}{2}{}} \in G.\lSRF_{\TC_b}.$

Рассмотрим следующую лемму, которая утверждает, что
метки для событий чтения в сертификационной ветке,
из которых исходят ребра отношения $\lDEPS$ в выпущенные события записи,
будут согласованы с метками соответствующих событий в графе $G$.

\begin{lemma}
\label{lm:sjf-det}
Для \IMM-консистентного графа $G$ верно,
что отношение $G.\lSRF$ совпадает с отношением $G.\lRF$
на множестве зафиксированных событий чтения:
$  G.\lSRF_{\TC} ; [G.D_{\TC}] \subseteq G.\lRF. $
\end{lemma}

Для всех остальных событий чтения, согласно свойству восприимчивости,
можно безопасно заменить прочитанные значения.

Следующая лемма  позволяет 
выбрать обосновывающее событие записи для нового события чтения.

\begin{lemma}
\label{lm:sjf-iss-po}
Для \IMM-консистентного графа $G$ выполняется 
$  G.\lSRF_{\TC} \suq [I] \seqc G.\lSRF_{\TC} \cup G.\lPO. $
\end{lemma}

Покажем, как с помощью этой леммы происходит выбор события записи. 
Положим $\tup{w, r} \in G.\lSRF_{\TC}$.
Если событие $w$ уже выпущено, то есть $\tup{w, r} \in [I] \seqc G.\lSRF_{\TC}$, 
тогда воспользовавшись свойством \ref{simrel:ew-iss} отношения симуляции
можно выбрать событие записи $w' \in S.\lE$, 
которое будет принадлежать конфигурации $X$ 
и при этом соответствовать событию $w$, то есть $\ea(w') = w$.
Например, в случае конфигурации обхода $\TC_b$ (рисунок~\ref{fig:lb-sim-ex-travB})
для события чтения $\ese{2}{2}{1}$ в качестве обосновывающего события записи 
будет выбрано событие $\ese{2}{3}{1}$.
Если событие $w$ не является выпущенным, тогда, согласно 
лемме \ref{lm:sjf-iss-po}, оно должно предшествовать 
событию чтения в программном порядке, 
то есть $\tup{w, r} \in G.\lPO$.
Следовательно, в структуре событий $S$ также можно выбрать соответствующее событие записи, принадлежащее 
сертификационной ветки $\Br$ и предшествующее событию чтения в рамках программного порядка.

\paragraph{Упорядочивание событий записи.}

Далее опишем, как происходит выбор позиции нового события записи 
в отношении когерентности $S.\lCO$ структуры событий $S$.
Эта позиция выбирается на основе позиции образа данного события в 
в отношении когерентности $G.\lCO$ графа $G$.
Заметим, что из-за наличия конфликтующих событий
можно гарантировать только то, что отношение $S.\lCO$ вложено
в рефлексивное замыкание отношения $G.\lCO$,
то есть выполняется $\fmap{S.\lCO} \subseteq G.\lCO^?$.

\input{Dissertation/fig/lb-sim-ex-travC}

Продемонстрируем это 
на примере шага по переходу из конфигурации $\TC_b$ 
(рисунок~\ref{fig:lb-sim-ex-travB})
в конфигурацию $\TC_c$ 
(рисунок~\ref{fig:lb-sim-ex-travC}),
который покрывает событие $\ese{1}{1}{}$.
Чтобы симулировать этот шаг, строится
структура событий $S_c$, которая содержит новую сертификационную ветку 
$\Br_c \defeq \set{\ese{1}{1}{2}, \ese{1}{2}{2}, \ese{1}{3}{2}}$.

Так как события записи $\ese{1}{2}{1}$ и $\ese{1}{2}{2}$ 
имеют различные метки, они не могут быть объявлены $\lEW$-эквивалентными.
С другой стороны, требуется, чтобы отношение
$S_c.\lCO$ полностью упорядочивало все события записи 
в одну и ту же локацию по модулю $\lEW$-эквивалентных событий.
Это означает, что данную пару событий  необходимо 
упорядочить.
Так как образы этих событий в графе $G$ равны 
(точнее, они равны событию $\ese{1}{2}{}$),
то отношение $G.\lCO$ не может быть использовано
при выборе направления ребра отношения $S_c.\lCO$. 

Отметим, что порядок этих событий не имеет значения, однако 
в целях упрощения доказательства удобнее выбрать такой порядок, 
при котором новые события оказываются упорядочены 
в отношении когеретности раньше других событий.
Таким образом в случае структуры $S_c$ (рисунок~\ref{fig:lb-sim-ex-travC})
выбирается ребро $\tup{\ese{1}{2}{2}, \ese{1}{2}{1}}$.
Благодаря этому можно доказать, что $S.\lCO$ ребро, 
которое оканчивается в событие из новой ветки $\Br_c$,
должно отображаться в ребро $G.\lCO$ в графе $G$, 
то есть $\fmap{S_c.\lCO \seqc [\Br_c]} \suq G.\lCO$.

Рассмотрим также события $\ese{1}{3}{1}$ и $\ese{1}{3}{2}$.
Они имеют одинаковую метку и отображаются в одно и тоже событие $\ese{1}{3}{}$ в графе $G$.
Из этого следует, что эти события могут быть объявлены $\lEW$-эквивалентными.
Более того, их необходимо объявить таковыми,
иначе события ветки $\Br_c$ окажутся невидимыми 
(смотри определение~\ref{def:wkm-cfg}).
Действительно, существует путь 
${S_c.\lCF \cap (S_c.\lJFE \seqc (S_c.\lPO \cup S_c.\lJF)^*)}$
из события $\ese{1}{3}{1}$ в событие $\ese{1}{1}{2}$, 
который и делает события новой сертификационной ветки потенциально невидимыми. 

В общем случае новое событие записи $e$
присоединяется  к классу эквивалентности по отношению $S.\lEW$,
представленному событием $w$, такому, что 
${\ea(w) = \ea(e)}$ и ${w \in X \cap \fcomap{I}}$.
Если такого события $w$ не существует, тогда $e$
упорядочивается в отношении $S.\lCO$ до
множества событий, чьи образы в графе $G.\lCO$-предшествуют $\ea(e)$,
но после событий, чьи образы в графе равны или $G.\lCO$-следуют за $\ea(e)$.
Благодаря свойству \ref{simrel:jfe-iss} отношения симуляции
так построенное отношение $S'.\lEW$ гарантирует,
что все события из новой сертификационной ветки будут видимы. 

\section{Encoding Proof in \coq}

В этом разделе обсуждаются некоторые технические детали 
формализации в системе \coq~\cite{Coq:Weakestmo}
модели \Wkm, а также ряд особенностей   доказательства теоремы о корректности оптимальной схемы 
компиляции из этой модели в модель \IMM. 

Обе формализации выполнены  в системе \coq версии \texttt{8.9.1}
с использованием стандартной библиотеки \coq, 
содержащей необходимые базовые определения и леммы,
например, о целых числах и списках. 
Помимо этого в этих формализациях использовалась библиотека \hahn~\cite{Coq:Hahn}, 
предлагающая богатый набор лемм о множествах и бинарных отношениях,
а также различные тактики для автоматизации доказательств утверждений.
Наконец, для рассуждений о модели \IMM использовалась 
формализация этой модели~\cite{Coq:IMM} в \coq, 
выполненная в рамках работы~\cite{Podkopaev-al:POPL19}.

\coq-репозиторий состоит из следующих частей: формализация модели \Wkm, 
формализация операционной семантики построения структуры событий \Wkm
и формализация доказательства о корректности схемы компиляции

Первая часть расположена в папке \texttt{src/model} и включает в себя 
определение~\ref{def:eventstruct} структуры событий в модели \Wkm
(файл~\texttt{EventStructure.v}), 
определение~\ref{def:wkm-cfg} конфигурации структуры событий 
(файл~\texttt{Execution.v}) 
и определение~\ref{def:es-cons} предиката консистентности структуры событий 
(файл~\texttt{Consistency.v}).
Отметим, что определение структуры событий 
разбито на две части~--- определение самого кортежа,
включающего все компоненты структуры, и определение
предиката \emph{корректности} (well-formedness), 
который кодирует различные ограничения на форму структур событий (например, что отношение $\lJF$ может соединять 
только события записи с событиями чтения).
 
Вторая часть репозитория находится  в папке  \texttt{src/construction} и 
включает формализацию операционной семантики построения структуры событий. 
Следуя определению операционной семантики (рисунок~\ref{fig:wkmo-opsem}), 
в представленной формализации определение отношения перехода операционной семантики 
разбито на несколько более простых отношений, 
каждое из которых отвечает за обновление 
отдельного компонента структуры событий. 

Третья, наиболее объемная часть \coq-репозитория
расположена в папке \texttt{src/compilation} и  
содержит доказательство о корректности оптимальной схемы компиляции. 
Теорема~\texttt{compilation\_correctness} в файле~\texttt{Compilation.v}
репозитория соответствует теореме~\ref{thm:main};
лемма~\texttt{simrel\_init} в файле~\texttt{SimRelInit.v} --- лемме~\ref{lm:simstart},
лемма~\texttt{simrel\_step} в файле~\texttt{SimRelStep.v} --- лемме~\ref{lm:simstep},
а лемма~\texttt{simrel\_extract} в файле~\texttt{Compilation.v} --- лемме~\ref{lm:simend}.
Определение отношения симуляции $\simrel$
содержится в файле~\texttt{SimRel.v} под именем~\texttt{simrel}.

Доказательство леммы \texttt{simrel\_step} заключает в себе 
наиболее сложную часть представленного доказательства корректности. 
Это доказательство строится следующим образом.

При выполнении шага обхода графа $G \vdash \TC \travstep{e} \TC'$,
где событие $e$ принадлежащие потоку с идентификатором $t$ ( то есть $t \defeq G.\lTID(e)$), выполняется построение
\emph{сертификационного графа} $\GCert$.
Этот граф содержит события из потока $t$, 
принадлежащие множеству $C' \cup \dom{G.\lPO^? \seqc [I']}$.
Метки событий этого графа совпадают с метками 
событий графа $G$ на множестве зафиксированных событий $G.D_{\tup{C', I'}}$,
а отношение $\GCert.\lRF$ совпадает с $\lSRF_{\TC'}$.
Определение сертификационного графа, множества зафиксированных 
событий $G.D_{\TC}$, отношений $G.\lVF_{TC}$,  $G.\lSRF_{TC}$ и некоторых других деталей  находятся в файлах \texttt{CertRf.v} и \texttt{CertGraph.v}.

Благодаря свойству восприимчивости 
может быть построена такая трасса в локальной семантике потока $\state \thrdstep{}^* \state'$, что последовательность меток в этой трассе 
совпадает с метками событий в графе $\GCert$.
Далее доказательство проводится индукцией по данной трассе.
При этом в качестве инварианта используется вспомогательное отношение $\simrelcert$ 
(определение \texttt{simrel\_cert} в файле \texttt{SimRelCert.v}).

Это отношение 
включает свойство, утверждающее, что для всех событий, кроме событий из потока $t$,
должно выполняться отношение симуляции $\simrel$ 
для обновленной конфигурации $\TC'$ \footnote{Детальный разбор свойств 
этого отношения может быть найден в \cite[\S A]{Moiseenko-al:ECOOP20}}.
В частности, в качестве базы индукции доказывается,
что верно $\simrel(P, \lTID(P) \setminus \set{t}, G, \TC', S, X)$
(лемма \texttt{simrel\_cert\_start} в файле \texttt{SimRelStep.v}).
В качестве шага индукции доказывается,
что если семантика потока делает шаг $\state \thrdstep{l} \state'$
с меткой $l$, то  в структуру событий может быть добавлено новое событие 
$e$ c такой же меткой $l$, то есть $S \esstepcons{e} S'$, 
и, более того, этот шаг построения сохраняет отношение $\simrelcert$
(лемма \texttt{simrel\_cert\_lbl\_step} в файле \texttt{SimRelCertStepLemma.v}).
Наконец, показывается, что после добавления всех событий 
согласно трассе $\state \thrdstep{l} \state'$ и получения структуры $S'$,
из выполнения свойств отношения $\simrelcert$ следует, 
что выполняется отношение симуляции $\simrel(P, \lTID(P), G, \TC', S', X')$.

\subsection*{Выводы}

Формализация модели \Wkm и доказательства теоремы 
о корректности оптимальной схемы компиляции
помогли убедиться в правильности всех теоретических выкладок,
а также выявили некоторые ошибки в оригинальном определении модели,
приведенном в работе~\cite{Chakraborty-Vafeiadis:POPL19}.

Тем не менее процесс формализации оказался достаточно сложным и трудоемким --- 
итоговый репозиторий содержит около 30 тысяч строк кода на \coq. 
Отметим, что, во многом,  такой большой объем доказательства обосновывается 
сложностью самой модели \Wkm. Как можно видеть, даже 
определение модели (определение~\ref{def:eventstruct})
состоит из нескольких различных отношений и множества ограничений на них.
К сожалению, тот факт, что определение структур событий в модели \Wkm 
содержит множество деталей, специфичных только для области 
слабых моделей памяти, существенно затрудняет переиспользование
полученного кода на \coq для других возможных приложений теории структур событий. 

С целью преодоления этой проблемы в главе~\ref{ch:porf-evenstruct} 
предлагается альтернативная формализация на \coq, 
основанная на классической теории простых структур событий~\cite{Winskel:86}.
Эта теория предоставляет более простую и удобную 
для работы в системе \coq математическую структуру.
Также в данной главе демонстрируется, что некоторый фрагмент 
модели \Wkm может быть вложен в эту теорию.
