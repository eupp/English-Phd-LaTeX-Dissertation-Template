\chapter{Background}
\label{ch:review}

В данной главе приводится введение в предметную область
диссертационного исследования ---
семантику многопоточных программ и слабые модели памяти.
Рассматриваются требования, предъявляемые к моделям памяти,
обсуждаются существующие модели памяти, приводится их классификация.
Рассматриваются недостатки существующих моделей памяти
и открытые  вопросы.
Также вводятся необходимые математические формализмы,
используемые для описания семантики многопоточных программ
и слабых моделей памяти. 

\section{Weak Memory Models}
\label{sec:models-intro}

Напомним, что в контексте данного исследования
моделью памяти называется формальная семантика
многопоточных программ, оперирующих с разделяемой памятью.
В данной работе будут рассмотрены  модели памяти языков программирования 
--- \CPP, \Java и другие. 

Как уже обсуждалось выше, одной из наиболее простых моделей памяти
является модель \emph{последовательной согласованности}
(\emph{sequential consistency})~\cite{Lamport:TC79}.
В рамках данной модели каждый допустимый
сценарий поведения многопоточной программы
является результатом поочередного исполнения
атомарных обращений к разделяемой памяти из параллельных потоков.

Рассмотрим в качестве примера программу, представленную ниже.

\input{Dissertation/fig/dekker-ex}

Данная программа является упрощенной версией
алгоритма блокировки Деккера~\cite{Dijkstra:68}.
В ней два потока соревнуются за доступ к критической секции.
Для того, чтобы обозначить свое намерение войти в критическую секцию, каждый поток устанавливает значение переменной $x$ или $y$ соответственно
\footnote{В данной работе разделяемые переменные
будем обозначать как $x$, $y$, $z$..., 
а локальные переменные как $r_1$, $r_2$, $r_3$...}.
Право войти в критическую секцию получает тот поток, который успеет прочитать значение переменной до его установки другим потоком.

В рамках модели последовательной согласованности
в результате выполнения данной программы 
либо один из потоков прочитает значение~\tcode{1}, а другой~\tcode{0}, 
либо оба прочитают значение~\tcode{1}, и в этом последнем случае ни один из потоков
не войдет в критическую секцию. В результате имеем один из следующих допустимых результатов:
${[r_1=0, r_2=1]}$, ${[r_1=1,r_2=0]}$ или ${[r_1=1,r_2=1]}$. 
Соответствующие сценарии  будем называть 
\emph{последовательно согласованными}.

Алгоритм Деккера полагается на тот факт, что оба 
потока не могут одновременно прочитать значение~\tcode{0}.
В противном случае не гарантируется свойство \emph{взаимного исключения}, 
то есть два потока могут одновременно войти в критическую секцию. 
Тем не менее, если написать эту программу на языке \CLANG, скомпилировать её с помощью \GCC
и запустить  на процессоре семейства \IntelX, то
можно получить следующий результат:  ${[r_1=0,r_2=0]}$.
Подобные сценарии, 
не укладывающиеся в модель последовательной согласованности, 
принято называть \emph{слабыми сценариями}.
Они могут появляться 
в результате выполнения различных оптимизаций 
компилятором при сборке программы или процессором при ее исполнении. 
Например, в случае программы \ref{ex:Dekker}, оптимизатор может выполнить 
\emph{переупорядочивание независимых инструкций} 
записи в переменную $x$ и чтения из переменной $y$ в левом потоке.
Для оптимизированной версии программы сценарий поведения, 
ведущий к результату ${[r_1=0, r_2=0]}$, уже является последовательно согласованным. 
Таким образом, разработчик, использующий многопоточноть, должен знать о возможных контринтуитивных сценариях поведения его программы.   
Для этого современные многопоточные языки программирования 
предоставляют \emph{слабые модели памяти},
то есть формальную спецификацию  поведения многопоточных программ, 
допускающую слабые сценарии поведения,
поскольку более строгая модель последовательной согласованности
запрещает применение широкого спектра оптимизаций
и, следовательно, реализация данной модели на практике
приводит к значительным накладным расходам%
~\cite{Marino-al:PLDI11,Singh-al:ISCA12,Liu-al:OOPSLA17,Liu-al:PLDI19}. 


Таким образом, разработчикам важно понимать, насколько слабую модель памяти
предоставляет используемый ими язык программирования, какие оптимизации 
допускаются этой моделью и какие гарантии 
она предлагает программисту. 

Далее в разделе \ref{sec:models-primitives} 
вводятся программные примитивы для работы с разделяемой памятью. 
В разделе \ref{sec:models-requirements} более подробно обсуждаются 
различные требования, предъявляемые к моделям памяти, 
а в разделе \ref{sec:models-classes} обсуждаются существующие модели и их классификация. 
Наконец в разделе \ref{sec:models-summary} приводится сравнение различных 
классов моделей памяти и обозначаются открытые исследовательские проблемы, 
некоторые из которых были решены в рамках данного 
диссертационного исследования. 

\subsection{Programming Primitives}
\label{sec:models-primitives}

В рамках данного исследования будем считать, что
разделяемая память многопоточной программы является отображением 
адресов переменных\footnote{В данной работе адрес переменной 
также иногда будем называть \emph{локацией}.} в их значения. 
Таким образом, будем подразумевать, 
что разделяемая память состоит из взаимно непересекающихся, 
типизированных адресуемых ячеек памяти%
\footnote{В теории моделей памяти также иногда определяют 
разделяемую память как нетипизированную последовательность байт, 
допускающую обращения \emph{смешанного размера} (\emph{mixed-size accesses}). 
В контексте данной работы смешанные обращения не рассматриваются.}.

Основными операциями, которые предоставляет  разделяемая память, является 
операция записи в разделяемую переменную, а также операция чтения из разделяемой переменной. 
Кроме того, будем считать, что имеются также следующие атомарные операции: 
\emph{чтение-модификация-записи} (\emph{read-modify-write}), 
в частности,  сравнение и замена (\emph{compare-and-swap}, \CAS); 
атомарный обмен (\emph{exchange}, \EXCHG); 
атомарный инкремент (\emph{fetch-and-add}, \FADD).
Операция сравнения и замены атомарно выполняет сравнение 
текущего и ожидаемого значений переменной и в случае 
их совпадения заменяет значение переменной на желаемое.
Операция обмена атомарно заменяет значение переменной 
и возвращает ее прежнее значение. 
Наконец, операция атомарного инкремента прибавляет 
к значению переменной заданную величину и
возвращает ее значение до момента модификации.


Еще одним важным примитивом, 
предоставляемым моделями памяти, является  \emph{барьер памяти} 
(\emph{memory barrier} или \emph{memory fence})---  специальная инструкция, которая 
может быть вставлена в код с целью запретить 
переупорядочивание инструкций и таким образом предотвратить появление слабых сценариев.

Приведенное выше описание примитивов модели памяти 
подытожено в таблице~\ref{table:primitives}. 

\input{Dissertation/fig/primitives}

Отметим также, что модели памяти, как правило, различают 
несколько видов обращений к разделяемой памяти и позволяют 
программисту аннотировать эти обращения 
\emph{режимом доступа} (\emph{access mode}).
Режимы доступа отличаются гарантиями, 
которые они предоставляют. 
Выделяют следующие режимы доступа: 
\emph{неатомарный режим} (\emph{non-atomic}), 
\emph{ослабленный режим} (\emph{relaxed} или \emph{opaque} в терминологии \Java),
режим \emph{захвата} (\emph{acquire}), 
режим \emph{освобождения} (\emph{release}), 
их комбинированный режим \emph{захвата-освобождения} (\emph{acquire-release}), 
а также \emph{последовательно согласованный режим} 
(\emph{sequentially consistent} или \emph{volatile} в \Java).
Эти режимы обозначаются как $\na$, $\rlx$, $\acq$, $\rel$, $\acqrel$ и $\sco$ соответственно.
При этом режим $\acq$ применим только к операциям чтения,
а режим $\rel$ --- только к операциям записи.
Режимы обращения упорядочены по степени предоставляемых гарантий, 
как показано на следующей диаграмме. 

\input{Dissertation/fig/modes}

Неатомарные обращения, аннотированные режимом $\na$, 
не предназначены для конкурентного доступа 
к разделяемой переменной из параллельных потоков программы. 
В зависимости от конкретного языка программирования
конкурентные неатомарные обращения либо полностью запрещены
(например, в \Haskell~\cite{Vollmer-al:PPoPP17} и \Rust~\cite{RustBook:19}), 
либо могут приводить к неопределенному поведению
(например, в \CPP~\cite{Batty-al:POPL11}),
либо не предоставляют  гарантий порядка,
в котором потоки могут наблюдать эти обращения
(например, в \Java~\cite{Manson-al:POPL05}). 

Для ослабленных обращений, аннотированных режимом $\rlx$, 
как правило, гарантируется только выполнение свойства 
\emph{когерентности}~\cite{Alglave-al:TOPLAS14}.
Это свойство обеспечивает \emph{последовательную согласованность 
по каждой отдельной локации в памяти}.
Из этого следует, что программа, 
состоящая из ослабленных обращений к единственной переменной, 
допускает только последовательно согласованные сценарии исполнения.

Обращения, аннотированные режимами захвата $\acq$ и освобождения $\rel$,
используются для поддержки идиомы передачи сообщений~\cite{Lahav-al:POPL16}.
Поток, выполняющий отправку сообщения, должен аннотировать соответствующую 
операцию записи в разделяемую память режимом доступа $\rel$. Поток, ожидающий данное сообщение, должен иметь 
операцию чтения, аннотированную режимом доступа $\acq$.

Наконец, последовательно согласованные обращения (аннотированные режимом $\sco$) 
при правильном использовании гарантируют 
семантику последовательной согласованности%
~\cite{Boehm-Adve:PLDI08, Lahav-al:PLDI17}.

\subsection{Requirements to the Memory Models}
\label{sec:models-requirements}

Как было показано выше, при обсуждении  алгоритма Деккера, 
разрабатывая  многопоточные программы, необходимо 
учитывать модель памяти, предоставляемую соответствующим языком программирования.
При этом следует иметь в виду, что к моделям памяти предъявляются противоречивые требования. 
С одной стороны, более строгая модель допускает меньше сценариев поведения 
и предоставляет больше гарантий разработчику.
С другой стороны, более слабая модель позволяет выполнять большее количество  оптимизаций, 
что приводит к повышению производительности программы. 
Таким образом, при создании модели памяти необходимо 
найти сбалансированный  компромисс между этими конфликтующими запросами.

В этом разделе будет  детально описан 
набор типовых требований, предъявляемых 
к моделям памяти языков программирования. 

\subsubsection*{Optimalality and Soundness of Compilation Scheme}

\emph{Схема компиляции} --- это  отображение
примитивов языка программирования в инструкции 
языка ассемблера конкретного семейства процессоров.
Будем считать, что и высокоуровневый язык программирования, и 
язык ассемблера в данном случае предоставляют одинаковый 
набор программных примитивов, описанных в разделе \ref{sec:models-primitives}.

\emph{Оптимальная} схема компиляции позволяет 
компилировать команды обращения к разделяемой памяти 
из языка программирования в инструкции целевого процессора
без необходимости вставки барьеров памяти и 
без усиления режима доступа обращений. 
Другими словами, наличие у языка программирование оптимальной схемы компиляции
позволяет компилировать программы на этом языке в эффективный код соответствующего целевого процессора.  
Напротив, использование неоптимальных схем компиляции
может приводить к снижению производительности кода
из-за вставки многочисленных барьеров.
В то же время  барьеры могут предотвратить появление слабых сценариев поведения, 
допустимых  архитектурой процессора. 

\emph{Корректность} схемы компиляции гарантирует,
что множество сценариев поведения, допустимых моделью памяти процессора 
для скомпилированной программы,  
является подмножеством сценариев поведения исходной программы, 
допустимой моделью памяти языка программирования. 

Рассмотрим следующий пример. 
Программа \ref{ex:sb} является 
упрощенным вариантом алгоритма Деккера: 

\begin{equation*}
\inarrII{
   \writeInst{}{x}{1}   \\
   \readInst{}{r_1}{y}  \\
}{
  \writeInst{}{y}{1}   \\
  \readInst{}{r_2}{x}  \\
}
\tag{SB}\label{ex:sb}
\end{equation*}

Допустим, что язык программирования должен обеспечивать
последовательно согласованную модель памяти и 
поддерживать компиляцию в ассемблерный код процессоров семейства \IntelX.

Рассмотрим схему компиляции, которая 
компилирует инструкции чтения и записи 
разделяемых переменных в инструкцию \texttt{MOV}%
\footnote{В архитектуре \IntelX инструкция \texttt{MOV} 
используется также для обычного чтения значения из памяти по адресу  
и для записи значения по адресу в память.}. 
Такая схема компиляции является оптимальной, 
так как она не вставляет дополнительных барьеров памяти
и не усиливает режимы доступа обращений к памяти. 
Однако данная схема не является корректной, так как
спецификации модели памяти~\IntelX, в частности, 
допускает для программы \ref{ex:sb} сценарий исполнения 
с результатом ${[r_1=0, r_2=0]}$, который 
не является последовательно согласованным.
Данный результат может появиться вследствие 
\emph{буферизации операций записи} --- 
операция записи ${\writeInst{}{x}{1}}$ может быть исполнена процессором после выполнения всех остальных инструкций программы.

Рассмотрим другую схему компиляции, 
которая вставляет инструкцию \texttt{mfence}
%% \footnote{В архитектуре \IntelX инструкция \texttt{mfence} 
%% является барьером памяти.}. 
после каждой операции записи%
~\cite{Sewell-al:CACM10, Batty-al:POPL11}.
Инструкция \texttt{mfence} является специальным барьером памяти 
в системе команд процессоров \IntelX, и 
ее выполнение  приводит к сбросу буфера записей в основную память. 
Для программы \ref{ex:sb}, скомпилированной таким способом,
результат ${[r_1=0, r_2=0]}$ невозможен в \IntelX. 
Таким образом, альтернативная схема компиляции 
является корректной, но не оптимальной%
\footnote{На практике использование данной схемы 
компиляции может приводить к замедлению 
на 10-30\%~\cite{Marino-al:PLDI11, Liu-al:OOPSLA17}.}. 

К сожалению, модель последовательной согласованности 
не обладает оптимальной и корректной схемой компиляции 
для современных мультипроцессоров семейств 
\IntelX, \ARM и \POWER.
Это является одной из причин ослабления моделей памяти в
высокопроизводительных языках программирования. 

\subsubsection*{Soundness of Program Transformations}

Другим важным требованием к моделям памяти 
является корректность трансформаций исходного кода, 
то есть правил преобразования исходного кода, 
применяемых компилятором при оптимизации программ. \emph{Корректность} трансформации гарантирует,
что множество сценариев поведения программы, 
полученной после применения трансформации, 
является подмножеством допустимых сценариев 
поведения оригинальной программы.

Возвращаясь к программе \ref{ex:sb},
вновь рассмотрим модель последовательной согласованности 
и трансформацию \emph{перестановки независимых инструкций}.
Допустим, что данная трансформация применяется к левому потоку 
и переставляет местами операции записи и чтения,
как показано ниже. 

\bigskip

\begin{minipage}{0.42\linewidth}
\begin{equation*}
\inarrII{
   \writeInst{}{x}{1}   \\
   \readInst{}{r_1}{y}  \\
}{
  \writeInst{}{y}{1}   \\
  \readInst{}{r_2}{x}  \\
}
% \tag{SB}\label{ex:sb-src}
\end{equation*}
\end{minipage}\hfill%
\begin{minipage}{0.05\linewidth}
\Large~\\ $\leadsto$
\end{minipage}\hfill%
\begin{minipage}{0.42\linewidth}
\begin{equation*}
\inarrII{
   \readInst{}{r_1}{y}  \\
   \writeInst{}{x}{1}   \\
}{
  \writeInst{}{y}{1}   \\
  \readInst{}{r_2}{x}  \\
}
% \tag{SBtr}\label{ex:sb-tgt}
\end{equation*}
\end{minipage}

\bigskip

Для исходной версии программы (слева), 
результат $[r_1=0, r_2=0]$ \textbf{не является} 
последовательно согласованным, но для трансформированной 
версии программы этот результат уже \textbf{является} 
последовательно согласованным. 
Таким образом, можно сделать вывод, что перестановка независимых инструкций 
не является корректной трансформацией с точки зрения 
модели последовательной согласованности. 

В теории моделей памяти рассматривается вопрос корректности 
широкого набора базовых трансформаций.
Подробный список этих трансформаций с пояснениями 
может быть найден в ~\cite{Moiseenko-al:PCS21}.
В данной работе будут обсуждаться только некоторые 
конкретные трансформации, которые будут вводиться по мере необходимости. 

\subsubsection*{Data Race Freedom Guarantees}

Базовая гарантия, ожидаемая от модели памяти, 
заключается в том, чтобы для программ, не содержащих \emph{гонок по данным}%
\footnote{Напомним, что гонкой по данным (data race) называется пара конкурентных (из разных потоков)
обращений к одной и той же разделяемой переменной,
причём минимум одно из этих обращений является операцией записи.}, 
допускались только последовательно согласованные сценарии исполнения. 
Это свойство также называется \emph{свободой от гонок}~\cite{Manson-al:POPL05}
(data race freedom, \DRF).

Более формально, утверждается, 
что слабая модель памяти $M$ удовлетворяет свойству \DRF, если для любой программы $P$, которая не содержит 
гонок ни в одном последовательно согласованном сценарии исполнения,
модель $M$ допускает только последовательно согласованном сценарии%
\footnote{Свойство свободы от гонок в приведенной выше формулировке
также называется \DRFM{SC} по названию модели памяти 
sequential consistency. 
Можно также рассматривать свойство \DRF от другой 
произвольной модели $\mathsf{M}$, в этом случае такое 
свойство называется \DRFM{M}.}.

Таким образом, свойство \DRF позволяет свести рассуждения о поведении 
многопоточной программы в слабой модели к рассуждению о поведении 
этой же программы в более простой модели последовательной согласованности.
Для этого достаточно показать, что программа не имеет гонок в модели последовательной согласованности. 

\subsubsection*{Speculative Execution}

Еще одним важным свойством модели памяти является  наличие/отсутствие у нее возможности спекулятивного исполнения.
Рассмотрим еще один пример. 

\bigskip

\begin{equation*}
\inarrII{
  \readInst{}{r_1}{x}   \\
  \writeInst{}{y}{1}    \\
}{
  \readInst{}{r_2}{y}   \\
  \writeInst{}{x}{1}    \\
}
\tag{LB}\label{ex:lb-spec}
\end{equation*}

\bigskip

Некоторые модели памяти, в частности, 
модели семейств мультипроцессоров \ARM и \POWER,
допускают для данной программы сценарий поведения, 
приводящий к результату ${[r_1=1, r_2=1]}$, хотя данный результат не может быть получен 
путем исполнения инструкции согласно их 
порядку внутри потоков (\emph{in-order execution}).
Для того, чтобы получить этот результат, необходимо 
использовать \emph{спекулятивное исполнение}
(\emph{speculative execution})~\cite{Boudol-Petri:ESOP10,Boehm-Demsky:MSPC14}:
например, данный результат можно получить, если 
буферизировать операцию чтения $\readInst{}{r_1}{x}$ в левом потоке
и исполнить инструкцию записи $\writeInst{}{y}{1}$ вне очереди%
\footnote{Из этого происходит название приведенной программы --- 
буферизация операции чтения (\emph{load buffering}, \ref{ex:lb-spec})}.

Важно отметить, что неограниченное использование 
спекулятивного исполнения может привести к нежелательным последствиям. 
Рассмотрим следующий пример.

\bigskip

\begin{equation*}
\inarrII{
  \readInst{}{r_1}{x}   \\
  \writeInst{}{y}{r_1}  \\
}{
  \readInst{}{r_2}{y}   \\
  \writeInst{}{x}{r_2}  \\
}
\tag{LB+dep}\label{ex:lb+dep-spec}
\end{equation*}

\bigskip

Сценарий исполнения, в котором сначала происходит 
спекулятивное исполнение операции записи 
в переменную \tcode{y} значения \tcode{1} в левом потоке, 
затем чтение этого значения и его запись в переменную \tcode{x}
в правом потоке, а затем вновь чтение его обратно в левом потоке, 
ведет к циклу причинно-следственных связей 
и неожиданному результату ${[r_1=1, r_2=1]}$, которые являются примером  \emph{значений из воздуха} 
(\emph{out of thin-air})~\cite{Batty-al:ESOP15}.
Для того, чтобы запретить сценарии, приводящие к   значениям 
из воздуха, модель памяти должна ограничивать использование
спекулятивного исполнения. 
Более подробно возможные решения этой проблемы 
обсуждаются в разделах \ref{sec:models-classes}, 
\ref{sec:exec-graphs} и \ref{sec:wkmo-eventstruct}.

\subsubsection*{Automated Formal Verification}

Многопоточные программы являются источниками нетривиальных
трудновоспроизводимых ошибок. 
Тестирование многопоточных программ, как правило, 
оказывается недостаточно эффективным  из-за их недетерминированного 
поведения.
В контексте слабых моделей памяти эта проблема встает еще более остро 
из-за  слабых сценариев поведения. 

По этой причине крайне актуальной является
разработка средств автоматической верификации программ, 
например, методом проверки моделей~\cite{Baier:2008},
которые бы учитывали слабые сценарии поведения.
Однако для некоторых моделей памяти проблема верификации 
оказываются  вычислительно сложной 
в виду очень большого пространства возможных состояний. 
В частности, процесс верификации может быть существенно затруднен, 
если модель памяти допускает спекулятивное исполнение.
Более подробно эта проблема обсуждается в разделе \ref{sec:models-classes}.  

\subsection{Classes of Memory models}
\label{sec:models-classes}

Слабые модели памяти языков программирования 
можно разбить на несколько классов в зависимости от их свойств: наличие 
 оптимальной схемы компиляции, 
поддерживаемых трансформаций и предоставляемых гарантий. 

Согласно классификации, представленной в работе~\cite{Moiseenko-al:PCS21}, будем рассматривать четыре класса моделей памяти,: 
\begin{itemize}
  \item \emph{модели, сохраняющие программный порядок}
        (program order preserving models); 
  \item \emph{модели, сохраняющие синтаксические зависимости} 
        (syntactic dependency preserving models);
  \item \emph{модели, сохраняющие семантические зависимости} 
        (semantic dependency preserving models);
  \item \emph{модели, допускающие значения из воздуха} (out of thin-air models).
\end{itemize}

 

Продемонстрируем разницу между этими классами, 
 используя  следующие вариации программы 
буферизации операции чтения: 

\input{Dissertation/fig/lb-ex}

\subsubsection*{Program Order Preserving Memory Models}

В таких  моделях 
эффекты от выполнения обращений к разделяемой памяти в потоках 
происходят согласно их \emph{программному порядку},
то есть в линейном порядке, в котором соответствующие 
инструкции обращения к памяти расположены в тексте программы%
\footnote{Заметим, что при этом данный класс моделей 
все же позволяет операциям чтения наблюдать ``устаревшие'' значение, 
в отличие от модели последовательной согласованности.}. 
Другими словами, в рамках данных моделей запрещено 
спекулятивное исполнение. 
Модели памяти, принадлежащие к этому классу, 
запрещают сценарий поведения с результатом ${[r_1=1,r_2=1]}$
для всех трех программ \ref{ex:lb-nodep}, \ref{ex:lb-fakedep} и \ref{ex:lb-dep}.

Модели памяти, сохраняющие программный порядок, 
предоставляют значительные  гарантии  поведения программ. 
В частности, они обладают свойством свободы от гонок \DRF, 
запрещают спекулятивное исполнение и, следовательно, 
в них не может быть значений из воздуха~\cite{Lahav-al:PLDI17}. 
Также для данного класса моделей разработаны эффективные 
алгоритмы автоматической верификации 
методом проверки моделей~\cite{Kokologiannakis-al:POPL2017, Kokologiannakis:PLDI2019}.
С другой стороны, данный класс моделей не поддерживает
оптимальную схему компиляции в модели мультипроцессоров
\ARM и \POWER, а также не поддерживает трансформацию 
перестановки операции чтения после независимой
от нее операции записи (\emph{load/store reordering}). 

К данному классу относятся 
 следующие модели: известная  модель~\RCMM~\cite{Lahav-al:PLDI17}, 
покрывающая подмножество сценариев поведения, допустимых моделью памяти языка \CLANG;
 модель \TSO процессоров семейства \Intel~\cite{Sewell-al:CACM10}; 
модель последовательной согласованности (sequential consistency)~\cite{Lamport:TC79}; модель
причинной согласованности (causal consistency)~\autocite{Lahav-Boker:PLDI2020}; 
модель  согласованности в конечном счёте (eventual consistency)~\cite{Jagadeesan-al:ESOP2018};
 модель памяти языка \OCaml~\cite{Dolan-al:PLDI18}.

\subsubsection*{Syntactic Dependency Preserving Models}

Эти модели ослабляют требование линейности программного порядка 
и вводят отношение частичного порядка --- \emph{сохраняемый программный порядок}. 
Операции обращения к разделяемой памяти из одного и того же потока
находятся в отношении сохраняемого программного порядка, 
если между соответствующими им инструкциями есть 
\emph{синтаксические зависимости}, например, 
\emph{зависимость по данным} или \emph{по управлению}. 

Например, в программе \ref{ex:lb-nodep} между инструкциями в 
левом потоке нет синтаксической зависимости, 
поэтому эти инструкции могут быть выполнены в произвольном порядке. 
Следовательно, модель памяти, сохраняющая синтаксические зависимости, 
допускает сценарий поведения с результатом ${[r_1=1,r_2=1]}$. 
Однако данный результат запрещен для программ 
\ref{ex:lb-dep} и \ref{ex:lb-fakedep}, 
поскольку в этих программах в обоих потоках существует зависимость 
между инструкциями. 

Модели данного класса поддерживают оптимальные схемы компиляции
в модели современных мультипроцессоров. 
В отличие от моделей, сохраняющих программный порядок, 
данный класс моделей допускает перестановку 
инструкции чтения после независящей от нее инструкции записи. 
Но при этом данный класс запрещает множество других трансформаций,
которые могут удалять синтаксические зависимости между инструкциями. 
Примером такой трансформации является \emph{свертка констант}~\cite{Muchnick:ACDI97}.
Например, в случае программы~\ref{ex:lb-fakedep}
свертка констант может преобразовать инструкцию 
$\writeInst{}{y}{1 + a * 0}$ в инструкцию $\writeInst{}{y}{1}$, 
удалив зависимость от предшествующей инструкции чтения $\readInst{}{a}{x}$.
После применения этой трансформации сценарий поведения с результатом ${[r_1=1,r_2=1]}$
становится допустимым.  

Модели памяти, сохраняющие синтаксические зависимости, 
предоставляют более слабые гарантии по сравнению с 
моделями, сохраняющими программный порядок. 
Эти модели все еще обладают свойством свободы от гонок (\DRF), 
но в отличие от моделей предыдущего класса 
допускают спекулятивное исполнение 
синтаксически независимых инструкций. 
Тем не менее для данного класса моделей  
существуют  эффективные алгоритмы автоматической верификации 
методом проверки моделей%
~\cite{Abdulla-al:CAV2016,Pulte-al:PLDI2019,Kokologiannakis-Vafeiadis:ASPLOS2020}.

Модели, сохраняющие синтаксические зависимости,
не используются  для
языков программирования, потому что  запрещают применение широкого 
класса трансформаций (например, свертку констант).  
Вместе с тем, большинство моделей современных мултьтипроцессоров, 
например, \ARM~\cite{Pulte-al:POPL18} и \POWER~\cite{Sarkar-al:PLDI11}, 
попадают именно в этот класс. 
Также к данному классу относится 
модель памяти ядра \Linux~\cite{Alglave-al:ASPLOS18}

\subsubsection*{Semantic Dependency Preserving Models}

Эти модели, вместо синтаксических зависимостей между операциями, отслеживают 
\emph{семантические зависимости}.
Например, в случае программы \ref{ex:lb-fakedep} можно сказать,
что хотя между инструкциями $\readInst{}{a}{x}$ и $\writeInst{}{y}{1 + a * 0}$
есть синтаксическая зависимость, семантический они являются независимыми,
так как на самом деле записываемое значение $1 + a * 0$
не зависит от значения $a$, прочитанного первой инструкцией.
Таким образом, модели данного класса допускают
сценарий исполнения с результатом ${[r_1=1,r_2=1]}$ для программ
\ref{ex:lb-nodep} и \ref{ex:lb-fakedep}, но не для \ref{ex:lb-dep}.

Модели памяти, сохраняющие семантические зависимости,
поддерживают оптимальные схемы компиляции и
применение широкого класса различных трансформаций программ.
В то же время данные модели предоставляют гарантию \DRF,
но также допускают спекулятивное исполнение.
Модели данного класса используют различные
концептуально сложные формализмы, чтобы  строго определить  семантические зависимости между операциями.
Эта приводит к тому,
что автоматическая верификация программ в этих моделях существенно затруднена.

К данному классу относятся различные модели,
предложенные в качестве моделей памяти для
языков \CPP и \Java, в частности, модели
\Prm~\cite{Kang-al:POPL17},
\Wkm~\cite{Chakraborty-Vafeiadis:POPL19}, 
\PwP~\cite{Jagadeesan-al:OOPSLA2020}
и ряд других~\cite{Jeffrey-Riely:LICS16,PichonPharabod-Sewell:POPL16,Paviotti-al:ESOP20}.

\subsubsection*{Out-of-Thin-Air Models}

Такие модели допускают сценарий исполнения с результатом ${[r_1=1,r_2=1]}$
для всех трех программ \ref{ex:lb-nodep}, \ref{ex:lb-fakedep} и \ref{ex:lb-dep}.

Модели данного класса предоставляют оптимальные схемы компиляции и
допускают применение широкого класса различных трансформаций программ.
Однако ценой этого оказывается появление значений из воздуха, что препятствует как неформальному,
так и строго формальному рассуждению о поведении программ,
приводит к нарушению гарантии \DRF и невозможности
построения каких-либо инструментов верификации программ%
~\cite{Boehm-Demsky:MSPC14, Batty-al:ESOP15}. 

Все эти недостатки 
привели к следующему консенсусу в исследовательском сообществе:
модели, допускающие значения из воздуха,
не подходят на роль моделей памяти 
для языков программирования.
Тем не менее отметим, что первоначальная версия модели памяти для языков \CPP
допускала значения из воздуха~\cite{Batty-al:POPL11}.

\subsection{Comparison of Memory Models and Open Problems}
\label{sec:models-summary}

Таблица~\ref{table:models-classes} резюмирует 
анализ классов моделей памяти, приведенный выше.

\input{Dissertation/memory-models-table}

Можно видеть, что модели памяти,
сохраняющие программный порядок или синтаксические зависимости, 
предоставляют набор базовых гарантий о поведении программ, 
который включает свойство \DRF. Также для моделей данных классов 
доступны средства автоматической верификации.
%% ~\cite{Abdulla-al:CAV2016,Pulte-al:PLDI2019,Kokologiannakis-al:POPL2017,
%% Kokologiannakis:PLDI2019,Kokologiannakis-Vafeiadis:ASPLOS2020}.
Однако использование моделей данного класса влечет 
дополнительные накладные расходы на время исполнения программ 
из-за того, что они не поддерживают оптимальные схемы компиляции
и/или некоторые важные трансформации программ.
В дополнение к этому отметим, что модели,
сохраняющие синтаксические зависимости, используют спекулятивное исполнение, 
что приводит к увеличению их концептуальной сложности  
и росту числа допустимых сценариев исполнения программ. 

С другой стороны, модели, допускающие значения из воздуха, 
поддерживают оптимальные схемы компиляции и широкий спектр 
трансформации программ, но для них затруднены 
формальные рассуждения. 

Модели, сохраняющие семантические зависимости, стремятся 
разрешить это противоречие, и, с одной стороны, 
поддержать оптимальные схемы компиляции и широкий спектр 
трансформаций программ, а, с другой стороны, 
гарантировать отсутствие значений из воздуха 
и предоставить разумный набор гарантий о поведении программ.
Это достигается  с помощью использования различных 
сложных формализмов, позволяющих получить строгие определения
семантических зависимостей между операциями.
Концептуальная сложность моделей данного класса, 
а также значительное количество допустимых сценариев поведения программ,
приводит к тому, что проблема построения эффективных 
средств автоматической верификации программ в 
моделях памяти данного класса до сих пор не была изучена. 

Данное диссертационное исследование посвящено исследованию модели \Wkm~\cite{Chakraborty-Vafeiadis:POPL19}
(список ее свойств  приводится в таблице \ref{table:models-classes}), 
которая принадлежит классу моделей, сохраняющих семантические зависимости. При этом уделяется внимание 
формализации модели, а также разработке средств верификации
многопоточных программ относительно этой модели. 

\section{Formal Semantics of Concurrent Programs and Memory Models}

В этом разделе описаны различные формализмы,
применяемые для задания семантики многопоточных программ и моделей памяти и используемые в данном исследовании.
В разделе~\ref{sec:lts} дано определение \emph{систем помеченных переходов}
и \emph{операционных семантик с чередованием} 
(interleaving operational semanitcs).
В разделе~\ref{sec:pomsets-eventstruct} приводится альтернативный способ
задания семантики многопоточных программ без чередования 
(non-interleaving) 
с помощью семантических доменов
\emph{истинной конкурентности} (true concurrency)%
~\cite{Nielsen-al:1981,Pratt:CONCUR84,Nielsen:REX93,Sassone:MFCS1993}.
А именно, кратко описаны \emph{языки частично упорядоченных мультимножеств},
также известные как \emph{языки помсетов} (pomset languages), и \emph{структуры событий}.
В разделе~\ref{sec:exec-graphs} вводится понятие графов сценариев исполнения
и аксиоматических моделей памяти, а также приводится краткое сравнение
графов сценариев исполнения и частично упорядоченных мультимножеств.
Наконец, в разделе~\ref{sec:wkmo-eventstruct} вводится
специальный тип структур событий, используемых в модели \Wkm.

\subsection{Labelled Transition Systems}
\label{sec:lts}

Данный формализм является традиционным 
способом задания операционной семантики программ. 
Системы помеченных переходов --- это  граф (потенциально бесконечный), 
вершины которого представляют внутреннее состояния программы, а
ребра соответствуют выполнению шага вычислений. 
Метка ребра задает видимый эффект выполнения данного шага вычислений.

\begin{definition}
  \label{def:lts}
  \emph{Система помеченных переходов} является тройкой
    $\LTS \defeq \tup{\StateType, \LabelType, \TrRel}$, компоненты которой заданы следующим образом: 
  \begin{itemize}
    \item $\StateType$ --- множество состояний;
    \item $\LabelType$ --- множество меток, также называемое \emph{алфавитом};
    \item $R \subseteq L \times S \times S$ ---  помеченное отношение перехода.
  \end{itemize}
\end{definition}

Для обозначения  перехода между состояниями используется следующая нотация:
\[
\begin{array}{lcr@{\hspace{3em}}lcr}
  \ltr[R]{\ell}{s}{s'} & \defeq & \step{\ell}{s}{s'} \in \TrRel,                     &
  \tr[R]{s}{s'}        & \defeq & \exists \ell \ldotp \step{\ell}{s}{s'} \in \TrRel. \\
\end{array}
\]

\begin{definition}
  \label{def:lts-trace}
  \emph{Трассой} помеченной системой переходов называется чередующаяся последовательность  
  состояний $s_0, s_1, \ldots, s_n \in \LabelType$ 
  и меток $\ell_1, \ldots, \ell_n \in L$ 
  такая, что выполняется следующее условие:
  $$s_0 \xrightarrow{\ell_1} s_1 \xrightarrow{\ell_2} s_2 \xrightarrow{\ell_3} \ldots \xrightarrow{\ell_n} s_n.$$
\end{definition}

\begin{definition}
  \label{def:lts-lang}
  \emph{Язык, принимаемый системой переходов в начальном состоянии $s_0$} ---
  это множество последовательностей слов над алфавитом $\LabelType$ 
  таких, что для каждого слова существует соответствующая 
  трасса, начинающаяся в $s_0$:
  $$ \langof{\LTS, s_0} \defeq \set{ 
      \ell_1 \ldots \ell_n ~|~ \exists s_1, \ldots, s_n \ldotp 
       s_0 \xrightarrow{\ell_1} s_1 \xrightarrow{\ell_2} \ldots \xrightarrow{\ell_n} s_n
     }. 
  $$
\end{definition}
  
\input{Dissertation/fig/lts-lang-ex}

На рисунке~\ref{fig:lts-ex} показан пример системы помеченных переходов, 
а на рисунке~\ref{fig:lang-ex} --- пример языка, 
принимаемого этой системой в состоянии $s_0$.

В рамках  операционной семантики с чередованием
(interleaving semantics) поведение многопоточной программы
определяется как поочередное исполнение атомарных действий параллельных потоков.

\begin{definition}
  \label{def:lts-par}
  \emph{Параллельной композицией двух систем переходов} $\LTS_1$ и $\LTS_2$
  будем называть систему переходов
  $\parlts{\LTS_1}{\LTS_2} \defeq \tup{\StateType_1 \times \StateType_2, \LabelType, \TrRel_{\parSymb}},$
  где $\TrRel_{\parSymb}$ определяется следующим образом:
  \begin{itemize}
    \item $\ltr[\TrRel_1]{\ell}{s_1}{s'_1}$ влечет
          $\ltr[\TrRel_{\parSymb}]{\ell}{\tup{s_1, s_2}}{\tup{s'_1, s_2}}$,
    \item $\ltr[\TrRel_2]{\ell}{s_2}{s'_2}$ влечет
          $\ltr[\TrRel_{\parSymb}]{\ell}{\tup{s_1, s_2}}{\tup{s_1, s'_2}}$.
  \end{itemize}
\end{definition}

Если при этом потоки имеют доступ к общему ресурсу 
(например, к разделяемой памяти), то 
семантику этого ресурса можно также задать с помощью системы переходов,
а затем рассмотреть произведение параллельной композиции потоков и ресурса.  

\begin{definition}
  \label{def:lts-par}
  \emph{Произведением двух систем переходов} $\LTS_1$ и $\LTS_2$
  будем называть систему
  $\prodlts{\LTS_1}{\LTS_2} \defeq \tup{\StateType_1 \times \StateType_2, \LabelType, \TrRel_{\prodSymb}},$
  где $\TrRel_{\prodSymb}$ определяется так:
  \begin{itemize}
    \item $\ltr[\TrRel_{\prodSymb}]{\ell}{\tup{s_1, s_2}}{\tup{s'_1, s'_2}}$ 
      тогда и только тогда, когда 
      $\ltr[\TrRel_1]{\ell}{s_1}{s'_1}$ и $\ltr[\TrRel_2]{\ell}{s_2}{s'_2}$.
  \end{itemize}
\end{definition}

Таким образом, если система помеченных переходов $\LTS_{\thrdSymb}$ 
задает семантику потоков, а система $\LTS_{\resSymb}$ --- 
семантику разделяемого ресурса, тогда 
$(\LTS_{\thrdSymb} \parSymb \dots \parSymb \LTS_{\thrdSymb}) \prodSymb \LTS_{\resSymb}$
задает семантику всей системы, состоящей из $n$ потоков и разделяемого ресурса.

\subsection{Pomset Languages and Prime Event Structures}
\label{sec:pomsets-eventstruct}

Операционные семантики с чередованием являются 
простым и интуитивно понятным способом для моделирования
многопоточных программ. Однако недостаток этого подхода заключается в том, 
что с ростом программы экспоненциально растет количество трасс, 
допустимых операционной семантикой. 

Для решения этой проблемы исследователями 
были предложены различные альтернативные 
подходы к заданию семантики многопоточных программ, 
которые позволяют более компактно представить пространство 
возможных сценариев поведения. 
Данный класс семантик принято называть 
\emph{семантиками без чередования} (non-interleaving semantics)
или также \emph{истинно конкурентными семантиками}
(true concurrent semantics)~\cite{Nielsen:REX93}.
Из данного класса семантик в рамках 
данной диссертации особый интерес представляют 
\emph{языки частично упорядоченных мультимножеств}
(кратко --- языки помсетов)~\cite{Pratt:CONCUR84,Gischer:TCS88} 
и \emph{структуры событий}~\cite{Winskel:86}.

Языки помеченных частично упорядоченных множеств является
обобщением понятия обычных ``последовательных'' языков. 
Обобщение заключается в переходе от линейного порядка 
на символах алфавита в рамках слова к частичному порядку.
Частично упорядоченное множество соответствует одному
сценарию исполнения многопоточной программы.
Элементы этого множества представляют
атомарные шаги вычисления и называются \emph{событиями}.
Каждому событию ставится в соответствие семантическая \emph{метка} ---
символ заданного алфавита.
Если событие $e_1$ происходит до события ~$e_2$ (обозначается как $e_1 \ca e_2$), 
то считается, что событие~$e_2$ в
сценарии исполнения программы зависит от события~$e_1$.
Если не выполняется ни $e_1 \ca e_2$, ни $e_2 \ca e_1$, 
тогда события $e_1$ и $e_2$ считаются параллельными (обозначается как 
$e_1 \co e_2$). 

\begin{definition}
  \label{def:lposet}
  \emph{Помеченное частично упорядоченное множество} над множеством меток $\LabelType$ является
  тройкой $\tup{\Event, \lab, \ca}$, компоненты 
  которой заданы так:
  \begin{itemize}
    \item $\Event$ ---  \emph{множество событий;}
    \item $\lab : \Event \fun \LabelType$ \emph{ ---  функция разметки событий;}
    \item $\ca \subseteq \Event \times \Event$ --- частичный порядок 
      \emph{причинно-следственной связи} между событиями. 
  \end{itemize}
\end{definition}

Множество всех помеченных частично упорядоченных множеств над алфавитом $\LabelType$
будем обозначать как $\lPoset[\LabelType]$. 

Отметим, что при работе c помеченными частично упорядоченными множествами
конкретные идентификаторы событий, как правило, неважны,
важна лишь их разметка и отношение причинно-следственной связи между ними.
Таким образом, с помеченными частично упорядоченными множествами 
работают по модулю переименования событий, то есть с точностью до изоморфизма.

Рассмотрим $p, q \in \lPoset[\LabelType]$. Функция $f : E_p \fun E_q$ называется:
\begin{itemize}
  \item \emph{сохраняющей метки}, если ${\lab_q(f(e)) = \lab_p(e)}$;
  \item \emph{сохраняющей порядок}, если ${e_1 \ca_p e_2}$ влечет ${f(e_1) \ca_q f(e_2)}$;
  \item \emph{вкладывающей порядок}, если ${e_1 \ca_p e_2}$ тогда и только тогда, когда ${f(e_1) \ca_q f(e_2)}$.
\end{itemize}

\begin{definition}
  \label{def:lposet-hom}
  \emph{Гомоморфизмом} частично упорядоченных помеченных множеств называется
  функция, сохраняющая метки и порядок. 
\end{definition}

\begin{definition}
  \label{def:lposet-iso}
  \emph{Изоморфизмом} частично упорядоченных помеченных множеств называется
  биективная функция, сохраняющая метки и вкладывающая порядок. 
\end{definition}

\begin{definition}
  \label{def:lposet-subs}
  Будем говорить, что частично упорядоченные помеченные множества
  $p$ и $q$ \emph{изоморфны} ( обозначается как $p \iso q$),
  если существует изоморфная функция между ними.
\end{definition}

\begin{definition}
  \label{def:pomset}
  \emph{Помеченные частично упорядоченные мультимножества}
  или кратко \emph{помсеты} (от англ. partially ordered multiset, pomset) --- 
  это классы помеченных частично упорядоченных множеств по модулю изоморфизма: 
  $${\Pom[\LabelType] \defeq \lPoset[\LabelType] / {\iso}}.$$ 
\end{definition}

\begin{definition}
  \label{def:pomset}
  \emph{Язык помсетов} --- это множество помсетов: 
  $${\Pomlang[\LabelType] \defeq \pwset{\Pom[\LabelType]}}.$$ 
\end{definition}

\input{Dissertation/fig/pom-es-ex}

На рисунке~\ref{fig:pom-ex} представлен пример языка помсетов. 
Данный язык помсетов кодирует обычный язык, 
представленный на рисунке~\ref{fig:lang-ex}, так как 
каждое слово из обычного языка является дополнением некоторого 
частичного упорядоченного множества из языка помcетов
до линейно упорядоченного множества. 
Формально, связь языка помсетов и обычного языка можно установить 
с помощью понятия \emph{линеаризации помсета}.

\begin{definition}
  \label{def:pomset-subs}
  Помсет $p$ \emph{поглощается} некоторым помсетом  $q$,  
  если существует биективный гомоморфизм из $q$ в $p$.
  В таком случае также говорят, что помсет $p$ более упорядочен чем $q$. 
  Факт поглощения помсета $p$ другим помсетом $q$ будем обозначать как $p \subs q$.
\end{definition}

\begin{definition}
  \label{def:pomset-lin}
  Помсет $p$ является \emph{линеаризацией} помсета $q$, 
  если $p$ является линейно упорядоченным и 
  поглощается $q$. Этот факт будем обозначать как   $p \in \Lin{q}$.
\end{definition}

Линеаризация языка помсетов $P$ определяется 
как объединение линеаризации всех входящих в язык помсетов:
$$ \Lin{P} \defeq \bigcup_{p \in P}\Lin{p}. $$
Наконец, можно сказать что язык помсетов $P \in \Pomlang[\LabelType]$
соответствует обычному языку $L \in \Lang{\LabelType}$, если $\Lin{P} = L$.

Множество помсетов можно объединить в одну \emph{структуру событий}
и таким образом представить язык помсетов как одно частично упорядоченное множество.
Существует множество видов структур событий%
~\cite{Winskel:86,Nielsen-al:1981,Boudol-Castellani:1991,Langerak:91,Baldan-al:IC01}, но 
в контексте данной работы, говоря о \emph{структурах событий}, мы будем иметь в виду \emph{простые структуры событий}, если явно не сказано иное. 

По сравнению с помеченным частично упорядоченным множеством 
простые структуры событий позволяют дополнительно выразить тот факт, 
что два события $e_1$ и $e_2$ находятся в конфликте.
Это означает, что эти два события не могут одновременно 
принадлежать одному сценарию исполнения программы. 

\begin{definition}
  \label{def:lposet-dwfin}
  Будем говорить, что помеченное частично упорядоченное множество 
  $p = \tup{\Event, \lab, \ca}$ является \emph{префикс-конечным}, 
  если каждое событие имеет конечное число предшественников, 
  то есть для любого $e \in \Event$ множество 
  $\dwset{e} \defeq \set{e' ~|~ e' \ca e}$ конечно.
\end{definition}

\begin{definition}
  \label{def:prime-es}
  \emph{Простая структура событий с бинарным конфликтом} над множеством меток $\LabelType$ \emph{---
  это кортеж} $\tup{\Event, \lab, \ca, \cf}$\emph{, где} 
  $\tup{\Event, \lab, \ca}$ \emph{является префикс-конечным помеченым 
  частично упорядоченным множеством, 
  а} $\cf \suq \Event \times \Event$ \emph{--- это} бинарное отношение конфликта\emph{, 
  которое является иррефлексивным, симметричным и 
  удовлетворяет свойству} наследственности\emph{, то есть}
   $e_1 \cf e_2 ~\text{и}~ e_2 \ca e_3 ~\text{влечет}~ e_1 \cf e_3.$
\end{definition}

На рисунке~\ref{fig:es-ex} представлена простая структура событий 
с бинарным конфликтом, кодирующая язык с  рисунка~\ref{fig:lang-ex}. 

Отметим, что часто язык помсетов может иметь более сложную структуру 
конфликтности между событиями, которая не  сводится 
к бинарному конфликту между парой событий. 
В таком случае рассматривают простые структуры событий более общего вида. 

\begin{definition}
  \label{def:prime-cons-es}
  \emph{Простая структура событий с предикатом консистентности} над множеством меток $\LabelType$ ---
  это кортеж $\tup{\Event, \lab, \ca, \Cons}$, где 
  $\tup{\Event, \lab, \ca}$ является префикс-конечным помеченым 
  частично упорядоченым множеством, а 
  а $\Cons \suq \pwfset{\Event}$ --- это \emph{предикат консистентности}, 
  который должен удовлетворять следующим условиям:
  \begin{itemize}
    \item \label{ax:prime-cons-emp}
      $\emptyset \in \Cons$
    \item \label{ax:prime-cons-subs}
      $X \subseteq Y$ и $Y \in \Cons$ влечет $X \in \Cons$
    \item \label{ax:prime-cons-ca}
      $e_1 \ca e_2$ и $\set{e_2} \cup X \in \Cons$ 
      влечет $\set{e_1} \cup X \in \Cons$.
  \end{itemize}
\end{definition}

Можно видеть, что простые структуры событий с бинарным конфликтом
являются частным случаем простых структур событий 
с предикатом консистентности. 
Действительно, для простой структуры событий с бинарным конфликтом
можно определить предикат консистентности следующим образом:
$$X \in \Cons \iff \forall e_1~e_2 \in X \ldotp \neg e_1 \cf e_2.$$

Наконец, формально определим язык помсетов, порождаемый структурой событий. 

\begin{definition}
  \label{def:es-cfg}
  Пусть $S = \tup{\Event, \lab, \ca, \Cons}$ --- это простая структура событий 
  с предикатом консистентности. Тогда подмножество событий 
  $X \suq \Event$ называется \emph{конфигурацией} структуры $S$, 
  если оно является префикс-замкнутым, а все его конечные подмножества 
  являются консистентными: 
  \begin{itemize}
    \item $\dwset{X} \defeq {e' ~|~ \exists e \in X \ldotp~ e' \ca e } \suq X$ 
    \item $Y \finsubseteq X$ влечет $Y \in \Cons$.
  \end{itemize}
\end{definition}

Будем обозначать  множество всех конфигураций структуры событий $S$ как $\Cfg{S}$.

\begin{definition}
  \label{def:es-pomlang}
  Язык помсетов, порождаемый структурой событий $S = \tup{\Event, \lab, \ca, \Cons}$, 
  определяется следующим образом:
  $$ \pomlang{S} \defeq \set{p ~|~ \exists X \in \Cfg{S} \ldotp p = S\rst{X} },$$
  где $S\rst{X} \defeq \tup{X, \lab\rst{X}, \ca\rst{X}}$ --- это сужение 
  структуры событий $S$ на консистентное подмножество событий $X$.
\end{definition}

\subsection{Execution Graphs}
\label{sec:exec-graphs}

Далее перейдем к описанию формализмов, используемых 
для определения моделей памяти.
Напомним, что под моделью памяти понимается
семантика многопоточной системы, оперирующей с разделяемой памятью.
Как уже упоминалось в разделе~\ref{sec:lts},
модель памяти можно определить в терминах операционной семантики.
В таком случае система переходов
$(\LTS_{\thrdSymb} \parSymb \dots \parSymb \LTS_{\thrdSymb}) \prodSymb \LTS_{\memSymb}$
будет описывать многопоточную систему, состоящую из $n$ потоков
и разделяемой памяти, где $\LTS_{\thrdSymb}$ --- это система переходов,
описывающая поведение потоков, а $\LTS_{\memSymb}$ --- система переходов,
описывающая поведение разделяемой памяти. 

Как уже отмечалось, в контексте моделирования
многопоточных систем одним из недостатков подхода,
основанного на операционной семантике, 
является экспоненциально рост количества трасс системы.
В контексте слабых моделей памяти у данного подхода
также есть и другой недостаток.
Проблема заключается в том, что для кодирования каждой
отдельной модели памяти необходимо разработать
собственное представление этой модели  
в терминах системы переходов $\LTS_{\memSymb}$.
Эта система может оказаться достаточно сложной и потребовать моделирования
множества различных структур данных, например,
буферов операций, очередей сообщений,
многоуровневых кэшей и так далее.  

Поэтому для спецификации моделей памяти
часто используют  \emph{аксиоматический стиль}.
В аксиоматическом стиле задано большинство моделей
современных мультипроцессоров, например,
\Intel~\cite{Sewell-al:CACM10}, 
\POWER~\cite{Sarkar-al:PLDI11,Alglave-al:TOPLAS14}),
\ARM~\cite{Pulte-al:POPL18,Alglave-al:TOPLAS14}), а также данный подход использован 
и для некоторых языков программирования,
например, \OCaml~\cite{Dolan-al:PLDI18}, \JS~\cite{Watt-al:PLDI2020}.

Модель памяти в аксиоматическом стиле
определяется как множество консистентных 
\emph{графов сценариев исполнения} (\emph{execution graphs}).
Вершинами в этом графе являются атомарные события, помеченные семантическими метками,
а ребра обозначают различные отношения между этими событиями.
В этом смысле графы сценариев исполнения похожи на помсеты:
главное отличие между ними заключается в том, что 
помсет состоит из единственного отношения причинно-следственной связи, 
а граф сценариев исполнения состоит из
нескольких отношений, наделенных различной семантикой.
Например, отношение \emph{программного порядка} (\emph{program order}) $\lPO$ 
задает порядок, в котором выполняются события в каждом потоке,
а отношение \emph{читает-из} (reads-from) $\lRF$, 
для каждого события записи и указывает, 
какие события чтения выполняют операцию чтения из него. 
На рисунке~\ref{fig:lb-nodep-execs} показаны примеры графов сценариев исполнения, 
соответствующих программе \ref{ex:lb-nodep}.

\input{Dissertation/fig/execs-ex}

Далее введем формальное определение графов сценариев исполнения.
Сначала необходимо  ввести тип семантических меток (алфавит)
для описания абстракции разделяемой памяти.

Определим следующие множества:
\begin{itemize}
  \item $\Tid \suq \N$ обозначает множество \emph{идентификаторов потоков}, 
    а поток с идентификатором $t_0 \defeq 0$
    обозначает выделенный \emph{инициализирующий} поток в программе;
  \item $\Loc$ обозначает множество \emph{разделяемых переменных} 
    (или \emph{локаций});
  \item $\Mod \defeq \set{\na, \rlx, \acq, \rel, \acqrel, \sco}$
    обозначает множество \emph{режимов доступа} (access modes)
    к разделяемым переменным;
  \item $\Val$ обозначает множество возможных \emph{значений}. 
\end{itemize}  

Также определим множество меток $\MemLab$, 
соответствующих абстракции разделяемой памяти. 
Метка $l \in \MemLab$ может быть следующих видов:
\begin{itemize}
  \item $\rlab{o}{x}{v}$ --- метка операции чтения значения $v$ из переменной $x$, 
    аннотированная режимом доступа $o$;
  \item $\wlab{o}{x}{v}$ --- метка операции записи значения $v$ в переменную $x$, 
    аннотированная режимом доступа $o$;
  \item $\lF^o$ --- метка операции барьера, аннотированная режимом $o$.
\end{itemize}
Если у метки опущен режим доступа, то будем считать, что 
она аннотирована режимом $\rlx$.

\begin{definition}
  \label{def:exec-graph}
  \emph{Граф сценария исполнения} (\emph{execution graph}) $G$ является
  кортежом $\tup{\lE, \lLAB, \lPO, \lRMW, \lRF, \lCO}$,
  элементы этого кортежа определены ниже.
  \begin{itemize}

    \item $\lE \suq \N$ --- это множество событий.

    \item $\lTID : \lE \fun \Tid$ --- это функция, 
      которая присваивает каждому событию идентификатор потока.
      Множество событий, принадлежащих инициализирующему потоку,
      определяется как ${\lEi \defeq \set{e \in \lE \mid \lTID(e) = t_0}}$.

    \item $\lLAB : \lE \fun \MemLab$ --- это функция, 
      которая назначает каждому событию метку. 
      Данная функция также индуцирует частично определенные функции
      $\lTYP$, $\lLOC$, $\lMOD$, $\lVAL$, которые возвращают
      тип, локацию, режим доступа и значение события соответственно. 
      Также положим, что $\lR$, $\lW$ и $\lF$ обозначают подмножества 
      событий с меткой операции чтения, записи и барьера соответственно.

    \item $\lPO \suq \lE \times \lE$ --- это отношение 
      \emph{программного порядка} (\emph{program order}).
      Это отношение строгого частичного порядка на событиях, 
      которое полностью упорядочивает все события внутри одного потока
      согласно потоку управления программы. 
      Дополнительно полагается, что инициализирующие события $\lEi$ 
      упорядочены программным порядком раньше всех других событий.
      Также введем отношение \emph{непосредственного программного порядка}
      (\emph{immediate program order}): 
      будем считать событие $e_1$ непосредственным $\lPO$-предшественником 
      события $e_2$ если $e_1$ предшествует $e_2$ 
      и между ними нет других событий.
      \begin{equation*}
        \lPOimm \defeq \lPO \setminus (\lPO \seqc \lPO)
      \end{equation*}

    \item $\lRMW \suq \lRex \seqc \lPOimm \cap \lEQLOC \seqc \lWex$ ---
      отношение соединяющие \emph{атомарные пары событий чтения-записи}. 
      Если $\tup{r, w} \in \lRMW$ тогда считается, что данная пара событий
      возникла в ходе исполнения одной инструкции атомарного чтения-записи, 
      например, инструкции \emph{атомарного сравнения с обменом} (\CAS).

    \item $\lRF \suq [\lW] \seqc \lEQLOC \cap \lEQVAL \seqc [\lR]$ --- отношение 
      \emph{читает-из} (\emph{reads-from}). 
      Это отношение связывает событие-запись с событиями-чтениями, 
      которые выполняют операцию чтения из него. 
      Для каждого события чтения должно существовать 
      событие записи, из которого выполняется чтение: 
      $$ r \in \lR \implies \exists w \in \lW \ldotp \tup{w, r} \in \lRF.$$
      Более того, каждое событие чтения может быть связано только с одним событием записи:
      $$ \tup{w_1,r} \in \lRF \wedge \tup{w_2,r} \in \lRF \implies w_1 = w_2.$$

      Дополнительно будем рассматривать внутреннею (\emph{internal}) 
      и внешнюю (\emph{external}) версию отношения ``читает-из''
      (обозначаются как $\lRFI$ и $\lRFE$ соответственно), 
      в зависимости от того принадлежит ли пара событий записи и чтения
      одному потоку или разным потокам.
      \[\def\arraystretch{1}
       \begin{array}{c@{\qquad}c@{\qquad}c@{\qquad}c}
         \lRFI \defeq \lRF \cap \lPO      &
         \lRFE \defeq \lRF \setminus \lPO
       \end{array}
      \]

    \item $\lCO \suq [\lW] \seqc \lEQLOC \seqc [\lW]$ --- это отношение 
      \emph{когерентности}. Это отношение строгого частичного порядка на событиях, 
      которое полностью упорядочивает все операции записи в одну локацию. 
      Это отношение представляет собой порядок, в котором операции записи 
      продвигаются в основную память и становятся видимы другим потокам. 
      \begin{equation*}
        \forall w_1, w_2 \in \lW \ldotp~ 
          \lLOC(w_1) = \lLOC(w_2) \implies \tup{w_1, w_2} \in \lCO \cup \lCO^{-1}
      \end{equation*}
      По аналогии с отношением ``читает-из'' также определим
      внутреннею и внешнюю версии отношения когерентности.
      \[\def\arraystretch{1}
       \begin{array}{c@{\qquad}c@{\qquad}c@{\qquad}c}
         \lCOI \defeq \lCO \cap \lPO      &
         \lCOE \defeq \lCO \setminus \lPO
       \end{array}
      \]

  \end{itemize}
\end{definition}

Множество всех графов сценариев исполнения будем обозначать как~$\ExecG$.

\begin{definition}
  \label{def:ax-memory-model}
  \emph{Аксиоматическая модель памяти} (\emph{axiomatic memory model}) $M$ 
  задается как подмножество графов сценариев исполнения: $M \suq \ExecG$.
\end{definition}

\begin{definition}
  \label{def:memory-model-cons}
  Граф $G$ называется \emph{консистентным} с точки зрения модели $M$, 
  или просто $M$-\emph{консистентным}, если $G \in M$.
\end{definition}

\paragraph{Сохранение программного порядка.}

Модели памяти, сохраняющие программный порядок, накладывают 
ограничение, требующее, чтобы объединение отношений программного порядка
и ``читает-из'' было ацикличным. 

\begin{definition}
Будем говорить, что граф сценария исполнения $G$ 
\emph{сохраняет программный порядок}, если выполняются следующее условие: 
\begin{itemize}
  \item[] $\lPO \cup \lRF$ является ацикличным отношением.
    \labelAxiom{$\lPORF$-acyclic}{ax:porf-acyc}
\end{itemize}
\end{definition}

Обозначим множество всех таких графов как $\PorfExecG$.
Также будем говорить, что модель памяти $M$ сохраняет программный порядок, 
если любой $M$-консистентный граф сохраняет программный порядок, 
то есть верно следующее: ${M \suq \PorfExecG}$.

Например, среди графов, показанных на рисунке~\ref{fig:lb-nodep-execs}, 
графы \circledb{A}, \circledb{B} и \circledb{C} сохраняют программный порядок, 
а граф \circledb{D} --- нет, так как он содержит $\lPO \cup \lRF$ цикл.
Таким образом, сценарий исполнения программы \ref{ex:lb-nodep},
%% соответствующий графу \circledb{D},
в результате которого в локальные переменные $a$ и $b$ оказывается записано значение $1$,
запрещен моделями памяти, сохраняющими программный порядок.

\paragraph{Сохранение синтаксических зависимостей.}

Модели памяти, сохраняющие синтаксические зависимости, 
могут допускать некоторые $\lPO \cup \lRF$ цикличные графы. 
Данные модели гарантируют сохранение порядка между событиями
одного потока только в том случае, если они связаны отношением 
\emph{сохраняемого программного порядка} $\lPPO$ (\emph{preserved program order}), 
которое является подмножеством отношения программного порядка $\lPO$. 
Отношение сохраняемого программного порядка
строится с помощью понятия \emph{синтаксических зависимостей} между событиями,
которое включает зависимость по данным, по управлению и нек. другие. 

\begin{definition}
  \label{def:ext-exec-graph}
  \emph{Расширенным графом сценария исполнения} будем называть
  обычный граф сценария исполнения (определение~\ref{def:exec-graph}), 
  дополненный следующими отношениями: 
  $\lDATA$ --- \emph{зависимость по данным}  (\emph{data dependency}),$\lCTRL$ --- \emph{зависимость по потоку управления}   (\emph{control dependency}), 
  $\lADDR$ --- \emph{зависимость по целевому адресу}  (\emph{address dependency}) 
  и $\lRMWDEP$ --- \emph{зависимость по операции \CAS}  (\emph{\CAS dependency}).
\end{definition}

В контексте моделей памяти, сохраняющих синтаксические зависимости,
под графом сценария исполнения будем подразумевать расширенный граф, 
который дополнен отношениями зависимости. 

\begin{definition}
  \label{def:deps-rel}
  Для расширенного графа сценария исполнения определим 
  объединенное отношение \emph{зависимости} (\emph{dependency}) 
  следующим образом:
  $$ \lDEPS \defeq \lDATA \cup \lCTRL \cup \lADDR \seqc \lPO^? \cup \lRMWDEP. $$
\end{definition}

Точное определение сохраняемого программного порядка может 
варьироваться в зависимости от конкретной модели памяти, 
но, как правило, оно включает как минимум объединенное отношение зависимости. 
Модели памяти, сохраняющие синтаксические зависимости, 
накладывают ограничение, требующее, чтобы объединение 
отношений сохраняемого программного порядка и 
внешнего отношения ``читает-из'' было ацикличным. 

\begin{definition}
\label{def:ppo-preserving}
Будем говорить, что граф сценария исполнения $G$ 
\emph{сохраняет синтаксические зависимости}, если выполняются следующие условия: 
\begin{itemize}
  \item $\lDEPS \suq \lPPO$
    \labelAxiom{$\lPPO$-deps}{ax:ppo-deps}
  \item $\lPPO \cup \lRFE$ является ацикличным отношением.
    \labelAxiom{$\lPPORF$-acyclic}{ax:pporf-acyc}
\end{itemize}
\end{definition}

Обозначим множество всех таких графов как $\PporfExecG$.
Также будем говорить, что модель памяти $M$ 
сохраняет синтаксические зависимости, 
если любой $M$-консистентный граф сохраняет синтаксические зависимости, 
то есть верно следующее:  ${M \suq \PporfExecG}$.

\input{Dissertation/fig/lb-execs}

Рассмотрим, например, пару $\lPO \cup \lRF$ цикличных графов, 
изображенных на рисунке~\ref{fig:LB-ppo-execs}.
Данные графы соответствуют сценарию исполнения 
с результатом $a = b = 1$. 
Отметим, что граф, показанный на рисунке~\ref{fig:LB-nodep-ppo-exec},
является $\lPPO \cup \lRFE$ ацикличным,
в то время как граф на рисунке~\ref{fig:LB-dep-ppo-exec} содержит $\lPPO \cup \lRFE$ цикл. 
Это объясняется тем, что в программе \ref{ex:lb-nodep} инструкции 
в левом потоке не связаны зависимостью по данным, 
а в программах \ref{ex:lb-fakedep}~и~\ref{ex:lb-dep}
--- связаны. 
Таким образом, модели памяти, сохраняющие синтаксические зависимости, 
допускают сценарий исполнения с результатом $a = b = 1$ 
для программы \ref{ex:lb-nodep}, 
но не для программ \ref{ex:lb-fakedep}~и~\ref{ex:lb-dep}.

Далее рассмотрим некоторые другие часто встречаемые
в различных моделях памяти свойства консистентности.

\paragraph{Когерентность}является базовым свойством моделей памяти,
которое гарантирует  последовательную согласованность
по каждой отдельной локации в памяти
(напомним, что это свойство также упоминалось
в разделе~\ref{sec:models-primitives}).
В терминах графов сценариев исполнения это свойство 
сводится к следующему требованию:  отношение 
$\lPO\rst{\lLOC} \cup \lRF \cup \lCO \cup \lRB$
должно быть ацикличным, где отношение $\lRB$ задано согласно следующему определению.  

\begin{definition}
  \label{def:rb}
  Отношение \emph{``читает-перед''} $\lRB$ (\emph{reads-before}) 
  упорядочивает операции чтения перед операциями записи, 
  которые следуют в порядке когерентности за записью, 
  из которой выполняется чтение, то есть   $\lRB \defeq \lRF^{-1} \seqc \lCO$. 
\end{definition}

Модели памяти языков программирования усиливают свойство 
когерентности и в определении выше вместо отношения программного порядка 
рассматривают отношение ``происходит-до'' $\lHB$ (\emph{happens-before}),
которое является объединением программного порядка 
и отношения межпоточной синхронизации $\lSW$.
Ниже приводится формальное определение этих двух отношений, 
а также некоторых вспомогательных отношения. 

\begin{definition}
  \label{def:rseq}
  Отношение \emph{выпускающей последовательности} $\lRSEQ$
  (\emph{release sequence}) задается следующим образом\footnote{
    Отметим, что определение выпускающей последовательности 
    может немного варьироваться в различных моделях памяти. 
    Здесь приведено определение этого отношения согласно модели \RCMM~\cite{Lahav-al:PLDI17}.
    Далее в тексте данной диссертации в случаях, когда определение 
    выпускающей последовательности для некоторой модели памяти отличается от
    представленного выше, будет приведено альтернативное определение. 
  }: 
  $$ \lRSEQ \defeq [\lW] \seqc \lPO\rst{\lLOC}^? \seqc (\lRF \seqc \lRMW)^*. $$
\end{definition}

\begin{definition}
  \label{def:sw}
  Отношение \emph{``синхронизируется-c''} $\lSW$ (\emph{synchronizes-with}) 
  соединяет пары синхронизирующихся событий.
  Например, освобождающая запись синхронизируется с захватывающим чтением, 
  которое читает из этой записи.  
  Формально это отношение задается так: 
  $$ \lSW  \defeq [\lE^{\rel\squq}]                 \seqc 
                  ([\lF] \seqc \lPO)^? \seqc \lRSEQ \seqc 
                  \lRF \seqc (\lPO \seqc [\lF])^?   \seqc 
                  [\lE^{\acq\squq}]. 
  $$
\end{definition}

\begin{definition}
  \label{def:hb}
  Отношение \emph{``произошло-до''} $\lHB$ (\emph{happens-before})
  является транзитивным замыканием объединения программного порядка 
  и отношения ``синхронизируется-c'':
  $$ \lHB \defeq (\lPO \cup \lSW)^+. $$
\end{definition}

\begin{definition}
  \label{def:eco}
  \emph{Расширенный порядок когерентности} $\lECO$ (\emph{extended coherence order})
  определяется следующим образом: 
  $$ \lECO \defeq (\lCO \cup \lRF \cup \lRB)^+. $$ 
  Это отношение полностью упорядочивает все cобытия обращения к одной локации
  за исключением событий чтения, которые читают из одной и той же записи. 
\end{definition}

\begin{definition}
\label{def:coherence}
Будем говорить, что граф сценария исполнения $G$ является
\emph{когерентным} (\emph{coherent}), если выполняются следующее условие: 
\begin{itemize}
  \item[] $\lHB \seqc \lECO^?$ является иррефлексивным отношением.
      \labelAxiom{Coherent}{ax:coh}
\end{itemize}
\end{definition}

Заметим, что приведенное выше определение свойства когерентности 
эквивалентно требованию, чтобы отношение
$\lHB\rst{\lLOC} \cup \lRF \cup \lCO \cup \lRB$ было ацикличным.

Программа \ref{ex:mp}, показанная на рисунке~\ref{fig:coh-ex}, 
демонстрирует пример идиомы синхронизации с передачей сообщения (\emph{message-passing}).
Левый поток выполняет операцию освобождающей записи в локацию \texttt{y}, 
а правый поток --- операцию захватывающего чтения из этой локации. 
Если эта операция  читает значение \texttt{1}, записанное левым потоком, 
то правый поток должен \emph{синхронизировать} свой взгляд (\emph{view}) 
на разделяемую память cо взглядом левого потока. 
В частности, это означает, что правый поток не может читать более старые значения,
чем записанные левым потоком до операции освобождающей записи.
Следовательно, чтение значения \texttt{0} из локации \texttt{x} должно быть запрещено.
На рисунке~\ref{fig:coh-ex} также показан граф сценария исполнения, 
соответствующий описанному выше сценарию. 
Этот граф \textbf{не является} когерентным, так как он содержит цикл 
$\wlab{\rlx}{x}{1} \arrowHB \rlab{\rlx}{x}{0} \arrowRB \wlab{\rlx}{x}{1}$ 

\input{Dissertation/fig/coh-ex}

\paragraph{Атомарность} 

гарантирует, что операция чтения 
в атомарной инструкции чтения-записи (например, \CAS)
всегда читает из самой последней согласно порядку когерентности записи.

\begin{definition}
\label{def:rmw-atomicity}
Будем говорить, что граф сценария исполнения $G$ является
\emph{\RMW-атомарным} (\emph{\RMW-atomic}), если выполняются следующее условие: 
\begin{itemize}
  \item[] $\lRMW \cap (\lRB \seqc \lCO) = \emptyset$.
      \labelAxiom{\RMW-Atomic}{ax:atom}
\end{itemize}
\end{definition}

На рисунке~\ref{fig:atom-ex}, показан пример графа сценария исполнения, 
который нарушает свойство \RMW-атомарности.

\input{Dissertation/fig/atom-ex}

\paragraph{Последовательная согласованность.}

Для программ, которые используют только обращения к памяти, 
аннотированные режимом доступа $\sco$, модели памяти 
языков программирования гарантируют семантику последовательной согласованности. 
Последовательная согласованность также гарантируется если 
между каждой парой инструкций обращения к памяти вставить 
полный барьер памяти --- инструкцию $\fenceInst{\sco}$.

Если в программе не смешиваются обращения к одной и той же локации, 
аннотированные режимом $\sco$ и более слабыми режимами, то тогда
эти  гарантии можно формализовать согласно следующему определению. 

\begin{definition}
Частичный порядок \emph{строгой последовательной упорядоченности} $\lPSCS$
(\emph{strong sequential consistency order}) 
задается так:
$$ \lPSCS \defeq ([\lE^\sco] \cup [\lF^\sco] \seqc \lHB^?) \seqc 
                 (\lHB \cup \lECO) \seqc 
                 (\lHB^? \seqc [\lF^\sco] \cup [\lE^\sco])
$$
\end{definition}

\begin{definition}
Будем говорить, что граф сценария исполнения $G$ является
\emph{строго последовательно согласованным} (\emph{strongly sequential consistent}), 
если выполняются следующее условие: 
\begin{itemize}
  \item[] $\lPSCS$ ациклично.
      \labelAxiom{Strongly Sequential Consistent}{ax:sc-strong}
\end{itemize}
\end{definition}

На рисунке~\ref{fig:sc-ex}, показан пример графа сценария исполнения, 
который не является строго последовательно согласованным.
Действительно, в этом графе существует цикл 
$\wlab{\sco}{x}{1} \arrowPO \rlab{\sco}{y}{0} \arrowRB \wlab{\sco}{y}{1}
                   \arrowPO \rlab{\sco}{x}{0} \arrowRB \wlab{\sco}{x}{1}$.

В случае если в программе к одной и той же локации происходят 
и $\sco$ обращения, и другие типы обращений, тогда определение 
последовательной согласованности усложняется.
Детальное обсуждение этой проблемы выходит за рамки диссертации
и может быть найдено в работе~\cite{Lahav-al:PLDI17}. 
Далее приводятся лишь необходимые формальные определения без дополнительных пояснений. 

\begin{definition}
Отношение \emph{``последовательно-упорядочен-до''} $\lSCB$ 
(\emph{sequentially consistent before}) задается как:

$$ \lSCB \defeq \lPO \cup
                \lPO\rst{\neq \lLOC} \seqc \lHB \seqc 
                \lPO\rst{\neq \lLOC} \cup
                \lHB\rst{\lLOC} \cup
                \lCO \cup \lRB. 
$$

\end{definition}

\begin{definition}
Частиный порядок \emph{базовой последовательной упорядоченности} $\lPSCB$
(\emph{basic partial sequential consistency order}) 
определяется следующим образом:

$$ \lPSCB \defeq ([\lE^\sco] \cup [\lF^\sco] \seqc \lHB^?) \seqc 
                 \lSCB \seqc 
                 (\lHB^?\seqc[\lF^\sco] \cup [\lE^\sco]). 
$$ 

\end{definition}

\begin{definition}
Частиный порядок \emph{последовательной упорядоченности барьеров} $\lPSCF$
(\emph{barrier partial sequential consistency order}) 
определяется как:

$$ \lPSCF \defeq [\lF^\sco] \seqc 
                 (\lHB \cup \lHB \seqc \lECO \seqc \lHB) \seqc 
                 [\lF^\sco]. 
$$ 

\end{definition}

\begin{definition}
Частиный порядок \emph{последовательной упорядоченности} $\lPSC$
(\emph{partial sequential consistency order}) 
задан как объединение двух предыдущих отношений частичного порядка:
$$ \lPSC \defeq \lPSCB \cup \lPSCF. $$ 
\end{definition}

\begin{definition}
\label{def:seq-consistency}
Будем говорить, что граф сценария исполнения $G$ является
\emph{последовательно согласованным} (\emph{sequentially consistent}), 
если выполняются следующее условие: 
\begin{itemize}
  \item[] $\lPSC$ является ацикличным отношением.
      \labelAxiom{Sequentially Consistent}{ax:sc}
\end{itemize}
\end{definition}

\input{Dissertation/fig/sc-ex}

\paragraph{Модель \RCMM.}

В заключении данного подраздела в качестве примера 
приведем определение консистентности в 
уже упоминавшейся модели \RCMM~\cite{Lahav-al:PLDI17}.
Данное определение по сути объединяет все приведенные выше свойства.  

\begin{definition}
  \label{def:rc11-cons}
  Граф $G$ является консистентным с точки зрения модели \RCMM
  если выполняются следующие условия:  

  \begin{itemize}

    \item $\lPO \cup \lRF$ является ацикличным отношением;
      \labelAxiom{\RCMM-No-Thin-Air}{ax:rc11-noota}

    \item $\lHB \seqc \lECO^?$ является иррефлексивным отношением;
      \labelAxiom{Coherent}{ax:rc11-coh}

    \item $\lRMW \cap (\lRB \seqc \lCO) = \emptyset$;
      \labelAxiom{\RMW-Atomic}{ax:rc11-atom}

    \item $\lPSC$ является ацикличным отношением.
      \labelAxiom{Sequentially Consistent}{ax:rc11-sc}

  \end{itemize}
\end{definition}

\subsection{\Wkm Event Structures}
\label{sec:wkmo-eventstruct}

В предыдущем разделе было показано, что 
модели памяти, сохраняющие программный порядок 
или синтаксические зависимости, могут быть 
заданы в аксиоматическом стиле, 
то есть как множество консистентных графов 
сценариев исполнения.
В этом случае каждому сценарию исполнения, 
допустимому моделью памяти, соответствует единственный граф. 

К сожалению, модели памяти, сохраняющие семантические зависимости,
не могут быть заданы в таком стиле~\cite{Batty-al:ESOP15}.
Для того, чтобы обосновать некоторый результат исполнения программы, 
модели данного класса вынуждены рассматривать сразу несколько сценариев исполнения.
%% которые моделируют спекулятивное исполнение программы.
В рамках модели \Wkm это множество сценариев
объединяется в структуру событий особого вида.

\begin{definition}
  \label{def:eventstruct}
  \emph{Структура событий модели \Wkm} (\emph{\Wkm event structure}) $S$ ---
  это кортеж $\tup{\lE, \lTID, \lLAB, \lPO, \lRMW, \lJF, \lEW, \lCO}$.
  Компоненты этого кортежа определены следующим образом.
  \begin{itemize}

    \item $\lE$, $\lTID$, $\lLAB$ определены по аналогии
      с графами сценариев исполнения (определение~\ref{def:exec-graph}).

    \item $\lPO \suq \lE \times \lE$ ---
      это отношение программного порядка, определенное по аналогии
      с графами сценариев исполнения (определение~\ref{def:exec-graph}).
      В отличие от случая графов сценариев исполнения
      в случае структуры событий отношение программного порядка
      не обязано полностью упорядочивать все события внутри одного потока.
      События, принадлежащие одному потоку не связанные 
      отношением программного порядка, называются \emph{конфликтующими}.
      Формально, отношение конфликта $\lCF$ задается следующим образом:
      \begin{equation*}
        \lCF \defeq ([\lE \setminus \lEi] \seqc {=_{\lTID}} \seqc [\lE \setminus \lEi])
                    \setminus (\lPO \cup \lPO^{-1})^?.
      \end{equation*}
      Также считается что два события находятся в отношении
      \emph{непосредственного конфликта} если они 
      имеют общего предка относительно программного порядка. 
      \begin{equation*}
        \lCFimm \defeq \lCF \cap (\lPOimm^{-1} \seqc \lPOimm)
      \end{equation*}

    \item Отношение $\lRMW$ определено по аналогии
      с графами сценариев исполнения (определение~\ref{def:exec-graph}).
    
    \item $\lJF \suq [\lW] \seqc (\lEQLOC \cap \lEQVAL) \seqc [\lR]$ --- 
      отношение \emph{обоснован-из} (\emph{justified-from}). 
      Данное отношение во многом аналогично отношению ``читает-из'' 
      из определения графов сценариев исполнения, 
      однако, как будет показано далее, для структур событий 
      отношение ``читает-из'' является производным. 
      Отношение $\lJF$ связывает событие записи с событиями чтения, 
      которые обоснованы данной записью.
      Каждое событие чтения должно быть обосновано: 
      $$ r \in \lR \implies \exists w \in \lW \ldotp \tup{w, r} \in \lJF.$$
      Требуется, чтобы связанные события имели одну и ту же локацию и значение, 
      кроме того, каждое событие чтения должно быть связано
      только с одним событием записи.
      \begin{equation*} 
        \begin{array}{rcl}
          \tup{w_1,r} \in \lJF \wedge \tup{w_2,r} \in \lJF 
             & \implies & w_1 = w_2 \\
        \end{array}
      \end{equation*} 
      Обоснование события чтения конфликтующим событием записи запрещено:
      ${\lJF \cap \lCF = \emptyset}$.
      По аналогии с отношением ``читает-из'' в случае
      графов сценариев исполнения (определение~\ref{def:exec-graph}) также 
      определяется внутреннея и внешняя версии отношения ``обоснован-из''.
      \[\def\arraystretch{1}
       \begin{array}{c@{\qquad}c@{\qquad}c@{\qquad}c}
         \lJFI \defeq \lJF \cap \lPO      &
         \lJFE \defeq \lJF \setminus \lPO
       \end{array}
      \]

    \item $\lEW \suq [\lW] \seqc (\lCF \cap \lEQLOC \cap \lEQVAL)^? \seqc [\lW]$ ---
      отношение \emph{эквивалентности на записях} (\emph{equal-writes}).
      Это отношение эквивалентности связывает конфликтующие
      (или идентичные) события записи с одной и той же локацией и значением.

    \item $\lCO \suq [\lW] \seqc \lEQLOC \seqc [\lW]$ ---
      отношение \emph{когерентности}, которое определено по аналогии с графами
      сценариев исполнения (определение~\ref{def:exec-graph}).
      В структуре событий \Wkm отношение когерентности
      полностью упорядочивает записи в одну и ту же локацию
      только с точностью до отношения эквивалентности на записях.
      \begin{equation*}
       \forall x \in \Loc \ldotp~ \forall w_1,w_2 \in \lW_{x} \ldotp~
          \tup{w_1, w_2} \in \lEW \cup \lCO \cup \lCO^{-1}.
      \end{equation*}
      Также полагается, что отношение $\lCO$ замкнуто
      относительно отношения $\lEW$, т.е.
      $ \lEW \seqc \lCO \seqc \lEW \subseteq \lCO. $

  \end{itemize}
\end{definition}

\input{Dissertation/fig/lb-es}

В качестве примера рассмотрим структуру событий, 
показанную на рисунке~\ref{fig:es-lb}. 
Данная структура соответствует программам 
\ref{ex:lb-nodep} и \ref{ex:lb-fakedep}.
Можно видеть, что события ${\ese{1}{1}{1} \arrowPO \ese{1}{2}{1}}$
формируют ветку левого потока в которой 
инструкция чтения $\readInst{}{r_1}{x}$ читает
инициализирующее значение \tcode{0}.
Рядом находится конфликтующая ветка ${\ese{1}{1}{2} \arrowPO \ese{1}{2}{2}}$.
Заметим, что показаны только ребра отношения непосредственного конфликта.
Например, показано ребро ${\ese{1}{1}{1} \arrowCF \ese{1}{1}{2}}$,
но не ${\ese{1}{1}{1} \arrowCF \ese{1}{2}{2}}$, 
потому что последнее может быть выведено из первого.
Также обратим внимание, что каждое событие чтения 
обосновано некоторым событием записи, например, можно видеть ребра
${\Init \arrowJF \ese{1}{1}{1}}$
${\ese{1}{2}{1} \arrowJF \ese{2}{1}{}}$
и ${\ese{2}{2}{} \arrowJF \ese{1}{1}{2}}$.
Наконец, две записи в локацию \tcode{y} помечены 
как эквивалентные: ${\ese{1}{2}{1} \arrowEW \ese{1}{2}{2}}$.

Отметим, что в отличие от классического определения простых структур событий, 
структуры событий в модели \Wkm содержат не одно отношение 
причинно-следственной связи $\ca$, а множество отношений c различной семантикой. 
В качестве аналога отношения причинно-следственной связи $\ca$
для \Wkm структуры событий можно было бы рассматривать 
транзитивное замыкание объединения отношений $\lPO$ и $\lJF$, 
то есть отношение $(\lPO \cup \lJF)^*$. 
Однако, можно видеть, что в этом случае \Wkm структура событий 
нарушает аксиомы иррефлексивности и наследственности отношений конфликта. 
Например, в структуре, показанной на рисунке~\ref{fig:es-lb}, 
событие $\ese{1}{1}{2}$ зависит от события $\ese{1}{1}{1}$, 
которое находится с ним в конфликте.
Если допустить, что выполняется аксиома наследственности конфликта,
тогда событие $\ese{1}{1}{2}$ должно быть в конфликте с самим собой, 
что нарушает аксиому иррефлексивности конфликта. 
Таким образом, оказывается, что классическая теория простых структур событий 
неприменима к модели \Wkm.
Детально эта проблема обсуждается в главе~\ref{ch:porf-evenstruct}.

Структура событий \Wkm может кодировать несколько графов сценариев исполнения. 
Чтобы задать множество извлекаемых графов введем аналог понятия 
конфигурации для структур событий \Wkm.
Заметим, что здесь вновь проявляется расхождение теории 
структур событий \Wkm и классической теории простых структур событий. 
Рассмотрим, например, множество состоящее из одного события $\{\ese{1}{1}{2}\}$ 
структуры, показанной на рисунке~\ref{fig:es-lb}.
Чтобы сформировать конфигурацию, недостаточно просто 
взять замыкание этого множества относительно отношений $\lPO$ и $\lJF$,
так как, например, событие $\ese{2}{1}{}$ обосновано событием $\ese{1}{2}{1}$,
которое в свою очередь находится в конфликте с исходным событием $\ese{1}{1}{2}$.
Чтобы обойти данное проблему, можно вместо 
события записи $\ese{1}{2}{1}$ взять эквивалентное ему событие записи $\ese{1}{2}{2}$.
Для формализовации этого построения, 
в модели \Wkm вводится производное отношение ``читает-из'' $\lRF$, 
которое расширяет отношение $\lJF$ на классы эквивалентности по отношению $\lEW^*$.

\begin{definition}
  \label{def:wkm-rf}
  Для \Wkm структуры событий $S$ отношение \emph{``читает-из''} $\lRF$
  определяется следующим образом:
  $$\lRF \defeq (\lEW^* \seqc \lJF) \setminus \lCF.$$
\end{definition}

Помимо этого также вводится понятие \emph{видимых} событий.
Видимое событие не может зависеть от конфликтующих с ним событий записи,
для каждого такого конфликтующего события должна существовать
эквивалентное неконфликтное событие записи. 

\begin{definition}
  \label{def:wkm-vis}
  Множество \emph{видимых} $\lVIS$ (\emph{visible}) событий
  задано следующим образом:
  $$\lVIS \defeq \set{e \in \lE \mid
      \lCF \cap (\lJFE \seqc (\lPO \cup \lJF)^*) \seqc [e] \suq
      \lEW \seqc (\lPO \cup \lPO^{-1})^?}
  $$
\end{definition}

\begin{definition}
\label{def:wkm-cfg}
\emph{Обоснованной конфигурацией} структуры событий $S$
называется подмножество событий $C \subseteq S.\lE$ такое, что:
\begin{itemize}
  \item $C$ бесконфликтно: $\lCF \cap C \times C = \emptyset$;
  \item $C$ замкнуто относительно $\lPO$: $\dom{\lPO \seqc [C]} \suq C$;
  \item $C$ полно относительно $\lRF$: $C \cap \lR \suq \cod{[C] \seqc \lRF}$.
  \item $C$ состоит из видимых событий: $C \suq S.\lVIS$.
\end{itemize}
\end{definition}

\begin{definition}
\label{def:wkm-extracted}
Будем говорить, что граф сценария исполнения $G$
может быть \emph{извлечен} из структуры событий $S$, 
что обозначается как $S \rhd G$,
если множество событий графа $G.\lE$ является 
обоснованной конфигурацией структуры событий $S$, 
такой что $G = S\rst{G.\lE}$.
\end{definition}

Также как и в случае аксиоматических моделей памяти,
заданных в терминах графов сценариев исполнения,
в модели \Wkm вводится предикат консистентности структур событий,
который призван отфильтровать структуры,
обосновывающее неконсистентные сценарии исполнений.
Далее введем определение консистентности и некоторые вспомогательные понятия.

\begin{definition}
  \label{def:wkm-sw-hb-eco}
  Отношения ``синхронизируются-с'' $\lSW$ и ``произошло-до'' $\lHB$,
  а также отношение расширенного порядка когерентности $\lECO$
  определяются для структур событий в модели \Wkm аналогично как 
  и для графов сценариев исполнения 
  (смотри определения \ref{def:sw}, \ref{def:hb} и \ref{def:eco}).
\end{definition}

\begin{definition}
  \label{def:wkm-ecf}
  Отношение \emph{расширенного конфликта} $\lECF$
  (\emph{extended conflict}) распространяет отношение конфликта
  вдоль отношения ``произошло-до'' $\lHB$:
  $$\lECF \defeq (\lHB^{-1})^? \seqc \lCF \seqc \lHB^?$$
\end{definition}

\begin{definition}
\label{def:es-cons}
Структура событий модели \Wkm называется \emph{консистентной}
если выполняются следующие условия:
\begin{itemize}

  \item $\lECF$ является иррефлексивным отношением;
   \labelAxiom{Non-Contradictory}{ax:ecf-irr}

  \item $\lJF \cap \lECF = \emptyset$;
   \labelAxiom{Well-Justified}{ax:wkm-jf-necf}

  \item $\lPO \cup \lJF$ является ацикличным отношением;
    \labelAxiom{\Wkm-No-Thin-Air}{ax:wkm-noota}

  \item $\dom{\lJFE} \subseteq \lVIS$;
    \labelAxiom{Visibly-Justified}{ax:wkm-jf-vis}

  \item $\lHB \seqc \lECO^?$ является иррефлексивным отношением.
    \labelAxiom{Coherent}{ax:wkm-coh}

\end{itemize}
\end{definition}

Первые два ограничения запрещают структуры событий, 
в которых некоторое событие находится в конфликте с самим собой
или обосновывается конфликтующим событием записи. 
Ограничение \ref{ax:wkm-noota} предотвращает появление значений из воздуха.
Ограничение \ref{ax:wkm-jf-vis} утверждает, что события чтения 
могут быть обоснованы только событиями записи из того же потока, 
или видимыми событиями записи из других потоков. 
Наконец, ограничение \ref{ax:wkm-coh} гарантирует 
когерентность на уровне всей структуры событий.
Причина, по которой свойство когерентности устанавливается 
на уровне всей структуры событий, а не на уровне
индивидуальных графов сценариев исполнения, может быть найдена 
в работе \cite{Chakraborty-Vafeiadis:POPL19}.

\begin{definition}
  \label{def:wkm-cons}
  Граф $G$ является консистентным с точки зрения модели \Wkm 
  если существует \Wkm консистентная структура событий $S$, 
  такая что $G$ может быть из нее извлечен, то есть $S \rhd G$, 
  и более того выполняются следующие условия:
\begin{itemize}

  \item $\lRMW \cap (\lRB \seqc \lCO) = \emptyset$;
    \labelAxiom{\RMW-Atomic}{ax:wkm-atom}

  \item $\lPSC$ является ацикличным отношением.
    \labelAxiom{Sequentially-Consistent}{ax:wkm-sc}

\end{itemize}
\end{definition}
