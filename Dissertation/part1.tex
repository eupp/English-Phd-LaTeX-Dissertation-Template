\chapter{Обзор}
\label{ch:review}

\section{Слабые модели памяти}

\eupp{Данный подраздел будет в значительной степени основан
  на материле обзорной статьи~\cite{Moiseenko-al:PCS21}}

Краткое введение в область слабых моделей памяти, пример. 
Обоснование важности исследования этой области.  

\subsection{Требования к моделям памяти}

Основные требования предъявлемые к моделям памяти,
их краткое описание и мотивация их введения:

\begin{itemize}
  \item Корректность компиляции.
  \item Корректность трансформаций программ.
  \item Предоставляемые гарантии для рассуждения о поведении программ.
    Здесь также будет сделан акцент на инструментах
    для верификации многопоточных программ. 
\end{itemize}

\subsection{Классы моделей памяти}

Основные классы моделей памяти (по материалам обзорной статьи~\cite{Moiseenko-al:PCS21}).
Описание свойств этих классов и компромиссов в их дизайне
в соответствии с требованиями, предъявленными в предыдущем разделе. 

\subsection{Итог}

Подведение итога обзора моделей памяти.
Фрагмент сравнительной таблицы из обзорной статьи~\cite{Moiseenko-al:PCS21}.
Обозначение research gaps, которые закрывает данная диссертация, а именно:

\begin{itemize}
  \item классическая теория стуктур событий для моделей памяти
    сохраняющих программный порядок;
  \item корректность компиляции для модели \Wkm;
  \item автоматическая верификация многопоточных программ
    (model checking) в модели \WkmS.
\end{itemize}

\section{Формальная семантика параллельных программ и моделей памяти}

В этом разделе приводятся определения различных формализмов,
используемых для задания семантики многопоточных программ и моделей памяти.
В разделе \cref{sec:lts} дано определение \emph{систем помеченных переходов}
и \emph{операционных семантик с чередованием} 
(\emph{interleaving operational semanitcs}).
В разделе \cref{sec:pomsets-eventstruct} приводится альтернативный способ
задания семантики многопоточных программ без чередования 
(\emph{non-interleaving}) 
с помощью семантических доменов \emph{истинной конкурентности} 
(\emph{true concurrency}), а именно 
\emph{языков частично упорядоченных мультимножеств} и \emph{структур событий}.
В разделе \cref{sec:exec-graphs} вводится понятие графов сценариев исполнения
и аксиоматических моделей памяти, а также приводится краткое сравнение
графов сценариев исполнения и частично упорядоченных мультимножеств.
Наконец, в разделе \cref{sec:wkmo-eventstruct} вводится
специальный тип структур событий, используемых в модели \Wkm.

\subsection{Системы помеченных переходов}
\label{sec:lts}

Системы помеченных переходов являются традиционным 
способом задания операционной семантики. 
Системы помеченных переходов это (потенциально бесконечный) граф, 
вершины в котором представляют внутрение состояния системы, а
ребра соответствуют выполнению шага вычислений. 
Метка ребра задает видимый эффект выполения данного шага вычислений.
%% Множество трасс автомата задает его ``последовательную'' спецификацию, 
%% а список меток, индуцируемый трассой, определяет
%% наблюдаемое поведение автомата. 

\begin{definition}
  \label{def:lts}
  \emph{Система помеченных переходов} --- это тройка
    $\LTS \defeq \tup{\State, \Label, \TrRel}$, где 
  \begin{itemize}
    \item $\State$ --- множество состояний;
    \item $\Label$ --- множество меток, также называемое \emph{алфавитом};
    \item $R \subseteq L \times S \times S$ --- помеченное отношение перехода.
  \end{itemize}
  Для обозначения наличия перехода между состояниями используется следующая нотация:
    \[
    \begin{array}{lcr@{\hspace{3em}}lcr}
    \ltr[R]{\ell}{s}{s'} & \defeq & \step{\ell}{s}{s'} \in \TrRel                     &
    \tr[R]{s}{s'}        & \defeq & \exists \ell \ldotp \step{\ell}{s}{s'} \in \TrRel \\
    \end{array}
    \]
  \emph{Трассой} помеченной системой переходов называется чередующаяся последовательность  
  состояний $s_0, s_1, \ldots, s_n \in \Label$ 
  и меток $\ell_1, \ldots, \ell_n \in L$, 
  такая что выполняется условие
  $$s_0 \xrightarrow{\ell_1} s_1 \xrightarrow{\ell_2} s_2 \xrightarrow{\ell_3} \ldots \xrightarrow{\ell_n} s_n$$
  Язык, принимаемый системой переходов в начальном состоянии $s_0$ 
  это множество последовательностей слов над алфавитом $\Label$, 
  таких что для каждого слова существует соответствующая 
  трасса, начинающася в $s_0$:
  $$ \langof{\LTS, s_0} \defeq \set{ 
       \ell_1 \ldots \ell_n ~|~ \exists s_1, \ldots, s_n \ldotp 
       s_0 \xrightarrow{\ell_1} s_1 \xrightarrow{\ell_2} \ldots \xrightarrow{\ell_n} s_n
     } 
  $$
  
\end{definition}

\input{Dissertation/fig/lts-lang-ex}

На \cref{fig:lts-ex} показан пример системы помеченных переходов, 
а на \cref{fig:lang-ex} пример языка, 
принимаемаемого этой системой в состоянии $s_0$.

В рамках так называемой операционной семантики с чередованием
(interleaving semantics) поведение многопоточной программы
определяется как поочередное исполнение атомарных действий параллельных потоков.

\begin{definition}
  \label{def:lts-par}
  Параллельной композицией двух систем переходов $\LTS_1$ и $\LTS_2$
  будем называть систему переходов
  $\parlts{\LTS_1}{\LTS_2} \defeq \tup{\State_1 \times \State_2, \Label, \TrRel_{\parSymb}}$
  где $\TrRel_{\parSymb}$ определяется следующим образом:
  \begin{itemize}
    \item $\ltr[\TrRel_1]{\ell}{s_1}{s'_1}$ влечет
          $\ltr[\TrRel_{\parSymb}]{\ell}{\tup{s_1, s_2}}{\tup{s'_1, s_2}}$, и
    \item $\ltr[\TrRel_2]{\ell}{s_2}{s'_2}$ влечет
          $\ltr[\TrRel_{\parSymb}]{\ell}{\tup{s_1, s_2}}{\tup{s_1, s'_2}}$.
  \end{itemize}
\end{definition}

Если при этом потоки имеют доступ к общему ресурсу 
(например, разделяемой памяти), то в таком случае можно
семантику ресурса также задать с помощью системы переходов
а затем рассмотреть произведение параллельной композиции потоков и ресурса.  

\begin{definition}
  \label{def:lts-par}
  Произведением двух систем переходов $\LTS_1$ и $\LTS_2$
  будем называть систему переходов
  $\prodlts{\LTS_1}{\LTS_2} \defeq \tup{\State_1 \times \State_2, \Label, \TrRel_{\prodSymb}}$
  где $\TrRel_{\prodSymb}$ определяется следующим образом:
  \begin{itemize}
    \item $\ltr[\TrRel_{\prodSymb}]{\ell}{\tup{s_1, s_2}}{\tup{s'_1, s'_2}}$ 
      тогда и только тогда, когда 
      $\ltr[\TrRel_1]{\ell}{s_1}{s'_1}$ и $\ltr[\TrRel_2]{\ell}{s_2}{s'_2}$.
  \end{itemize}
\end{definition}

Таким образом, если система помеченных переходов $\LTS_{\thrdSymb}$ 
задает семантику потоков, а система $\LTS_{\resSymb}$ --- 
семантику разделяемого ресурса, тогда 
$(\LTS_{\thrdSymb} \parSymb \dots \parSymb \LTS_{\thrdSymb}) \prodSymb \LTS_{\resSymb}$
задает семантику всей системы, состоящей из $n$ потоков и разделяемого ресурса.

\subsection{Языки помсетов и простые структуры событий}
\label{sec:pomsets-eventstruct}

Операционные семантики с чередованием представляют 
простой и интуитивно понятный подход для моделирования
многопоточных программ. Однако его недостаток заключается в том, 
что с ростом программы экспоненциально растет количество трасс, 
допустимых операционной семантикой. 

В попытке преодолеть эту проблему, исследователями 
были предложены различные альтернативные 
подходы к заданию семантики многопоточных программ, 
которые позволяют более компактно представить пространство 
возможных сценариев поведения таких программ. 
Данный класс семантик принято называть 
\emph{семантиками без чередования} (\emph{non-interleaving semantics})
или также \emph{истинно конкурентными семантиками}
(\emph{true concurrent semantics})~\cite{Nielsen:REX93}.
Из данного класса семантик в рамках 
данной диссертации интерес представляют 
\emph{языки частично упорядоченных мультимножеств}
(кратко --- языки помсетов)~\cite{Pratt:CONCUR84,Gischer:TCS88}, 
и \emph{структуры событий}~\cite{Winskel:86}.

Языки помеченных частично упорядоченных множеств является
обощением понятия обычных ``последовательных'' языков, 
то есть множества слов данного алфавита. 
Обобщение заключается в переходе от линейного порядка 
на символах алфавита в рамках слова к частичному порядку.
Частично упорядоченное множество соответствует одному
сценарию исполнения многопоточной программы.
Элементы этого множества представляют
атомарные шаги вычисления и называются \emph{событиями}.
Каждому событию ставится в соответствие семантическая \emph{метка} ---
символ заданного алфавита.
Если событие $e_1$ упорядочено перед ~$e_2$, $e_1 \ca e_2$, 
тогда считается что событие~$e_2$ в
сценарии исполнения программы зависит от события~$e_1$.
Если не выполняется ни $e_1 \ca e_2$ ни $e_2 \ca e_1$ 
тогда события $e_1$ и $e_2$ считаются параллельными, 
$e_1 \co e_2$. 

\begin{definition}
  \label{def:lposet}
  \emph{Помеченное частично упорядоченное множество} над алфавитом $\Label$, 
  это тройка $\tup{\Event, \lab, \ca}$, где 
  \begin{itemize}
    \item $\Event$ это множество \emph{событий};
    \item $\lab : \Event \fun \lab$ \emph{функция разметки событий};
    \item $\ca \subseteq \Event \times \Event$ это частичный порядок 
      \emph{причинно-следственной связи} между событиями. 
  \end{itemize}
  Множество всех помеченных частично упорядоченных множеств над алфавитом $\Label$
  будем обозначать как $\lPoset[\Label]$. 
\end{definition}

Отметим, что при работе c помеченными частично упорядоченными множествами
конкретные идентификаторы событий как правило неважны,
важна лишь их разметка и отношение причинно-следственной связи между ними.
Таким образом, с помеченными частично упорядоченными множествами 
работают по модулю переименования событий, то есть с точностью до изоморфизма.

\begin{definition}
  \label{def:lposet-morph}
  Рассмотрим $p, q \in \lPoset[\Label]$. Функция $f : E_p \fun E_q$ называется:
  \begin{itemize}
    \item \emph{сохраняющей метки} если ${\lab_q(f(e)) = \lab_p(e)}$;
    \item \emph{сохраняющей порядок} если ${e_1 \ca_p e_2}$ влечет ${f(e_1) \ca_q f(e_2)}$;
    \item \emph{вкладывающей порядок} если ${e_1 \ca_p e_2}$ тогда и только тогда, когда ${f(e_1) \ca_q f(e_2)}$.
  \end{itemize}
  \emph{Гомоморфизмом} частично упорядоченных помеченных множеств называется
  функция, сохраняющая метки и порядок. Если более того эта фунцкия
  биективна и вкладываюет порядок, то она называется изоморфизмом.
  Запись $p \iso q$ означает что $p$ и $q$ изоморфны,
  то есть существует изоморфная функция между носителями $p$ и $q$.
\end{definition}

\begin{definition}
  \label{def:pomset}
  Помеченные частично упорядоченные мультимножества, 
  или, кратко, \emph{помсеты} (от англ. \emph{partially ordered multiset, pomset}), 
  это классы помеченных частично упорядоченных множеств по модулю изоморфизма: 
  $${\Pom[\Label] \defeq \lPoset[\Label] / {\iso}}.$$ 
  Язык помсетов --- это множество помсетов: 
  $${\Pomlang[\Label] \defeq \pwset{\Pom[\Label]}}.$$ 
\end{definition}

\input{Dissertation/fig/pom-es-ex}

На \cref{fig:pom-ex} можно видеть пример языка помсетов. 
Этот язык помсетов кодирует обычный язык, показанный \cref{fig:lang-ex}, 
так как каждое слово из обычного языка является дополнением некоторого 
частичного упорядоченного множества из языка помcетов
до линейно упорядоченного множества. 
Формально, связь языка помсетов и обычного языка можно установить 
с помощью понятия \emph{линеаризации помсета}.

\begin{definition}
  \label{def:pomset-subs}
  Помсет $p$ \emph{поглощается} $q$, $p \subs q$, 
  если существует биективный гомоморфизм из $q$ в $p$.
  В таком случае также говорят, что $p$ более упорядочено чем $q$.
\end{definition}

\begin{definition}
  \label{def:pomset-lin}
  Помсет $p$ является линеаризацией $q$, 
  что обозначается как $p \in \Lin{q}$,
  если $p$ является линейно упорядоченным и 
  поглощается $q$, $p \subs q$.
  Линеаризация языка помсетов $P$ определяется 
  как объединение линеаризации всех входящих в язык помсетов:
  $$ \Lin{P} \defeq \bigcup_{p \in P}\Lin{p} $$
  Наконец, можно сказать что язык помсетов $P \in \Pomlang[\Label]$
  соответствует обычному языку $L \in \Lang{\Label}$, если $\Lin{P} = L$.
\end{definition}

%% Определение языков помсетов и класса простых структур событий.
%% Связанные определения и простейшие свойства. 

\subsection{Графы сценариев исполнения}
\label{sec:exec-graphs}

Определение аксиоматических моделей памяти и графов сценариев исполнения.

\subsection{Структуры событий в модели \Wkm}
\label{sec:wkmo-eventstruct}

Определение класса структур событий, использующихся в модели \Wkm.
