\chapter{Верификация методом проверки модели для \WkmS}
\label{ch:mc-weakestmo2}

В данной главе описывается разработанный в рамках данной диссертации 
инструмент проверки моделей \wmc для верификации 
многопоточных программ в модели \WkmS.
Предложенный инструмент разработан на основе \genmc --- 
инструмента для автоматической верификации многопоточных программ, 
написанных на языке \CLANG, в модели памяти \RCMM. 
Таким образом предложенный \wmc расширяет 
оригинальный инструмент \genmc, 
добавляя в него поддержку модели памяти \WkmS.  

Алгоритм, лежащий в основе \wmc, полагается на новые свойства модели \WkmS, 
а именно свободу от буферизации операций чтения и 
локальность сертификации, чтобы реализовать ключевые 
оптимизации и сделать верификацию в модели \WkmS возможной на практике.  
В рамках серии экспериментов показывается, что 
\wmc обладает лучшей производительностью по сравнению с аналогами.

Данная глава организована следующим образом. 
В разделе \ref{sec:mc-wmm} дано краткое введение 
в задачу верификации методом проверки моделей 
в контексте слабых моделей памяти.
В разделе \ref{sec:genmc} описывается оригинальный инструмент 
\genmc.
В разделе \ref{sec:wmc} описывается разработанный в 
рамках данной диссертации инструмент \wmc.
Наконец, в разделе \ref{sec:wmc-eval} описаны эксперименты 
по измерению производительности \wmc и его сравнению с аналогами.

\section{Метод проверки моделей для слабых моделей памяти}
\label{sec:mc-wmm}

\emph{Метод проверки моделей} (\emph{model checking}) 
является одним из методов формальной автоматической верификации программ,
целью которого является проверка удовлетворяет ли 
модель программы заданной спецификации~\cite{Baier:2008}. 
В контексте данной работы будем говорить только 
о проверке свойств \emph{безопасности} (\emph{safety properties}), 
то есть свойств утверждающих, что некоторое 
``плохое'' событие никогда не произойдет. 

Метод проверки моделей с \emph{явным представлением состояний} 
(\emph{explicit-state model checking}) достигает 
этой цели путем явного построения пространства состояний программы 
и перечисления возможных сценариев ее исполнения.
Поскольку количество возможных сценариев исполнения 
растет экспоненциально с ростом программы, 
перечисление всех возможных сценариев исполнения 
на практике не предоставляется возможным. 

\emph{Проверка моделей без сохранения состояний} 
(\emph{stateless model checking}) позволяет 
избежать экспоненциального потребления памяти 
на хранение всего пространства состояний программы 
и достичь полиномиального потребления памяти  --- 
в каждый момент времени алгоритм проверки моделей 
сохраняет только один сценарий исполнения программы 
и некоторую дополнительную информацию.

Проверка моделей без сохранения состояний зачастую 
используется в комбинации с техникой  
\emph{редукции частичного порядка} (\emph{partial order reduction}), 
которая позволяет сократить пространство перебора. 
В основе этой техники лежит наблюдение, что 
порядок выполнения некоторых операций программы 
не имеет значения для конечного результата, 
то есть, что некоторые операции коммутируют. 
Таким образом все сценарии исполнения можно разбить 
на классы эквивалентности, где каждый класс 
можно представить отношением частичного порядка. 
Тогда достаточно рассмотреть только один сценарий исполнения из каждого класса.   

В контексте слабых моделей памяти принято рассматривать 
$\lPORF$-эквивалентность сценариев исполнения%
~\cite{Chalupa-al:POPL2017,Abdulla-al:OOPSLA2018,Abdulla-al:OOPSLA2019},
то есть эквивалентность с точностью до отношений $\lPO$ и $\lRF$ 
на соответствующих графах сценариев исполнения.
Иногда также рассматривается $\lPORFMO$-эквивалентность%
~\cite{Abdulla-al:TACAS2015,Kokologiannakis:PLDI2019}, 
то есть эквивалентность с точностью до отношений $\lPO$, $\lRF$ и $\lMO$. 
Таким образом задача проверки моделей в контексте 
слабых моделей памяти сводится к задаче перечисления 
консистентных графов сценариев исполнения заданной программы. 

\section{Инструмент \genmc}
\label{sec:genmc}

Данный инструмент выполняет автоматическую верификацию многопоточных программ
методом проверки моделей с явным представлением состояний, но без сохранения
пространства состояний (explicit-state stateless model checking)~\cite{Kokologiannakis:PLDI2019, Kokologiannakis:CAD2021}.
\genmc в первую очередь предназначен 
для верификации программ, написанных на языке \CLANG, 
но может быть адаптирован для других языков программирования, 
поддерживающих компиляцию в промежуточное представление \LLVM.  
По умолчанию \genmc осуществляет верификацию  в модели памяти \RCMM,
однако инструмент потенциально поддерживает 
произвольные модели памяти, сохраняющие программный порядок.
\genmc использует технику редукции частичных порядков
и позволяет пользователю выбрать либо редукцию по
отношению $\lPORF$-эквивалентности, либо по отношению $\lPORFMO$-эквивалентности.
В рамках данной работы будем подразумевать, что используется
редукция по отношению $\lPORFMO$-эквивалентности,
так как данный тип редукции частичных порядков 
проще адаптировать для модели \WkmS.

Инструмент \genmc состоит из двух основных компонент: 
\emph{интерпретатора} и \emph{драйвера}~\cite{Kokologiannakis:CAD2021}. 
\textbf{Интерпретатор} выполняет исполнение биткода \LLVM  
и оповещает драйвер о наступлении определенных событий 
(например, о выполнении инструкций чтения или записи в разделяемую память). 
\textbf{Драйвер} в свою очередь 
ответственен за генерацию сценариев исполнения программы и 
проверку их консистентности согласно заданной модели памяти.
Для выполнения этих задач драйвер поддерживает несколько структур данных, 
в том числе текущий граф сценария исполнения
%%  и множество перепосещаемых вершин, 
%% то есть подмножество событий чтения в этом графе 
%% которые в дальнейшем могут быть повторно рассмотрены драйверомм 
%% с целью исследования альтернативных сценариев исполнения.

Для добавления поддержки новой модели памяти в \genmc 
предполагается разработка нового драйвера, специфичного 
для данной конкретной модели памяти.
При этом, с целью лучшего переиспользования программного кода
в соответствии с принципами объектно-ориентированного программирования, 
допускается наследование классов, реализующих драйверы. 
Расширение инструмента \genmc с целью поддержки 
модели памяти \WkmS было реализовано именно таким образом ---
путем добавления нового драйвера, который наследует 
от драйвера для модели памяти \RCMM.
Поэтому, чтобы разобрать алгоритм, реализованный в новом драйвере, 
необходимо сначала разобрать алгоритм работы драйвера для модели \RCMM.

\subsection*{Алгоритм генерации \RCMM-консистентных сценариев}

На листинге~\ref{alg:visit} представлен 
псевдокод алгоритма генерации консистентных сценариев исполнения,
реализованного в драйвере \genmc для модели \RCMM. 
Фрагменты псевдокода, выделенные светло-синим цветом \alghl{\quad\quad},
%{\sethlcolor{lightcyan}\hl{\quad\quad\quad}}, 
отображают изменения, внесенные в драйвер для поддержки модели \WkmS.
Эти изменения обсуждаются далее в разделе \ref{sec:wmc}
и на данный момент могут быть проигнорированы.

\input{Dissertation/alg/visitone}

Рекурсивная процедура \visit принимает на вход программу $\prog$,
текущий граф сценария исполнения $G$ 
(изначально на вход процедуре подается пустой граф).
Также процедура поддерживает множество 
перепосещаемых вершин графа $G.\lT$ (также изначально пустого).
Это множество состоит из событий чтения, принадлежащих графу $G$, 
которые в дальнейшем могут быть повторно рассмотрены алгоритмом 
с целью исследования альтернативных сценариев исполнения.

В первую очередь при вызове процедура \visit проверяет, 
является ли текущий граф $G$ \RCMM-консистентным (строка~\ref{visit:cons}).
Заметим, что для того, чтобы адаптировать алгоритм к произвольной модели памяти, 
сохраняющей программный порядок, достаточно только
заменить эту проверку на проверку консистентности 
согласно требуемой модели памяти. 

Далее алгоритм выбирает следующее событие $a$ (строка~\ref{visit:switch}), 
генерируемое при исполнении программы $\prog$,
используя вспомогательную функцию $\nextE$ (строка~\ref{visit:switch}).
Если исполнение программы завершилось, то 
$\nextE$ возвращает специальное значение $\bot$ (строка~\ref{visit:done})
и выполнение процедуры \visit оканчивается --- 
при этом полученный граф $G$ является 
полным консистентным графом программы $\prog$.
Если во время исполнения программы произошла ошибка
(например, нарушении пользовательской проверки (\texttt{assert}) 
или выход за границы массива) тогда 
$\nextE$ возвращает специальное значение $\lERR$ (строка~\ref{visit:error})
и выполнение процедуры \visit обрывается с сообщением об ошибке. 
Иначе событие $a$ также добавляется в текущий граф $G$
и далее рассматриваются различные случаи, в зависимости от типа нового события.

Если $a$ --- это событие чтения, тогда 
процедура $\visit$ рекурсивно исследует все возможные графы
для каждого возможного события записи,
из которого может прочитать значение $a$.  
Вспомогательная функция $\getReadsFrom$
возвращает множество событий записи, 
которые могут образовать ребро $\lRF$ с новым событием $a$.
Для каждого такого события $w$ создается новый граф $G'$
путем добавления нового $\lRF$ ребра в текущий граф $G$ 
с помощью функции $\setRF$. 
Отметим, что при этом в новом графе событие $a$
также помечается как перепосещаемое: $a \in G'.\lT$.
Далее на каждом таком графе рекурсивно вызывается 
процедура $\visit$ (строки~\ref{visit:getrfs}~и~\ref{visit:visit-rfs}).

Если $a$ --- это событие записи, тогда после 
рекурсивного вызова (строка~\ref{visit:visit-w}) 
процедура \visit также проверяет, может ли событие $a$
\emph{перепосетить} некоторые события чтения в графе $G$.
То есть, процедура \visit рекурсивно исследует все графы, 
которые могут быть получены путем замены события записи, 
из которого читает некоторое событие $r \in G.\lR$, 
на новое событие $a$. Для этого вызывается 
вспомогательная процедура $\calcRevisits$ (строка~\ref{visit:calcrevisits}).

\input{Dissertation/alg/calcrevisits}

Псевдокод этой процедуры показан на листинге~\ref{alg:calcrevisits}. 
На первом шаге выполнения процедуры вызывается 
функция \getRevisitable (строка~\ref{calcrevisits:push-normal-revs}). 
Эта функция возвращает множество пар $\tup{w, r}$ 
состоящих из события записи $w$ и события чтения $r$, 
таких что событие $r$ может быть перепосещено 
путем замены записи, из которой оно читает, на запись $w$.
Обратим внимание, что функция \getRevisitable отфильтровывает 
события чтения $r$, перепосещение которые может привести к 
появлению $\lPORF$ цикла (то есть $r \notin \dom{G.\lPORF;[a]}$).
Для каждой такой пары $\tup{w, r}$ создается новый граф $G'$
(строка~\ref{calcrevisits:restrict}). 
Граф $G'$ получается путем ограничения текущего графа $G$
на множество событий, добавленных перед событием $r$, 
и события $w$ вместе с его $\lPORF$ префиксом. 
При этом множество $G'.\lT$ получается путем ограничения его 
на множество событий чтения, добавленных перед событием $r$ включительно.
Наконец, на каждом полученном таким образом графе $G'$ 
рекурсивно запускается процедура $\visit$ (строка~\ref{calcrevisits:visit-revs}).

В случае же, если $a$ --- это не событие чтения или записи 
(а, например, событие барьера памяти), 
тогда процедура $\visit$ просто запускается рекурсивно
(строка~\ref{visit:default} в листинге~\ref{alg:visit}).

\subsection*{Пример работы алгоритма}
\label{sec:genmc-ex}

Продемонстрируем на примере программы~\ref{ex:lb-nodep}
из раздела~\ref{sec:models-classes}, 
как процедура \visit генерирует все \RCMM консистентные сценарии исполнения.
Напомним, что данная программа имеет три \RCMM консистентных сценария исполнения
(графы \circledb{A}, \circledb{B} и \circledb{C} 
на рисунке~\ref{fig:lb-nodep-execs}).

Процедура \visit начинает выполнение с пустым графом.
На первом шаге происходит исполнение инструкции $a := x$
и в граф добавляется новое событие чтения $\rlab{}{x}{0}$.
Заметим, что на данном этапе в графе нет других событий записи
в переменную $x$, кроме инициализирующей записи, поэтому 
в строках~\ref{visit:getrfs}-\ref{visit:visit-rfs} листинга~\ref{alg:visit} 
произойдет только один рекурсивный вызов процедуры \visit.
Аналогично, на следующем шаге происходит исполнение инструкции $y := 1$
и в граф добавляется новое событие записи $\wlab{}{y}{1}$.
Так как в графе нет событий чтения из переменной $y$,
функция \getRevisitable возвращает пустое множество 
(строка~\ref{calcrevisits:push-normal-revs} листинга~\ref{alg:calcrevisits})
и снова происходит только один рекурсивный вызов процедуры \visit
(строка~\ref{visit:visit-w} листинга~\ref{alg:visit}).
Первые два шага алгоритма показаны на рисунке ниже. 

\input{Dissertation/fig/alg-lb-step1}

Далее происходит исполнение инструкции $a := y$.
Однако на этот раз происходит два рекурсивных вызова 
процедуры \visit: в одном из них новое событие 
читает значение $0$ из инициализирующей записи, а в другом 
читает значение $1$ из записи $\wlab{}{y}{1}$.
Рассмотрим сначала первый случай --- тогда 
меткой нового события является $\rlab{}{y}{0}$.

Когда на следующем шаге будет исполнена инструкция $x := b$, 
процедура $\visit$ также будет рекурсивно вызвана дважды:
в одном случае новое событие $\wlab{}{x}{1}$ не будет использовано
для перепосещения других событий чтения, а во втором случае
это событие будет использовано для перепосещения события чтения $\rlab{}{x}{0}$ 
(строка~\ref{calcrevisits:visit-revs} листинга~\ref{alg:calcrevisits}).
В первом случае рекурсивный вызов процедуры \visit завершится 
на строке \ref{visit:output}, завершив исследование 
одного полного \RCMM консистентного графа сценария исполнения
(этот граф соответствует графу \circledb{A} на рисунке~\ref{fig:lb-nodep-execs}).

\input{Dissertation/fig/alg-lb-step2}

Во втором случае происходит перепосещение события чтения $\rlab{}{x}{0}$ 
событием записи $\wlab{}{x}{0}$ (шаг \circledb{5} на рисунке ниже). 
%% Ниже показан граф, который передается 
%% в качестве аргумента при рекурсивном вызове процедуры \visit. 

\input{Dissertation/fig/alg-lb-step3}

Напомним, что процедура \calcRevisits ограничивает граф перед тем 
как рекурсивно вызвать процедуру \visit  
(строка~\ref{calcrevisits:restrict} листинга~\ref{alg:calcrevisits}).
В результате, граф содержит только события, которые были добавлены 
перед перепосещаемым событием чтения $\rlab{}{x}{0}$ 
(то есть только само это событие), 
а также событие записи $\wlab{}{x}{1}$ и всех его $\lPORF$ предшественников
(в данном случае это единственное событие $\rlab{}{y}{0}$).
На следующем шаге вновь выполняется инструкция $y := 1$ 
и событие $\wlab{}{y}{1}$ снова добавляется в граф.
На этот раз добавление этого события записи не приводит 
к перепосещению события чтения $\rlab{}{y}{0}$, 
так как оно не принадлежит к множеству перепосещаемых вершин $G.\lT$
(смотри псевдокод функции \getRevisitable на листинге~\ref{alg:calcrevisits}). 
Напомним, что при ограничении графа это множество также уменьшается 
и содержит только события чтения, добавленные до 
перепосещаемого события включительно 
(то есть до события $\rlab{}{x}{0}$ в данном случае). 
На этом заканчивается исследование еще одного консистентного графа, 
соответствующего графу \circledb{B} на рисунке~\ref{fig:lb-nodep-execs}.  

После этого выполнение алгоритма откатывается 
к рекурсивному вызову процедуры \visit, 
которое исследует альтернативный выбор ребра отношения $\lRF$
для события $\rlab{}{y}{0}$ 
(напомним, что этот рекурсивный вызов был сделан на шаге \circledb{3}).
 
\input{Dissertation/fig/alg-lb-step4}

Далее происходит выполнение инструкции $x := b$ 
и добавление события $\wlab{}{x}{1}$ в граф. 
Добавление этого события не приводит к перепосещению 
события чтения $\rlab{}{x}{0}$, на этот раз по причине того, 
что это событие упорядочено перед событием $\wlab{}{x}{1}$
согласно отношению порядка $\lPORF$.
На этом заканчивается исследование последнего консистентного графа, 
который соответствует графу \circledb{C} на рисунке~\ref{fig:lb-nodep-execs}.  

\section{Инструмент \wmc}
\label{sec:wmc}

Как уже упоминалось инструмент \wmc был разработан на базе \genmc 
путем добавления нового драйвера для модели \WkmS.
Этот драйвер, в свою очередь, наследуется от драйвера для модели \RCMM 
и модифицирует алгоритм генерации сценариев исполнения. 

\subsection*{Алгоритм генерации \WkmS-консистентных сценариев}

В псевдокоде на листингах~\ref{alg:visit} и ~\ref{alg:calcrevisits}
изменения, внесенные при реализации нового драйвера, 
выделены светло-синим цветом \alghl{\quad\quad}.
Разребем эти изменения. 

Начнем с листинга~\ref{alg:visit}. 
Обратим внимание, что у процедуры \visit появился 
еще один аргумент --- \emph{множество обещаний} $\pSet$.
Это множество содержит пары состоящие из событий записи, 
которые были ``обещаны'', то есть исполнены спекулятивно вне очереди,
и фрагмента графа сценария исполнения. 
Этот фрагмент включает в себя $\lPORF$ префикс события записи в графе, 
соответствующем спекулятивному сценарию исполнения программы.

Если переданное в процедуру \visit множество $\pSet$ не пусто, 
будем говорить, что алгоритм находится в \emph{фазе сертификации}.
Во время этой фазы алгоритм должен в первую очередь исполнить все сделанные обещания
и отложить все перепосещения, а также исследование всех сценариев исполнения, 
полученных в результате добавления нелокальных событий чтения 
(смотри разделы~\ref{sec:cert-loc}, \ref{sec:mc-opt} и \ref{sec:wkmo2}). 
Чтобы достичь этого, функция $\nextE$ (строка~\ref{visit:switch})
была модифицирована таким образом,
чтобы во время фазы сертификации возвращать события из того потока, 
в котором были сделаны обещания, пока либо все обещания 
не будут сертифицированы, либо выполнение этого потока не окончится
(в последнем случае функция возвращает значение $\bot$).

В случае, когда функция $\nextE$ возвращает $\bot$,
в алгоритм также была добавлена проверка того, 
что множество обещаний $\pSet$ пусто 
(строка~\ref{visit:done-certified}).
Действительно, если данное множество не пусто, это 
означает что алгоритм не смог успешно сертифицировать все сделанные обещания.
В этом случае текущий сценарий исполнения считается \emph{заблокированным}.  

Далее рассмотрим случай, когда новое событие $a$ является событием чтения.
Для обработки этого случая была модифицирована функция \getReadsFrom.
В фазе сертификации эта функция подсчитывает и возвращает 
только множество локальных событий чтения
(строки~\ref{getrfs:p-nonempty}-\ref{getrfs:restrict-local}
в псевдокоде функции \getReadsFrom на листинге~\ref{alg:visit}).
Рассмотрение всех остальных событий записи кандидатов на чтение
откладывается до окончания фазы сертификации (смотри далее). 

В случае когда новое событие $a$ является событием записи,
в фазе сертификации выполняется проверка совпадает 
ли эта запись с одним из обещаний (строка~\ref{visit:p-pop}).
Если это так, то совпадающее обещание считается сертифицированным.
В таком случае в переменную $\pSet'$ присваивается обновленное множество обещаний
из которого было удалено сертифицированное обещание.   
Далее выполняется проверка, заканчивается ли на этом процесс сертификаци, 
то есть было ли сертифицированно последнее оставшееся обещание
(строка~\ref{visit:cert-over}).
Таким образом, процедура \calcRevisits вызывается только \textbf{вне} фазы сертификации.

Далее рассмотрим изменения, внесенные в процедуру \calcRevisits.
В строках \ref{calcrevisits:cert-finished}-\ref{calcrevisits:get-nonlocal-revs}
происходит обработка случая, когда алгоритм только что закончил 
фазу сертификации обещаний. 
В этом случае вместо функции \getRevisitable вызывается функция \getCertRevs, 
псевдокод которой показан на листинге~\ref{alg:certrevs}.
Эта функция подсчитывает множество перепосещений, 
отложенных во время фазы сертификации (строка~\ref{certrevs:delayed}),
а также множество перепосещений локальных событий чтения 
(строка~\ref{certrevs:non-local}).
Перепосещение этих событий чтения приведет к исследованию 
сценариев исполнения, в которых выполняется нелокальная операция чтение. 

\input{Dissertation/alg/certrevs}

Обратим внимание, что в функцию \getRevisitable (листинг~\ref{alg:calcrevisits})
также были внесены изменения. Помимо перепосещаемых событий чтения, 
которые не предшествуют согласно отношению $\lPORF$ событию записи $a$ (аргументу функции),
эта функция теперь также возвращает события чтения $\lPORF$-предшествующие $a$,
если они находятся в состоянии \LB гонки с $a$ 
(смотри определение~\ref{def:lb-race}).
Таким образом, функция \getRevisitable создает перепосещения, 
которые потенциально могут привести к исследованию $\lPORF$
цикличных графов сценариев исполнения.

Продолжая обсуждать изменения, внесенные в процедуру \calcRevisits,
рассмотрим строки~\ref{calcrevisits:restrict}-\ref{calcrevisits:promises}.
Во-первых, заметим, что при ограничении графа 
процедура \calcRevisits теперь также удаляет из графа все события, 
следующие за перепосещаемым событием чтения $r$ в программном порядке 
(строка~\ref{calcrevisits:restrict}).
Эти события необходимо удалить, так как их появление 
в графе может зависеть от значения, прочитанного событием $r$.
Однако, некоторые из удаляемых событий записи должны быть 
затем вновь добавлены в фазе сертификации,
поскольку от них могут зависеть события в других потоках графа --- 
иными словами эти события и составляют множество обещаний.  
За подсчет множества обещаний отвечает функция \calcPromises
(строка~\ref{calcrevisits:promises}), псевдокод которой 
продемонстрирован на листинге~\ref{alg:getpromises}.

\input{Dissertation/alg/getpromises}

Функция \calcPromises принимает в качестве аргументов 
граф $G$, перепосещаемое событие чтения $r$ и множество событий $S$.
Эта функция возвращает все события записи, 
которые следуют в программном порядке за событием $r$,
прочитаны каким-либо внешним событием чтения и 
предшествуют согласно отношению $\lPORF$ событию из множества $S$.

Осталось лишь разобрать, что именно передается 
в процедуру \calcPromises в качестве множества $S$ 
(строка~\ref{calcrevisits:promises} в листинге~\ref{alg:calcrevisits}).
В первую очередь в состав множества $S$ входит
сама запись $w$, которая используется для перепосещения события чтения $r$.
В случае когда процедура \calcRevisits вызывается 
сразу после окончания фазы сертификации, в состав множества 
$S$ также включается событие $a$, которое является 
событием записи, сертифицирующим последнее обещание. 
Это необходимо, чтобы только что созданный $\lPORF$ цикл 
также был восстановлен в графе после перепосещения.  

\input{Dissertation/fig/lb-cyc}

Чтобы объяснить назначение последнего компонента $\getLastCycle(G, r)$, 
включенного в множество $S$, рассмотрим показанный на рисунке~\ref{fig:lb-cyc} пример. 
Чтобы сгенерировать показанный на рисунке граф, 
необходимо перепосетить событие чтения из переменной $z$
в среднем потоке после того, как был исследован граф,
содержащий $\lPORF$ цикл между событиями чтения и записи 
из переменных $x$ и $y$.
Действительно, изначально инструкция чтения $\readInst{}{r}{z}$
может прочитать значения $0$ или $1$, а инструкция $\readInst{}{s}{x}$
может почитать только значение $0$.
При этом инструкция $\writeInst{}{y}{1}$ будет исполнена 
только если инструкция $\readInst{}{r}{z}$ прочитает $0$.
Следовательно, и граф сценария исполнения, содержащий $\lPORF$ цикл,
может появиться только в этом случае. 
После окончания исследования $\lPORF$ цикличного графа, 
в котором инструкция $\readInst{}{r}{z}$ читает $0$, 
уже можно перепосетить соответствующее событие чтения 
и прийти к графу, показанному на рисунке. 

Чтобы обработать этот случай после окончания фазы сертификации
необходимо перепосетить все локальные события чтения в потоке, 
для которого выполнялась сертификация
(смотри псевдоков функции \getCertRevs в листинге~\ref{alg:certrevs}).
Кроме того, для каждого такого чтения $r$ необходимо 
гарантировать что $\lPORF$ циклы, которые включают 
события следующие за $r$ в программном порядке, 
будут восстановлены после перепосещения события $r$.
Решить эту задачу позволяет добавление в множество $S$ 
последнего компонента $\getLastCycle(G, r)$, 
включающего все события в сертифицируемом потоке,  
которые принадлежат к обозначенным $\lPORF$ циклам.

\subsection*{Пример работы алгоритма}

Вновь вернемся к программе~\ref{ex:lb-nodep}
чтобы на ее примере показать, как модифицированный алгоритм генерирует 
$\lPORF$ цикличные \WkmS консистентные графы сценариев исполнения.
Напомним, в дополнение к трем $\lPORF$ ацикличным и \RCMM-консистентным графам
(графы \circledb{A}, \circledb{B} и \circledb{C} 
на рисунке~\ref{fig:lb-nodep-execs})
модельь \WkmS для этой программы также допускает 
один $\lPORF$ цикличный граф 
(граф \circledb{D} на рисунке~\ref{fig:lb-nodep-execs}).

Шаги \circledb{1} --- \circledb{5} модифицированного алгоритма 
совпадают с соответствующими шагами оригинального алгоритма 
(смотри раздел~\ref{sec:genmc-ex}).
Однако на шаге \circledb{6} модифицированный алгоритм 
должен рассмотреть новое перепосещение события 
$\rlab{}{y}{0}$ событием $\wlab{}{y}{1}$, 
так как данные события формируют \LB гонку.
Заметим, что оригинальный алгоритм не рассматривал это перепосещение, 
так как событие $\rlab{}{y}{0}$ принадлежит $\lPORF$ префиксу 
события $\wlab{}{y}{1}$.
Далее алгоритм совершает шаги \circledg{6a} - \circledg{6b}, 
показанные ниже. 

\input{Dissertation/fig/alg-wmc-lb-step1}

А именно, при перепосещении события чтения $\rlab{}{y}{0}$ 
изменяется входящее в него $\lRF$ ребро и, следовательно, 
прочитанное значение --- метка события становится равна $\rlab{}{y}{1}$.
Также при ограничении графа удаляются все события, 
следующие за перепосещаемым событие чтением в программном порядке. 
Далее алгоритм входит в фазу сертификации --- 
его задача сертифицировать сделанно обещание записи $\wlab{}{x}{0}$.
Однако достичь этого не удается, так как выполнение 
следующей инструкции приводит к добавлению события $\wlab{}{x}{1}$
(из-за наличия в программе зависимости по данным от события чтения $\rlab{}{y}{1}$), 
после чего исполнение сертифицирумого потока оканчивается. 
Таким образом, алгоритму не удается сертифицировать сделанные обещания 
и граф, полученный на шаге \circledg{6b}, считается заблокированным.

Далее модифицированный алгоритм повторяет шаги 
\circledb{7} --- \circledb{8} оригинального алгоритма. 
На шаге \circledb{8} модифицированый алгоритм вновь 
обнаруживает \LB гонку --- теперь между событиями 
$\wlab{}{x}{1}$ и $\rlab{}{x}{0}$.
Вновь запускается фаза сертификации, 
которая на этот раз оканчивается успешно.
Это завершает исследование последнего консистентного графа сценария исполнения,
содержащего $\lPORF$ цикл 
(этот граф соответствует графу \circledb{D} на рисунке~\ref{fig:lb-nodep-execs}).

\input{Dissertation/fig/alg-wmc-lb-step2}

\section{Экспериментальное исследование \wmc}
\label{sec:wmc-eval}

\newcommand{\RQ}[1]{\textbf{RQ{#1}.}}

Для того, чтобы экспериментально оценить эффективность инструмента \wmc, было выполнено экспериментальное исследование.


\subsection*{Методология}

В данном подразделе опишем  методологию экспериментального исследования: исследовательские вопросы, инструменты, использованные для сравнения 
с \wmc, планируемые эксперименты и используемые наборы данных, конфигурация используемой для экспериментов системы.

\paragraph{Исследовательские вопросы.}

В рамках предложенной методологии Были 
сформулированы следующие исследовательские вопросы.
\begin{enumerate}

  \item[\RQ{1}] 
    Как часто на практике встречаются гонки с буферизацией операций чтения
    и каковы накладные расходы на их обнаружение?

  \item[\RQ{2}] 
    На сколько эффективен \wmc по сравнению с другими инструментами, 
    которые поддерживают модели памяти, 
    сохраняющие синтаксические или семантические зависимости? 

  \item[\RQ{3}] 
    Какова производительность \wmc в худшем случае, 
    когда программа содержит множество гонок с буферизацией операций чтения? 
    
\end{enumerate}

Так как в модели \WkmS, благодаря свойству \LBRF, программы, 
свободные от гонок с буферизацией операций чтения, 
имеют только \RCMM консистентные сценарии исполнения, 
то ответ на первый вопрос позволит определить, как часто 
на практике поведение инструмента \wmc отличается от поведения 
оригинального инструмента \genmc.
Ответ на второй вопрос и третий вопросы позволит оценить то, на сколько эффективными 
оказываются оптимизации, реализованные в \wmc благодаря 
наличию свойств \LBRF и \CL  модели \WkmS.


\paragraph{Инструменты проверки моделей.}

Для сравнения с  \wmc были выбраны следующие инструменты. 

\textbf{\genmc}~\cite{Kokologiannakis:PLDI2019,Kokologiannakis:CAD2021} ---
инструмент проверки моделей, выполняющий верификацию в модели памяти \RCMM%
\footnote{\genmc также может быть адаптирован для поддержки 
  произвольной модели памяти, сохраняющей программный порядок.}, 
которая относится к классу моделей, сохраняющих программный порядок.  
Отметим, что в отличие от всех других инструментов, используемых в экспериментах, 
только \genmc не использует спекулятивное исполнение инструкций, так как для класса моделей, сохраняющих программный порядок,
нет необходимости в его использовании при моделировании поведения программы. 
Поэтому ожидаемо, что \genmc будет показывать 
лучшее время работы по сравнению со всеми другими инструментами. 
%% По этой причине, а также потому, что \wmc изначально разрабатывался 
%% на основе \genmc, время работы \genmc в экспериментах 
%% используется в качестве базового измерения. 

\textbf{\hmc} --- 
расширение \genmc и поддерживает  модель памяти \IMM
\footnote{\hmc также может быть адаптирован для поддержки 
  произвольной модели памяти, сохраняющей синтаксические зависимости.},
которая относится к классу моделей, сохраняющих синтаксические зависимости~\cite{Kokologiannakis-Vafeiadis:ASPLOS2020}.  
Алгоритм, который лежит в основе \hmc, отслеживает синтаксические зависимости между событиями, 
чтобы предотвратить появление циклов причинно-следственной связи. 

 \textbf{\Nidhugg} --- инструмент проверки моделей, который поддерживает модель памяти мультипроцессоров \POWER, 
относящуюся к классу моделей, сохраняющих синтаксические зависимости~\cite{Abdulla-al:TACAS2015,Abdulla-al:CAV2016}.  
Аналогично \hmc, данный инструмент отслеживает синтаксические зависимости между событиями.

\textbf{\rmem} --- симулятор для выполнения многопоточных программ с учетом слабых сценариев исполнения  поддерживает множество моделей памяти различных мультипроцессоров~\cite{RMEM}. 
В рамках данной работы в экспериментах используется режим \PrmARM%
~\cite{Pulte-al:PLDI2019}, так как данный режим является 
наиболее эффективным в инструменте \rmem.
Режим \PrmARM проводит верификацию в модели памяти \ARMv{8}, 
которая относится к классу моделей, сохраняющих синтаксические зависимости. 
При этом для моделирования спекулятивного выполнения инструкций 
используется механизм обещаний~\cite{Kang-al:POPL17}.  

\textbf{\CDSChecker}~\cite{Norris-Demsky:OOPSLA2013} --- 
ещё одни инструмент проверки моделей, который выполняет  верификацию 
в неформально определенной модифицированной версии модели памяти \CMM.
Данный инструмент также использует механизм обещаний~\cite{Kang-al:POPL17}, 
чтобы моделировать спекулятивное исполнение и отслеживать
семантические зависимости между событиями. 
Таким образом, среди всех перечисленных инструментов,
только \CDSChecker выполняет верификацию в модели памяти, 
относящейся к классу моделей, сохраняющих семантические зависимости. 
Следовательно, данный инструмент наиболее близок по функциональности к \wmc.

Все вышеперечисленные инструменты выполняют проверку 
моделей с явным представлением состояний, 
но без сохранения пространства состояний (explicit-state stateless model checking). 
Эти инструменты, в первую очередь, предназначены 
для верификации многопоточных программ с учетом слабых моделей памяти. 
Более того, все инструменты, за исключением \genmc, выполняют верификацию 
в моделях памяти, относящихся к классу моделей, 
сохраняющих синтаксические или семантические зависимости. 
Данные инструменты были выбраны на основе публикаций 
на ведущих конференциях по тематике языков программирования 
и формальной верификации программ%
~\cite{Kokologiannakis:PLDI2019,Kokologiannakis:CAD2021,Kokologiannakis-Vafeiadis:ASPLOS2020,
Abdulla-al:TACAS2015,Abdulla-al:CAV2016,Pulte-al:PLDI2019,Norris-Demsky:OOPSLA2013}, 
и среди инструментов, удовлетворяющих приведенным выше свойствам, 
составляют достаточно полный список.


\paragraph{Эксперименты и наборы данных.} 

Для того, чтобы ответить на \emph{первый исследовательский вопрос} 
было поставлено два эксперимента. 

В рамках первого эксперимента были рассмотрены 
%% TODO: дождаться уточнения от Михалиса по поводу этих тестов
%% реализации 13 алгоритмов блокировки из работы%
%% ~\cite{Oberhauser-al:ASPLOS2021},
5 реализаций многопоточной очереди из работы%
~\cite{Kokologiannakis:PLDI2019}
и 11 реализаций многопоточных структур данных из работы%
\footnote{Были рассмотрены только 11 из 43 
тестовых программ из данной работы, 
так как эти программы были написаны на языке C++,
а \genmc поддерживает язык C и только подмножество возможностей языка C++.}
~\cite{Ou-Demsky:OOPSLA18}.
На данных программах был запущен инструмент \wmc с целью 
поиска гонок с буферизацией операций чтения.

%% В таблицу~\ref{tab:lbraces} в первую колонку
%% вносилось название тестовой программы, 
%% а во вторую колонку символ~``\cmark''~если соответствующая 
%% программа \textbf{не содержит} гонок данного вида и символ~``\xmark'' иначе.

В рамках второго эксперимента была рассмотрена 241 многопоточная программа 
из набора тестовых программ инструмента \genmc, 
который включает как небольшие ``лакмусовые тесты''~\cite{Alglave-al:TACAS2011}, 
так и реализации различных многопоточных структур данных.
Данный набор программ был разбит на две группы:
те программы, которые содержат гонки с буферизацией чтения 
(28 программ, название группы LB-racy)
и те, которые не содержат гонок данного типа 
(213 программ, название группы LB-race-free).
Далее было измерено время работы инструментов \genmc, \hmc и \wmc на данных программах
с целью измерить накладные расходы на поиск гонок с буферизацией операция чтения.
  
%% Результаты замеров были оформлены в виде таблицы~\ref{tab:overhead}.
%% В данной таблице в первой колонке приводится название группы, 
%% а в остальных колонках суммарное время работы инструментов 
%% на соответствующей группе программ в секундах.

Для ответа на \emph{второй исследовательский вопрос}, 
то есть для сравнения \wmc с аналогами, 
было использовано два тестовых набора программ.
На программах из этих тестовых наборов были запущены 
инструмент \wmc и другие инструменты c целью сравнить их эффективность.

\textit{Первый набор тестовых программ} был взят 
из соревнования по верификации программ \SVCOMP~\cite{SVCOMP}, 
а именно из категорий \texttt{pthread} и \texttt{pthread-atomic}.
Тестовые программы были модифицированы путем замены 
обращений к разделяемым переменным на атомарные обращения 
с ослабленным (relaxed) режимом доступа 
для того, чтобы спровоцировать появление гонок с буферизацией операций чтения. 
Отметим, что на некоторых программах из данного набора 
инструмент \Nidhugg был исключен из сравнения, так как он не поддерживает 
атомарные инструкции чтения-модификации-записи (\RMW) в модели памяти \POWER. 
%% Соответствующие ячейки в таблице~\ref{tab:svcomp} оставлены пустыми.

\textit{Второй набор тестовых программ} состоит из 
реализаций различных многопоточных структур данных, 
взятых из тестового набора \CDSChecker~\cite{Norris-Demsky:OOPSLA2013}. 
В данных программах все циклы были развернуты 
на определенную фиксированную глубину, чтобы исключить из сравнения тот фактор, 
поддерживают ли инструменты продвинутые методы рассуждения о циклах или нет. 
В рамках экспериментов с данным тестовым набором инструмент \Nidhugg 
был исключен из сравнения по той же причине, что 
и в случае некоторых программ из предыдущего тестового набора. 
Инструмент \rmem также был исключен из-за сложности портирования 
программ из данного набора в формат входных данных этого инструмента.

%% Данные, полученных в ходе этого эксперимента, были занесены в таблицу~\ref{tab:svcomp}. 
%% В первой колонке приводится название тестовой программы, 
%% а в остальных колонках время работы инструментов 
%% на соответствующей программе в секундах.
%% При этом было установленно максимальное ограничение на время работы --- 30 минут.
%% Если время работы инструмента выходило за этот предел, 
%% то его исполнение на данной тестовой программе обрывалось. 
%% В таблице этот факт отображается знаком \timeoutNoSpc~
%% в соответствующей колонке.
%% Также отметим, что на некоторых программах из данного набора 
%% инструмент \Nidhugg был исключен из сравнения, так как он не поддерживает 
%% атомарные инструкции чтения-модификации-записи (\RMW) в модели памяти \POWER. 
%% Соответствующие ячейки в таблице~\ref{tab:svcomp} оставлены пустыми.

%% Замеры времени работы инструментов на этом тестовом наборе 
%% были занесены в таблицу~\ref{tab:datastructures}. 
%% В первой колонке таблицы приводится название тестовой программы, 
%% а в остальных колонках время работы инструментов 
%% на соответствующей программе в секундах.
%% Максимальное ограничение на время работы также составляло 30 минут.

Наконец, для ответа на \emph{третий исследовательский вопрос}, 
было измерено количество исследованных \wmc 
сценариев исполнения для нескольких синтетических программ, 
содержащих множество гонок с буферизацией операций чтения. 
А именно, подсчитывалось количество исследованных уникальных сценариев исполнения,
процент повторяющихся сценариев, посещенных \wmc несколько раз, 
от количества уникальных сценариев и процент блокированных 
сценариев --- то есть тех сценариев, которые 
были отброшены во время работы инструмента 
из-за невозможности сертифицировать все сделанные обещания.

Кратко опишем тестовые программы, использованные в данном эксперименте. 
Программы \bmark{LB+ctrl(N)} и \bmark{LB+data(N)}
являются аналогом программы \ref{ex:lb-nodep} 
из раздела \cref{sec:models-classes},
за исключением того, что в этих программах 
$\lPORF$ цикл охватывает \texttt{N} потоков.
Также, в программе \bmark{LB+ctrl(N)} используются зависимости 
по потоку управления, а не зависимости по данным как в \bmark{LB+data(N)}.
Тестовая программа \bmark{LB-nodep(N)} является аналогом 
программы \ref{ex:lb-spec} из раздела \ref{sec:models-requirements}, 
за исключением того, что в этой программе 
$\lPORF$ цикл также охватывает \texttt{N} потоков.
Наконец, программа \bmark{LB-pairs(N)} содержит \texttt{N}
независимых пар потоков, где каждая пара образует 
подпрограмму, аналогичную \ref{ex:lb-spec}.

%% Данные, полученные в ходе последнего эксперимента, приведены в таблице~\ref{tab:lb}.
%% Первая колонка данной таблицы содержит название тестовой программы. 
%% Вторая колонка --- количество уникальных сценариев исполнения, 
%% исследованных \wmc. Третья колонка --- процент повторяющихся
%% сценариев, посещенных \wmc несколько раз, от 
%% количества уникальных сценариев. 
%% Последняя колонка показывает процент блокированных 
%% сценариев --- то есть тех сценариев, которые 
%% были отброшены во время работы инструмента 
%% из-за невозможности сертифицировать все сделанные обещания.

\paragraph{Конфигурация системы.} 

Все эксперименты проводились на системе Dell PowerEdge M620 blade
с двумя процессорами Intel Xeon E5-2667 v2 (8 ядер, 3.3 GHz)
и 256GB оперативной памяти. Операционная система --- Debian.
Использовалась библиотека \LLVM версии 7.
Также использовались следующие версии сравниваемых инструментов: 
\hmc (v0.5), \genmc (v0.5), \Nidhugg (v0.3), 
коммит с хеш-кодом \#da671f7 для \CDSChecker
и коммит с хеш-кодом \#85c8130 для \rmem (v0.1).

\subsection*{Результаты}

Проанализируем результаты, полученные в ходе описанных экспериментов.

\paragraph{\RQ{1}}
\textit{Как часто на практике встречаются гонки с буферизацией операций 
чтения и каковы накладные расходы на их обнаружение?}

Результаты первого эксперимента (таблица~\ref{tab:lbraces})
подтверждают гипотезу, что гонки с буферизацией операций чтения 
довольно редко встречаются на практике: 
из 16 тестовых программ ни в одной не были найдены гонки данного вида.
%% из 28 тестовых программ только в 2 были найдены гонки данного вида.

\input{Dissertation/table/lbraces}

Результаты второго эсперимента представлены в таблице~\ref{tab:overhead}.
В этой таблице, как и во всех остальных таблицах в этом разделе, 
время работы инструментов приводится в секундах.  
По результатам эксперимента, согласно данным во второй строке таблицы, 
можно видеть, что процесс обнаружения гонок с буферизацией операций чтения 
в инструменте \wmc приводит к накладным расходам на время работы 
примерно в 25\% процентов по сравнению с временем работы \genmc.
Тем не менее, эти накладные расходы существенно ниже чем 
расходы на поддержание информации о синтаксических зависимостях
в инструменте \hmc, которые увеличивают время работы \hmc
на программах из второй группы в два раза.  
Также заметим, что на программах из обоих групп
время работы \wmc существенно меньше времени работы \hmc. 

\input{Dissertation/table/overhead}

\paragraph{\RQ{2}}
\textit{На сколько эффективен \wmc по сравнению с другими инструментами, 
которые поддерживают модели памяти, сохраняющие синтаксические 
или семантические зависимости?}

Проанализируем данные
\footnote{В таблицах \ref{tab:svcomp} и \ref{tab:datastructures}
знак \timeoutNoSpc~ в ячейки таблицы означает, что 
время работы инструмента на данной тестовой программе 
вышло за рамки установленного максимального ограничения на время работы,
составляющего 30 минут.}
из таблицы~\ref{tab:svcomp}. 
Можно видеть, что \Nidhugg%
\footnote{В таблице~\ref{tab:svcomp} для программ, 
на которых \Nidhugg не запускался ввиду отстутствия 
поддержки инструкций \RMW, соответствующие ячейки оставлены пустыми}.
и \rmem работаю существенно медленнее остальных 
конкурентов почти на всех тестовых программах. 
Это объясняется особенностью используемых этими инструментами алгоритмов.
\Nidhugg выполняет дорогостоящие проверки консистентности
на каждом шаге исполнения программы.
\rmem строит линейный порядок на множестве всех операций записи.

\input{Dissertation/table/svcomp}

Единственная программа, на которой \Nidhugg показывает 
лучший результат по сравнению с остальными --- это \bmark{szymanski}.
Дело в том, что в данной программе используется 
последовательно-согласованные барьеры памяти.
\Nidhugg выполняет проверку последовательно-согласованной
консистентности на каждом шаге исполнения программы, в то время 
как остальные инструменты откладывают эту проверку 
до завершения исследования сценария исполнения. 
В то время как в большинстве случаев выполнение этой дорогостоящей проверки 
на каждом шаге существенно замедляет \Nidhugg, 
в случае программы \bmark{szymanski} это позволяет 
раньше отфильтровать неконсистентные сценарии исполнения 
и таким образом сократить пространство перебора. 

Что касается сравнения с \CDSChecker, то можно видеть,
что этот инструмент опережает \wmc только 
на программах \bmark{reorder} и \bmark{singleton}, 
а на всех остальных программах \CDSChecker работает существенно 
медленнее чем \wmc, и, в некоторых случаях 
(например, \bmark{fib\_bench} и \bmark{sigma}), 
даже превышает заданный лимит времени, в то время как 
\wmc укладывается в этот лимит.
Худшее время работы \CDSChecker объясняется тем, что 
данный инструмент вынужден тратить много времени 
на попытку сертификации неосуществимых обещаний. 
В то же время, свойство \LBRF, помогает \wmc 
рассматривать меньше потенциальных обещаний, 
а свойство \CL помогает быстро проверить 
сертифицируемость оставшихся обещаний.  

Заметим, что на тестовых программах из этого набора 
время работы \hmc также примерно в два раза больше времени работы \genmc, 
как и в случае данных из таблицы~\ref{tab:overhead}.
Это приводит к тому, что на некоторых тестовых программах 
(например, \bmark{sigma} и \bmark{indexer}) \wmc обгоняет \hmc.
Это вновь подтверждает гипотезу, что для программ, 
которые содержат мало гонок c буферизацией операций чтения, 
схема с запуском спекулятивного исполнения только в случае 
обнаружения этих гонок (\wmc) оказывается более эффективной, 
чем постоянное отслеживание синтаксических зависимостей между событиями (\hmc). 

Тем не менее, на программах \bmark{fib\_bench} и \bmark{peterson}
\wmc показывает худшее время по сравнению с \hmc.
Для \bmark{fib\_bench} проблема заключается в том, 
что \wmc вынужден тратить много времени 
на попытку сертификации неосуществимых обещаний, 
это проблема с которой также сталкивается \CDSChecker.
Что касается \bmark{peterson} то здесь проблема 
заключается в самой модели \WkmS --- для 
данной программы эта модель памяти просто допускает 
существенно большее количество слабых сценариев исполнения, 
чем модель \IMM, относительно которой выполняет верификацию \hmc. 

\input{Dissertation/table/realworld}

Результаты экспериментов, приведенные в таблице~\ref{tab:datastructures},
в целом подтверждают приведенные выше наблюдения. 
Время работы \CDSChecker на порядок больше времени 
работы других инструментов на всех тестовых программах, 
более того на 3 из 5 программ \CDSChecker не укладывается 
в заданный лимит времени. Время работы \hmc примерно в
два раза выше чем у \genmc~---~ замедление вызвано накладными расходами
на поддержание информации о синтаксических зависимостях между событиями.
На программах из этой группы \wmc вновь обходит \hmc, 
так как первые три программы из списка вообще не содержат 
гонок с буферизацией операций чтения, 
а две другие хоть и содержат гонки данного вида, 
обработка этих гонок все равно оказывается 
более эффективной, чем расходы на отслеживание синтаксических зависимостей.

\input{Dissertation/table/lb}

\paragraph{\RQ{3}}
\textit{Какова производительность \wmc в худшем случае, 
когда программа содержит множество гонок с буферизацией операций чтения?}

Проанализируем поведение инструмента \genmc
на синтетических программах (таблица~\ref{tab:lb}).
\wmc исследует одинаковое количество уникальных сценариев
исполнения для всех программ за исключением \bmark{LB+ctrl}.
В случае последней наличие зависимостей по управлению 
предотвращает появление большего количества слабых 
сценариев исполнения, содержащих $\lPORF$ циклы. 
За исключением программы \bmark{LB-pairs} 
количество повторяющихся и заблокированных сценариев исполнения 
остается очень маленьким. Однако для \bmark{LB-pairs}
количество повторяющихся сценариев исполнения 
в несколько раз превышает количество уникальных сценариев, 
а количество заблокированных сценариев составляет одну треть 
от количества уникальных. 
В подобных случаях \wmc может потребоваться 
сохранять информацию о всех исследованных сценариях исполнения, 
чтобы избежать необходимости их повторного посещения. 
Однако реализация данной стратегии приведет 
к кратному увеличению потребляемой памяти.  

\subsubsection*{Выводы}

Подводя итоги, можно сделать следующие выводы. 

В первую очередь отметим, что согласно результатам экспериментов,
гонки с буферизацией чтения действительно встречаются 
довольно редко в не синтетических многопоточных программах, 
и что затраты на их обнаружения не доминируют 
в суммарном времени работы инструмента.

Что касается сравнения с другими инструментами, 
то \wmc оказывается намного более эффективным, чем \CDSChecker~---~ 
единственный инструмент среди аналогов, который 
также выполняет верификацию в модели памяти, сохраняющей семантические зависимости.    
Вместе с тем на многих тестовых программах \wmc также опережает 
и другие инструменты (например, \hmc),
выполняющие верификацию в моделях памяти, 
сохраняющей синтаксические зависимости, даже 
несмотря на то, что этот класс моделей устроен более просто
и, как правило, допускает меньше возможных 
слабых сценариев исполнения чем модель \WkmS.
Это особенно заметно на программах, 
которые не содержат гонки с буферизацией операций чтения, 
либо содержат малое количество таких гонок. 
Это преимущество напрямую связано с реализованной в \wmc 
оптимизацией на основе свойства \LBRF --- 
для программ, свободных от буферизации операций чтения, 
\wmc не задействует механимз спекулятивного исполнения 
и выполняет исследование только \RCMM консистентных сценариев исполнения программы.

Кроме того отметим, что \wmc показывает худшую производительность 
по сравнению с другими инструментами на тех тестовых программах, 
которые практический не используют примитивы для синхронизации между потоками, 
такие как барьеры памяти или более сильные режимы доступа к атомарным переменным. 
К таким программам относится, например, тестовая программа \bmark{peterson}, 
реализующая алгоритм блокировки Петерсона. 
Подобные программы используют только ослабленные (relaxed)
режимы обращения к атомарным переменным.
Эта ситуация крайне нехарактерная для большинства 
практические значимых многопоточных программ, 
так как использование только ослабленных обращений к памяти
дает крайне мало гарантий о поведении программ. 
В остальных случаях \wmc показывает производительность 
лучшую по отношению к другим инструментам
и сравнимую с производительностью исходного инструмента~\genmc.

Наконец, на некоторых синтетических программах производительность \wmc 
может существенно ухудшится из-за необходимости исследовать 
избыточные дублирующиеся или заблокированные сценарии исполнения. 
Эта проблему можно частично решить путем сохранения информации
обо всех исследованных сценариях исполнения, увеличив таким образом   
количеством потребляемой инструментом оперативной памяти.
